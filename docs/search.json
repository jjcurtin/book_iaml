[
  {
    "objectID": "003_regression.html#overview-of-unit",
    "href": "003_regression.html#overview-of-unit",
    "title": "3  Introduction to Regression Models",
    "section": "3.1 Overview of Unit",
    "text": "3.1 Overview of Unit\n\n3.1.1 Learning Objectives\n\nUse of root mean square error (RMSE) in training and validation sets for model performance evaluation\nThe General Linear Model as a machine learning model\n\nExtensions to categorical variables (Dummy coding features)\nExtensions to interactive and non-linear effects of features\n\nK Nearest Neighbor (KNN)\n\nHyperparameter \\(k\\)\nScaling predictors\nExtensions to categorical variables\n\n\n\n\n\n3.1.2 Readings\n\nJames et al. (2023) Chapter 3, pp 59 - 109\n\n\n\n3.1.3 Lecture Videos\n\nLecture 1: Overview ~ 13 mins\nLecture 2: The Simple Linear Model, Part 1 ~ 16 mins\nLecture 3: The Simple Linear Model, Part 2 ~ 12 mins\nLecture 4: Extension to Multiple Predictors ~ 15 mins\nLecture 5: Extension to Categorical Predictors ~ 30 mins\nLecture 6: Extension to Interactions and Non-Linear Effects ~ 11 mins\nLecture 7: Introduction to KNN ~ 9 mins\nLecture 8: The hyperparameter k ~ 13 mins\nLecture 9: Distance and Scaling in KNN ~ 9 mins\nLecture 10: KNN with Ames ~ 12 mins\n\n\n\n\n3.1.4 Application Assignment and Quiz\n\nclean data: train; validate; test\ndata dictionary\nlm qmd\nknn qmd\nsolution: lm; knn\n\nPost questions to the Slack channel for application assignments.\nSubmit the application assignment here and complete the unit quiz by 8 pm on Wednesday, February 7th\n\nOur goal in this unit is to build a machine learning regression model that can accurately (we hope) predict the sale_price for future sales of houses (in Iowa? more generally?)\nTo begin this project we need to:\n\nSet up conflicts policies\nWe will hide this in future units\n\n\noptions(conflicts.policy = \"depends.ok\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\n\nℹ SHA-1 hash of file is \"175d942e14f108d74912bfb2593b77637328ecb1\"\n\ntidymodels_conflictRules()\n\n\n\nLoad the packages we will need. I am shifting here to only loading tidymodels and tidyverse because the other functions we need are only called occasionally (so we will call them by namespace to see how that “feels”.)\n\n\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\n\n\n\nsource additional class functions libraries\nWe will hide this in future units\n\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\n\nℹ SHA-1 hash of file is \"c045eee2655a18dc85e715b78182f176327358a7\"\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\n\nℹ SHA-1 hash of file is \"def6ce26ed7b2493931fde811adff9287ee8d874\"\n\n\n\nset display options\nWe will hide this in future units\n\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\n\n\nhandle paths\n\n\npath_data &lt;- \"./data\"\n\n\n\nSet up function to class ames data (copied with one improvement from last unit)\n\n\nclass_ames &lt;- function(df){\n  df |&gt;\n    mutate(across(where(is.character), factor)) |&gt; \n    mutate(overall_qual = factor(overall_qual, levels = 1:10), \n1           garage_qual = suppressWarnings(fct_relevel(garage_qual,\n                                                      c(\"no_garage\", \"po\", \"fa\", \n                                                    \"ta\", \"gd\", \"ex\"))))\n}\n\n\n1\n\nWarnings should be considered errors until investigated. Once investigated, they can be ignored. To explicitly ignore, use suppressWarnings()\n\n\n\n\n\n\nOpen the cleaned training set\n\n\ndata_trn &lt;- \n  read_csv(here::here(path_data, \"ames_clean_class_trn.csv\"), \n           col_types = cols()) |&gt;  \n  class_ames() |&gt; \n  glimpse()\n\nRows: 1,465\nColumns: 10\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;fct&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;fct&gt; ta, ta, no_garage, ta, ta, ta, ta, no_garage, no_garage, …\n$ ms_zoning    &lt;fct&gt; res_high, res_low, res_low, res_low, res_low, res_med, re…\n$ lot_config   &lt;fct&gt; inside, corner, fr2, fr2, inside, inside, inside, inside,…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, town_inside, town_end, duplex,…\n\n\n\n\nOpen the cleaned validation set\n\n\ndata_val &lt;- read_csv(here::here(path_data, \"ames_clean_class_val.csv\"),\n                     col_types = cols()) |&gt; \n  class_ames() |&gt; \n  glimpse()\n\nRows: 490\nColumns: 10\n$ sale_price   &lt;dbl&gt; 215000, 189900, 189000, 171500, 212000, 164000, 394432, 1…\n$ gr_liv_area  &lt;dbl&gt; 1656, 1629, 1804, 1341, 1502, 1752, 1856, 1004, 1092, 106…\n$ lot_area     &lt;dbl&gt; 31770, 13830, 7500, 10176, 6820, 12134, 11394, 11241, 168…\n$ year_built   &lt;dbl&gt; 1960, 1997, 1999, 1990, 1985, 1988, 2010, 1970, 1971, 197…\n$ overall_qual &lt;fct&gt; 6, 5, 7, 7, 8, 8, 9, 6, 5, 6, 7, 9, 8, 8, 7, 8, 6, 5, 5, …\n$ garage_cars  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 3, 2, 3, 1, 1, 2, …\n$ garage_qual  &lt;fct&gt; ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, t…\n$ ms_zoning    &lt;fct&gt; res_low, res_low, res_low, res_low, res_low, res_low, res…\n$ lot_config   &lt;fct&gt; corner, inside, inside, inside, corner, inside, corner, c…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, one_fam, town_end, one_fam, on…\n\n\nNOTE: Remember, I have held back an additional test set that we will use only once to evaluate the final model that we each develop in this unit.\n\nWe will also make a dataframe to track validation error across the models we fit\n\nerror_val &lt;- tibble(model = character(), rmse_val = numeric()) |&gt; \n  glimpse()\n\nRows: 0\nColumns: 2\n$ model    &lt;chr&gt; \n$ rmse_val &lt;dbl&gt; \n\n\n\nWe will fit regression models with various model configurations.\nThese configurations will differ with respect to statistical algorithm:\n\nA General Linear Model (lm) - a parametric approach\nK Nearest Neighbor (KNN) - a non-parametric approach\n\nThese configurations will differ with respect to the features\n\nSingle feature (i.e., simple regression)\nVarious sets of multiple features that vary by:\n\nRaw predictors used\nTransformations applied to those predictors as part of feature engineering\nInclusion (or not) of interactions among features\n\nThe KNN model configurations will also differ with respect to its hyperparameter- \\(k\\)\n\n\nTo build models that will work well in new data (e.g., the data that I have held back from you so far):\n\nWe have split the remaining data into a training and validation set for our own use during model building\nWe will fit models in train\nWe will evaluate them in validation\n\nRemember that we:\n\nUsed a 75/25 stratified (on sale_price) split of the data at the end of cleaning EDA to create training and validation sets\nAre only using a subset of the available predictors. The same ones I used for the EDA unit\n\nYou will work with all of my predictors and all the predictors you used for your EDA when you do the application assignment for this unit\n\nPause for a moment to answer this question:\n\n\n\n\n\n\nQuestion: Why do we need independent validation data to select the best model configuration? In other words, why cant we just fit and evaluate all of the models in our one training set?\n\n\n\n\n\n\n\nShow Answer\nThese models will all overfit the dataset within which they are fit to some degree.   \nIn other words, they will predict both systematic variance (the DGP) and some noise in \nthe training set.  However, they will differ in how much they overfit the training set.   \nAs the models get more flexible they will have the potential to overfit to a greater degree.\nModels with a larger number of features (e.g., more predictors, features based on interactions\nas well as raw predictors) will overfit to a greater degree.  All other things equal, the\nnon-parametric KNN will also be more flexible than the general linear model so it may \noverfit to a greater degree as well if the true DGP is linear on the features.  \nTherefore, just because a model fits the training set well does not mean it will work \nwell in new data because the noise will be different in every new dataset.  \nThis overfitting will be removed from our performance estimate if we calculate it \nwith new data (the validation set).\n\n\n\n\n\n\nLet’s take a quick look at the available raw predictors in the training set\n\ndata_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\ndata_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n10\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n5\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nn_unique\ntop_counts\n\n\n\n\noverall_qual\n0\n1\n10\n5: 424, 6: 350, 7: 304, 8: 176\n\n\ngarage_qual\n0\n1\n5\nta: 1312, no_: 81, fa: 57, gd: 13\n\n\nms_zoning\n0\n1\n7\nres: 1157, res: 217, flo: 66, com: 13\n\n\nlot_config\n0\n1\n5\nins: 1095, cor: 248, cul: 81, fr2: 39\n\n\nbldg_type\n0\n1\n5\none: 1216, tow: 108, dup: 63, tow: 46\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n1\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\n\n\n\n\nRemember from our modeling EDA that we have some issues to address as part of our feature engineering:\n\nMissing values\nPossible transformation of sale_price\nPossible transformation of other numeric predictors\nWe will need to use some feature engineering techniques to handle categorical variables\nWe may need to consider interactions among features\n\nAll of this will be accomplished with a recipe\nBut first, let’s discuss/review our first statistical algorithm"
  },
  {
    "objectID": "003_regression.html#the-simple-general-linear-model-lm",
    "href": "003_regression.html#the-simple-general-linear-model-lm",
    "title": "3  Introduction to Regression Models",
    "section": "3.2 The Simple (General) Linear Model (LM)",
    "text": "3.2 The Simple (General) Linear Model (LM)\nWe will start with only a quick review of the use of the simple (one feature) linear model (LM) as a machine learning model because you should be very familiar with this statistical model at this point\n\n\\(Y = \\beta_0 + \\beta_1*X_1 + \\epsilon\\)\n\nApplied to our regression problem, we might fit a model such as:\n\n\\(sale\\_price = \\beta_0 + \\beta_1*gr\\_liv\\_area + \\epsilon\\)\n\nThe (general) linear model is a parametric model. We need to estimate two parameters using our training set\n\n\\(\\beta_0\\)\n\\(\\beta_1\\)\n\nYou already know how to do this using lm() in base R. However, we will use the tidymodels modeling approach.\n\nWe use tidymodels because:\n\nIt provides a consistent interface to many (and growing numbers) of statistical algorithms\nIt provides very strong and easy feature engineering routines (e.g., missing data, scaling, transformations, near-zero variance, collinearity) via recipes\nIt simplifies model performance evaluation using resampling approaches (that you don’t know yet!)\nIt supports numerous performance metrics\nIt is tightly integrated within the tidyverse\nIt is under active development and support\nYou can see documentation for all of the packages at the tidymodels website. It is worth a quick review now to get a sense of what is available\n\n\nTo fit a model with a specific configuration, we need to:\n\nSet up a feature engineering recipe\nUse the recipe to make a feature matrix\n\nprep() it with training data\nbake() it with data you want to use to calculate feature matrix\n\nSelect and define the statistical algorithm\nFit the algorithm in the feature matrix in our training set\n\nThese steps are accomplished with functions from the recipes and parsnip packages.\n\nWe will start with a simple model configuration\n\nGeneral linear model (lm)\nOne feature (raw gr_liv_area)\nFit in training data\n\n\nSet up a VERY SIMPLE feature engineering recipe\n\nInclude outcome on the left size of ~\nInclude raw predictors (not yet features) on the right side of ~.\n\nIndicate the training data\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area, data = data_trn) \n\n\nWe can see a summary of it to verify it is doing what you expect by calling\n\nrec\nsummary(rec)\n\n\n\nWe can then prep the recipe and bake the data to make our feature matrix from the training dataset\n\nAgain, remember we always prep a recipe with training data but use the prepped recipe to bake any data\nIn this instance we will prep with data_trn and then bake data_trn so that we have features from our training set to train/fit the model.\n\n\nrec_prep &lt;- rec |&gt; \n  prep(training = data_trn)\n\n\n\nAnd now we can bake the training data to make a feature matrix\n\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(new_data = data_trn)\n\n\nYou should always review the feature matrix to make sure it looks as you expect\n\nincludes outcome (sale_price)\nincludes expected feature (gr_liv_area)\nSample size is as expected\nNo missing data\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n2\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\n\n\n\n\nNow let’s consider the statistical algorithm\n\ntidymodels breaks this apart into two pieces for clarity\nFirst, you specify the broad category of algorithm\n\ne.g., linear_reg(), nearest_neighbor(), logistic_reg()\n\nNext, you set_mode() to indicate if if the model is for regression or classification broadly\n\nNot needed if the engine can only be used for one mode (e.g., 'linear_reg() is only for regression.\n\nThen you select a function from a specific R package (or base R) that will implement the algorithm\n\ntidymodels calls this setting the engine\ne.g., lm, kknn, glm, glmnet\n\n\n\nYou can see the available engines (and modes: regression vs. classification) for the broad classes of algorithms\nWe will work with many of these algorithms later in the course\n\nshow_engines(\"linear_reg\")\n\n# A tibble: 7 × 2\n  engine mode      \n  &lt;chr&gt;  &lt;chr&gt;     \n1 lm     regression\n2 glm    regression\n3 glmnet regression\n4 stan   regression\n5 spark  regression\n6 keras  regression\n7 brulee regression\n\nshow_engines(\"nearest_neighbor\")\n\n# A tibble: 2 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 kknn   classification\n2 kknn   regression    \n\nshow_engines(\"logistic_reg\")\n\n# A tibble: 7 × 2\n  engine    mode          \n  &lt;chr&gt;     &lt;chr&gt;         \n1 glm       classification\n2 glmnet    classification\n3 LiblineaR classification\n4 spark     classification\n5 keras     classification\n6 stan      classification\n7 brulee    classification\n\nshow_engines(\"decision_tree\")\n\n# A tibble: 5 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 rpart  classification\n2 rpart  regression    \n3 C5.0   classification\n4 spark  classification\n5 spark  regression    \n\nshow_engines(\"rand_forest\")\n\n# A tibble: 6 × 2\n  engine       mode          \n  &lt;chr&gt;        &lt;chr&gt;         \n1 ranger       classification\n2 ranger       regression    \n3 randomForest classification\n4 randomForest regression    \n5 spark        classification\n6 spark        regression    \n\nshow_engines(\"mlp\")\n\n# A tibble: 6 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 keras  classification\n2 keras  regression    \n3 nnet   classification\n4 nnet   regression    \n5 brulee classification\n6 brulee regression    \n\n\n\nYou can load even more engines from the discrim package. We will use some of these later too. You need to load the package to use these engines.\n\nlibrary(discrim, exclude = \"smoothness\") # needed for these engines\n\nshow_engines(\"discrim_linear\") \n\n# A tibble: 4 × 2\n  engine        mode          \n  &lt;chr&gt;         &lt;chr&gt;         \n1 MASS          classification\n2 mda           classification\n3 sda           classification\n4 sparsediscrim classification\n\nshow_engines(\"discrim_regularized\") \n\n# A tibble: 1 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 klaR   classification\n\nshow_engines(\"naive_Bayes\")\n\n# A tibble: 2 × 2\n  engine     mode          \n  &lt;chr&gt;      &lt;chr&gt;         \n1 klaR       classification\n2 naivebayes classification\n\n\n\nYou can also better understand how the engine will be called using translate()\nNot useful here but will be with more complicated algorithms\n\nlinear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  translate()\n\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\nModel fit template:\nstats::lm(formula = missing_arg(), data = missing_arg(), weights = missing_arg())\n\n\n\nLet’s combine our feature matrix with an algorithm to fit a model in our training set using only raw gr_liv_area as a feature\nNote the specification of\n\nThe category of algorithm\nThe engine (no need to set mode of engine b/c lm are only for the regression mode)\nThe use of the . to indicate all features in the matrix.\n\nnot that useful here because there is only one feature: gr_liv_area\nwill be useful when we have many features in the matrix\n\nWe use the the feature matrix (rather than raw data) from the training set to fit the model.\n\n\nfit_lm_1 &lt;- \n1  linear_reg() |&gt;\n2  set_engine(\"lm\") |&gt;\n3  fit(sale_price ~ ., data = feat_trn)\n\n\n1\n\ncategory of algorithm\n\n2\n\nengine\n\n3\n\nuse of . for all features and use of feature matrix from training set\n\n\n\n\n\nWe can get the parameter estimates, standard errors, and statistical tests for each \\(\\beta\\) = 0 for this model using tidy() from the broom package (loaded as part of the tidyverse)\n\nfit_lm_1 |&gt;  tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic   p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)   16561.   4537.        3.65 2.72e-  4\n2 gr_liv_area     109.      2.85     38.2  4.78e-222\n\n\n\nThere are a variety of ways to pull out the estimates for each feature (and intercept)\nOption 1: Pull all estimates from the tidy object\n\nfit_lm_1 |&gt; \n  tidy() |&gt; \n  pull(estimate)\n\n[1] 16560.9991   108.9268\n\n\n\nOption 2: Extract a single estimate using $ and row number. Be careful that order of features won’t change! This assumes the feature coefficient for the relevant feature is always the second coefficient.\n\ntidy(fit_lm_1)$estimate[[2]]\n\n[1] 108.9268\n\n\n\nOption 3: Filter tidy df to the relevant row (using term ==) and pull the estimate. Safer!\n\nfit_lm_1 |&gt; \n  tidy() |&gt; \n  filter(term == \"gr_liv_area\") |&gt; \n  pull(estimate)\n\n[1] 108.9268\n\n\n\nOption 4: Write a function if we plan to do this a lot. We include this function in the fun_ml.R script in our repo. Better still (safe and code efficient)!\n\nget_estimate &lt;- function(the_fit, the_term){\n  the_fit |&gt; \n    tidy() |&gt; \n    filter(term == the_term) |&gt; \n    pull(estimate)\n}\n\nand then use this function\n\nget_estimate(fit_lm_1, \"gr_liv_area\")\n\n[1] 108.9268\n\nget_estimate(fit_lm_1, \"(Intercept)\")\n\n[1] 16561\n\n\n\nRegardless of the method, we now have a simple parametric model for sale_price\n\\(\\hat{sale\\_price} = 1.6561\\times 10^{4} + 108.9 * gr\\_liv\\_area\\)\n\nWe can get the predicted values for sale_price (i.e., \\(\\hat{sale\\_price}\\)) in our validation set using predict()\nHowever, we first need to make a feature matrix for our validation set\n\nWe use the same recipe that we previously prepped with training data (data_trn)\nBut now we bake the validation data, data_val\n\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(new_data = data_val)\n\n\nAs always, we should skim these new features\n\nSample size matches what we expect for validation set\nNo missing data\nIncludes expected outcome and features\n\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n2\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1493.0\n483.78\n480\n1143.5\n1436\n1729.5\n3608\n0.92\n1.16\n\n\nsale_price\n0\n1\n178512.8\n75493.59\n35311\n129125.0\n160000\n213000.0\n556581\n1.42\n2.97\n\n\n\n\n\n\nNow we can get predictions using our model with validation features\npredict() returns a dataframe with one column named .pred and one row for every observation in dataframe (e.g., validation feature set)\n\npredict(fit_lm_1, feat_val)\n\n# A tibble: 490 × 1\n     .pred\n     &lt;dbl&gt;\n 1 196944.\n 2 194003.\n 3 213065.\n 4 162632.\n 5 180169.\n 6 207401.\n 7 218729.\n 8 125923.\n 9 135509.\n10 133004.\n# ℹ 480 more rows\n\n\n\nWe can visualize how well this model performs in the validation set by plotting predicted sale_price (\\(\\hat{sale\\_price}\\)) vs. sale_price (ground truth in machine learning terminology) for these data\nWe might do this a lot so let’s write a function. We have also included this function in fun_ml.R\n\nplot_truth &lt;- function(truth, estimate) {\n  ggplot(mapping = aes(x = truth, y = estimate)) + \n    geom_abline(lty = 2, color = \"red\") + \n    geom_point(alpha = 0.5) + \n    labs(y = \"predicted outcome\", x = \"outcome\") +\n    coord_obs_pred()   # scale axes uniformly (from tune package)\n}\n\n\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_1, feat_val)$.pred)\n\n\n\n\nPerfect performance would have all the points right on the dotted line (same value for actual and predicted outcome)\n\nOur model doesn’t do that well yet. Not surprising\nPattern also has some indication of fanning of residuals AND some non-linearity with higher outcome scores that suggests need for a power transformation of outcome (e.g., log)\nThis is consistent with our earlier modeling EDA\nPerhaps not that bad here b/c both sale_price and gr_liv_area were positively skewed\nWe will need consider this eventually\n\n\nWe can quantify model performance by selecting a performance metric\n\nThe yardstick package within the tidymodels framework supports calculation of many performance metrics for regression and classification models\nSee the list of all currently available metrics\n\nRoot mean square error (RMSE) is a common performance metric for regression models\n\nYou focused on a related metric, sum of squared error (SSE), in PSY 610/710\nRMSE simply divides SSE by N (to get mean squared error; MSE) and then takes the square root to return the metric to the original units for the outcome variable\nIt is easy to calculate using rmse_vec() from the yardstick package\n\n\nrmse_vec(truth = feat_val$sale_price, \n         estimate = predict(fit_lm_1, feat_val)$.pred)\n\n[1] 51375.08\n\n\n\nLet’s record how well this model performed in validation so we can compare it to subsequent models\n\nerror_val &lt;- bind_rows(error_val, \n                       tibble(model = \"simple linear model\", \n                              rmse_val = rmse_vec(truth = feat_val$sale_price, \n                                                  estimate = predict(fit_lm_1,\n                                                                     feat_val)$.pred)))\nerror_val\n\n# A tibble: 1 × 2\n  model               rmse_val\n  &lt;chr&gt;                  &lt;dbl&gt;\n1 simple linear model   51375.\n\n\nNOTE: I will continue to bind RMSE to this dataframe for newer models but plan to hide this code chuck to avoid distractions. You can reuse this code repeatedly to track your own models if you like. (Perhaps we should write a function??)\n\nFor explanatory purposes, we might want to visualize the relationship between a feature and the outcome (in addition to examining the parameter estimates and the associated statistical tests)\n\nHere is a plot of \\(\\hat{sale\\_price}\\) by gr_liv_area superimposed over a scatterplot of the raw data from the validation set\n\n\nfeat_val |&gt; \n  ggplot(aes(x = gr_liv_area)) +\n    geom_point(aes(y = sale_price), color = \"gray\") +\n    geom_line(aes(y = predict(fit_lm_1, data_val)$.pred), \n              linewidth = 1.25, color = \"blue\") + \n    ggtitle(\"Validation Set\")\n\n\n\n\n\nAs expected, there is a moderately strong positive relationship between gr_liv_area and sale_price.\n\nWe can also again see the heteroscadasticity in the errors that might be corrected by a power transformation of sale_price (or gr_liv_area)"
  },
  {
    "objectID": "003_regression.html#extension-of-lm-to-multiple-predictors",
    "href": "003_regression.html#extension-of-lm-to-multiple-predictors",
    "title": "3  Introduction to Regression Models",
    "section": "3.3 Extension of LM to Multiple Predictors",
    "text": "3.3 Extension of LM to Multiple Predictors\nWe can improve model performance by moving from simple linear model to a linear model with multiple features derived from multiple predictors\nWe have many other numeric variables available to use, even in this pared down version of the dataset.\n\ndata_trn |&gt;  names()\n\n [1] \"sale_price\"   \"gr_liv_area\"  \"lot_area\"     \"year_built\"   \"overall_qual\"\n [6] \"garage_cars\"  \"garage_qual\"  \"ms_zoning\"    \"lot_config\"   \"bldg_type\"   \n\n\nLet’s expand our model to also include lot_area, year_built, and garage_cars\nAgain, we need:\n\nA feature engineering recipe\nTraining (and eventually validation) feature matrices\nAn algorithm to fit in training feature matrix\n\n\nWith the addition of new predictors, we now have a feature engineering task\n\nWe have missing data on garage_cars in the training set\nWe need to decide how we will handle it\n\nA simple solution is to do median imputation - substitute the median of the non-missing scores for any missing score.\n\nThis is fast and easy to understand\nIt works OK (but there are certainly better options that we will consider later in the course)\n\nsee other options in Step Functions - Imputation section on tidymodels website\n\nThere is only one missing value so it likely doesn’t matter much anyway\n\n\nLet’s add this to our recipe. All of the defaults are appropriate but you should see ?step_impute_median() to review them\n\nrec &lt;- \n1  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars,\n         data = data_trn) |&gt; \n  step_impute_median(garage_cars)\n\n\n1\n\nNotice we now list four predictors for our recipe using + between them\n\n\n\n\n\nNow we need to\n\nFirst prep recipe\n\n\nrec_prep &lt;- rec |&gt; \n1  prep(data_trn)\n\n\n1\n\nI am going to stop using training = at this point. Remember, we prep recipes with training data.\n\n\n\n\n\n\nNext, bake the training data with prepped recipe to get training features\n\n\nfeat_trn &lt;- rec_prep |&gt; \n1  bake(data_trn)\n\n\n1\n\nI am going to stop using new_data = but remember, we can bake any dataset to make features for that dataset.\n\n\n\n\n\n\nAnd take a quick look at the features\n\nSample size is correct\n4 features and the outcome variable\nAll features are numeric\nNo missing data for garage_qual\n\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\n\n\n\n\n\nAnd finally, bake the validation data with the same prepped recipe to get validation features\n\n\nfeat_val &lt;- rec_prep |&gt; \n1  bake(data_val)\n\n\n1\n\nNotice that here we are now baking data_val\n\n\n\n\n\n\nAnd take a quick look\n\nCorrect sample size (N = 490)\n4 features and outcome\nAll numeric\nNo missing data\n\n\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1493.00\n483.78\n480\n1143.5\n1436.0\n1729.50\n3608\n0.92\n1.16\n\n\nlot_area\n0\n1\n10462.08\n10422.55\n1680\n7500.0\n9563.5\n11780.75\n215245\n15.64\n301.66\n\n\nyear_built\n0\n1\n1971.08\n30.96\n1875\n1954.0\n1975.0\n2000.00\n2010\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n1.74\n0.76\n0\n1.0\n2.0\n2.00\n4\n-0.24\n0.22\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311\n129125.0\n160000.0\n213000.00\n556581\n1.42\n2.97\n\n\n\n\n\n\nNow let’s combine our algorithm and training features to fit this model configuration with 4 features\n\nfit_lm_4 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n1  fit(sale_price ~ ., data = feat_trn)\n\n\n1\n\nthe . is a bit more useful now\n\n\n\n\n\nThis yields these parameter estimates (which as we know from 610/710 were selected to minimize SSE in the training set):\n\nfit_lm_4 |&gt; tidy()\n\n# A tibble: 5 × 5\n  term            estimate std.error statistic   p.value\n  &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept) -1665041.    89370.       -18.6  1.14e- 69\n2 gr_liv_area       76.8       2.62      29.3  3.56e-149\n3 lot_area           0.514     0.146      3.51 4.60e-  4\n4 year_built       854.       46.2       18.5  7.66e- 69\n5 garage_cars    22901.     1964.        11.7  4.09e- 30\n\n\n\nHere is our parametric model\n\n\\(\\hat{sale\\_price} = -1.6650409\\times 10^{6} + 76.8 * gr\\_liv\\_area + 0.5 * lot\\_area + 854.3 * year\\_built + 2.29008\\times 10^{4} * garage\\_cars\\)\n\nCompared with our previous simple regression model:\n\n\\(\\hat{sale\\_price} = 1.6561\\times 10^{4} + 108.9 * gr\\_liv\\_area\\)\n\n\nOf course, these four features are correlated both with sale_price but also with each other\nLet’s look at correlations in the training set.\n\nfeat_trn |&gt; \n  cor() |&gt; \n  corrplot::corrplot.mixed()\n\n\n\n\n\n\n\n\n\n\n\nQuestion: What are the implications of the correlations among many of these predictors?\n\n\n\n\n\n\n\nShow Answer\nThe multiple regression model coefficients represent unique effects, controlling for \nall other variables in the model.  You can see how the unique effect of `gr_liv_area` \nis smaller than its overall effect from the simple regression.   This also means \nthat the overall predictive strength of the model will not be a sum of the effects \nof each predictor considered in isolation - it will likely be less.  Also, if the \ncorrelations are high, problems with multicollinearity will emerge.  This will yield \nlarge standard errors which means that the models will start to have more variance when \nfit in different training datasets!  We will soon learn about other regularized \nversions of the GLM that do not have these issues with correlated predictors.\n\n\n\n\n\n\nHow well does this more complex model perform in validation? Let’s compare the previous and current visualizations of \\(sale\\_price\\) vs. \\(\\hat{sale\\_price}\\)\n\nLooks like the errors are smaller (closer to the diagonal line that would represent prefect prediction)\nClear signs of non-linearity are now present as well. Time for more Modeling EDA!!\n\n\nplot_1 &lt;- plot_truth(truth = feat_val$sale_price, \n                     estimate = predict(fit_lm_1, feat_val)$.pred)\n\nplot_4 &lt;- plot_truth(truth = feat_val$sale_price, \n                     estimate = predict(fit_lm_4, feat_val)$.pred)\n\ncowplot::plot_grid(plot_1, plot_4, \n          labels = list(\"1 feature\", \"4 features\"), hjust = -1.5)\n\n\n\n\nCoding sidebar: Notice the use of plot_grid() from the cowplot package to make side by side plots. This also required returning the individual plots as objects (just assign to a object name, e.g., plot_1)\n\nLet’s compare model performance for the two models using RMSE in the validation set\n\nThe one feature simple linear model\n\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_lm_1, feat_val)$.pred)\n\n[1] 51375.08\n\n\n\nThe four feature linear model. A clear improvement!\n\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_lm_4, feat_val)$.pred)\n\n[1] 39903.25\n\n\n\n\nLet’s bind the new performance metric to our results table\n\n\n\n# A tibble: 2 × 2\n  model                  rmse_val\n  &lt;chr&gt;                     &lt;dbl&gt;\n1 simple linear model      51375.\n2 4 feature linear model   39903.\n\n\n\nGiven the non-linearity suggested by the truth vs. estimate plots, we might wonder if we could improve the fit if we transformed our features to be closer to normal\n\nThere are a number of recipe functions that do transformations (see Step Functions - Individual Transformations)\nWe will apply step_YeoJohnson(), which is similar to a Box-Cox transformation but can be more broadly applied because the scores don’t need to be strictly positive\n\n\nLet’s do it all again, now with transformed features!\n\nDefine the feature engineering recipe\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars, \n         data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_YeoJohnson(lot_area, gr_liv_area, year_built, garage_cars)\n\n\n\nPrep the recipe with training set\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\n\nUse prepped recipe to bake the training set into features\nNotice the features are now less skewed (but sale_price is still skewed)\n\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n5.22\n0.16\n4.60\n5.11\n5.23\n5.33\n5.86\n0.00\n0.12\n\n\nlot_area\n0\n1\n14.10\n1.14\n10.32\n13.69\n14.20\n14.64\n21.65\n0.08\n5.46\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880.00\n1953.00\n1972.00\n2000.00\n2010.00\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n2.12\n0.98\n0.00\n1.11\n2.37\n2.37\n5.23\n-0.03\n0.04\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789.00\n129500.00\n160000.00\n213500.00\n745000.00\n1.64\n4.60\n\n\n\n\n\n\n\nUse same prepped recipe to bake the validation set into features\nAgain, features are less skewed\n\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n5.22\n0.16\n4.65\n5.11\n5.23\n5.32\n5.66\n-0.17\n0.19\n\n\nlot_area\n0\n1\n14.14\n1.17\n10.57\n13.69\n14.24\n14.72\n22.44\n0.11\n6.12\n\n\nyear_built\n0\n1\n1971.08\n30.96\n1875.00\n1954.00\n1975.00\n2000.00\n2010.00\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n2.06\n0.96\n0.00\n1.11\n2.37\n2.37\n5.23\n0.01\n0.24\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311.00\n129125.00\n160000.00\n213000.00\n556581.00\n1.42\n2.97\n\n\n\n\n\n\n\nFit model\n\n\nfit_lm_4yj &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\nView truth vs. estimate plot\n\n\nplot_truth(truth = feat_val$sale_price,\n           estimate = predict(fit_lm_4yj, feat_val)$.pred)\n\n\n\n\n\n\nand look at the error\n\n\n\n# A tibble: 3 × 2\n  model                          rmse_val\n  &lt;chr&gt;                             &lt;dbl&gt;\n1 simple linear model              51375.\n2 4 feature linear model           39903.\n3 4 feature linear model with YJ   41660.\n\n\n\nThat didn’t help at all. Error still high and still non-linearity in plot.\n\n\nWe may need to consider\n\na transformation of sale_price (We will leave that to you for the application assignment if you are daring!)\nor a different algorithm that can handle non-linear relationships better"
  },
  {
    "objectID": "003_regression.html#extension-to-categorical-predictors",
    "href": "003_regression.html#extension-to-categorical-predictors",
    "title": "3  Introduction to Regression Models",
    "section": "3.4 Extension to Categorical Predictors",
    "text": "3.4 Extension to Categorical Predictors\nMany important predictors in our models may be categorical (nominal and some ordinal predictors)\n\nSome statistical algorithms (e.g., random forest) can accept even nominal predictors as features without any further feature engineering\nBut many cannot. Linear models cannot.\nThe type of feature engineering may differ for nominal vs. ordinal categorical predictors\nFor nominal categorical predictors:\n\nWe need to learn a common approach to transform them to numeric features - dummy coding. We will learn the concept in general AND how to accomplish within a feature engineering recipe.\n\nFor ordinal predictors:\n\nWe can treat them like numeric predictors\nWe can treat them like nominal categorical predictors\n\nSee article on Categorical Predictors on the tidymodels website for more details\n\n\n\n3.4.1 Dummy Coding\nFor many algorithms, we will need to use feature engineering to convert a categorical predictor to numeric features. One common technique is to use dummy coding. When dummy coding a predictor, we transform the original categorical predictor with m levels into m-1 dummy coded features.\nTo better understand how and why we do this, lets consider a version of ms_zoning in the Ames dataset.\n\ndata_trn |&gt; \n  pull(ms_zoning) |&gt; \n  table()\n\n\n    agri   commer    float    indus res_high  res_low  res_med \n       2       13       66        1        9     1157      217 \n\n\nWe will recode ms_zoning to have only 3 levels to make our example simple (though dummy codes can be used for predictors with any number of levels)\n\ndata_dummy &lt;- data_trn |&gt; \n1  select(sale_price, ms_zoning)  |&gt;\n2  mutate(ms_zoning3 = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\",\n                                                   \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n3                                 \"floating\" = \"float\")) |&gt;\n4  select(-ms_zoning)\n\n\n1\n\nMake a df (dataframe) with only sale_price and ms_zoning\n\n2\n\nfct_collapse() from the forcats package is our preferred way to collapse levels of a factor. See fct_recode() for more generic recoding of levels.\n\n3\n\nWe could have left this line out and float would have stayed as a level named float\n\n4\n\nRemove original ms_zoning predictor\n\n\n\n\n\nTake a look at the new predictor\n\ndata_dummy |&gt; \n  pull(ms_zoning3) |&gt; \n  table() \n\n\n commercial    floating residential \n         16          66        1383 \n\n\n\n\n\n\n\n\n\nQuestion: Why can’t we simply recode each level with a different consecutive value (e.g., commercial = 1, floating =2 , residential = 3)?\n\n\n\n\n\n\n\nShow Answer\nThere is no meaningful way to order the numbers that we assign to the levels of \nthis unordered categorical predictor.  The shape and strength of the relationship\nbetween it and sale_price will completely change based on arbitrary ordering of \nthe levels.\n\n\n\n\n\n\nImagine fitting a straight line to predict sale_price from ms_zoning3 using these three different ways to arbitrarily assign numbers to levels.\n\ndata_dummy |&gt; \n  mutate(ms_zoning3 = case_when(ms_zoning3 == \"residential\" ~ 1,\n                                ms_zoning3 == \"commercial\" ~ 2,\n                                ms_zoning3 == \"floating\" ~ 3)) |&gt; \n  ggplot(aes(x = ms_zoning3, y = sale_price)) +\n    geom_bar(stat=\"summary\", fun = \"mean\")\n\n\n\n\n\ndata_dummy |&gt; \n  mutate(ms_zoning3 = case_when(ms_zoning3 == \"residential\" ~ 2,\n                                ms_zoning3 == \"commercial\" ~ 1,\n                                ms_zoning3 == \"floating\" ~ 3)) |&gt; \n  ggplot(aes(x = ms_zoning3, y = sale_price)) +\n    geom_bar(stat=\"summary\", fun = \"mean\")\n\n\n\n\n\ndata_dummy |&gt; \n  mutate(ms_zoning3 = case_when(ms_zoning3 == \"residential\" ~ 3,\n                                ms_zoning3 == \"commercial\" ~ 1,\n                                ms_zoning3 == \"floating\" ~ 2)) |&gt; \n  ggplot(aes(x = ms_zoning3, y = sale_price)) +\n    geom_bar(stat=\"summary\", fun = \"mean\")\n\n\n\n\n\nDummy coding resolves this issue.\n\nWhen using dummy codes, we transform (i.e., feature engineer) our original m-level categorical predictor to m-1 dummy features.\nEach of these m-1 features represents a contrast between a specific level of the categorical variable and a reference level\nThe full set of m-1 features represents the overall effect of the categorical predictor variable.\nWe assign values of 0 or 1 to each observation on each feature in a meaningful pattern (see below)\n\n\nFor example, with our three-level predictor: ms_zoning3\n\nWe need 2 dummmy features (d1, d2) to represent this 3-level categorical predictor\nDummy feature 1 is coded 1 for residential and 0 for all other levels\nDummy feature 2 is coded 1 for floating and 0 for all other levels\n\nHere is this coding scheme displayed in a table\n\n\n# A tibble: 3 × 3\n  ms_zoning3     d1    d2\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 commercial      0     0\n2 residential     1     0\n3 floating        0     1\n\n\n\nWith this coding:\n\nCommercial properties are coded 0 for both d1 and d2.\n\nThis means that commercial properties will become the reference level against which both residential and floating village are compared.\nBecause we are focused on prediction, the choice of reference level is mostly arbitrary. For explanatory goals, you might consider which level is best suited to be the reference.\nThere is much deeper coverage of dummy and other contrast coding in 610/710\n\n\nWe can add these two features manually to the data frame and view a handful of observations to make this coding scheme more concrete\n\n\n# A tibble: 8 × 4\n  sale_price ms_zoning3     d1    d2\n       &lt;dbl&gt; &lt;fct&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1     105000 residential     1     0\n2     126000 residential     1     0\n3      13100 commercial      0     0\n4     115000 residential     1     0\n5     149500 floating        0     1\n6      40000 commercial      0     0\n7     120000 residential     1     0\n8     151000 floating        0     1\n\n\n\nIf we now fit a model where we predict sale_price from these two dummy coded features, each feature would represent the contrast of the mean sale_price for the level coded 1 vs. the mean sale_price for the level that is coded 0 for all features (i.e., commercial)\n\nd1 is the contrast of mean sale_price for residential vs. commercial\nd2 is the contrast of mean sale_price for floating vs. commercial\nThe combined effect of these two features represents the overall effect of ms_zoning3 on sale_price\n\n\nLets do this quickly in base R using lm() as you have done previously in 610.\n\nm &lt;- lm(sale_price ~ d1 + d2, data = data_dummy) \n\nm |&gt; summary()\n\n\nCall:\nlm(formula = sale_price ~ d1 + d2, data = data_dummy)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-166952  -50241  -20241   31254  565259 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)    81523      19409   4.200 2.83e-05 ***\nd1             98219      19521   5.031 5.47e-07 ***\nd2            143223      21634   6.620 5.03e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 77640 on 1462 degrees of freedom\nMultiple R-squared:  0.03151,   Adjusted R-squared:  0.03018 \nF-statistic: 23.78 on 2 and 1462 DF,  p-value: 6.858e-11\n\n\n\nThe mean sale price of residential properties is 9.8219^{4} dollars higher than commercial properties.\nThe mean sale price of floating villages is 1.43223^{5} dollars higher than commercial properties.\n\n\nTo understand this conceptually, it is easiest to visualize the linear model that would predict sale_price with these two dichotomous features.\n\nThere are only three columns of sale_price because the only possible values for d1 and d2 (which are both dichotomous) are\n\n0,0 (commercial)\n1,0 (residential)\n0,1 (floating village)\n\nThis regression with two features yields a prediction plane (displayed)\nThe left/right tilt of the plane will be the parameter estimate for d1 and it is the contrast of residential vs. commercial\nThe front/back tilt of the plane will be the parameter estimate for d2 and it is the contrast of floating village vs. commercial\n\n\n\n\n\n\n\nStatistical sidebar:\n\nAny full rank (# levels - 1) set of features regardless of coding system predicts exactly the same (e.g., dummy, helmert, contrast coding)\nPreference among coding systems is simply to get single df contrasts of theoretical importance (i.e., for explanation rather than prediction)\nFinal (mth) dummy feature is not included b/c its is completely redundant (perfectly multicollinear) with other dummy features. This would also prevent a linear model from fitting (‘dummy variable trap’).\nHowever, some statistical algorithms do not have problems with perfect multicollinearity (e.g., LASSO, ridge regression).\n\nFor these algorithms, you will sometimes see modified version of dummy coding called one-hot coding.\n\nThis approach uses one additional dummy coded feature for the final category.\n\nWe won’t spend time on this but you should be familiar with the term b/c it is often confused with dummy coding.\n\n\n\nCoding Sidebar\nWhen creating dummy coded features from factors that have levels with infrequent observations, you may occasionally end up with novel levels in your validation or test sets that were not present in your training set.\n\nThis will cause you issues.\n\nThese issues are mostly resolved if you make sure to explicitly list all possible levels for a factor when classing that factor in the training data, even if the level doesn’t exist in the training data.\n\nWe provide more detail on this issue in an appendix.\n\n\n\n\n3.4.2 Nominal Predictors\nNow that we understand how to use dummy coding to feature engineer nominal predictors, let’s consider some potentially important ones that are available to us.\nWe can discuss if any look promising.\n\nLets return first to ms_zoning\n\ndata_trn |&gt; \n  plot_categorical(\"ms_zoning\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\nWarning: Groups with fewer than two data points have been dropped.\n\n\n\n\n\nWe might:\n\nRepresent it with 6 dummy features (because there are 7 raw levels) but many of the categories are very low n - won’t account for much variance?\nCombine all the commercial categories (agri, commer, indus), which would take care of most of the low n groups. They also all tend to have the lower prices.\nCombine all the residential to get a better feature to variance accounted ratio. They all tend to have similar prices on average and res_high is also pretty low n. \n\nData dictionary entry: Identifies the general zoning classification of the sale.\n\nagri: Agriculture\ncommer: Commercial\nfloat: Floating Village Residential\nindus: Industrial\nres_high: Residential High Density\nres_med: Residential Medium Density\nres_low: Residential Low Density\n\n\nlot_config\n\ndata_trn |&gt; \n  plot_categorical(\"lot_config\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\nWe see that:\n\nMost are inside lots, some of the lot categories are low n\nMedian sale_price is not very different between configurations\nNot very promising but could help some (particularly given the large sample size)\n\nData dictionary entry: Lot configuration\n\ninside: Inside lot\ncorner: Corner lot\nculdsac: Cul-de-sac\nfr2: Frontage on 2 sides of property\nfr3: Frontage on 3 sides of property\n\n\nbldg_type\n\ndata_trn |&gt; \n  plot_categorical(\"bldg_type\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\nWe see that:\n\nMost of the houses are in one category - one_fam\nThere is not much difference in median sale_price among categories\nNot very promising\n\nData dictionary entry: Type of dwelling\n\none_fam: Single-family Detached\n\ntwo_fam: Two-family Conversion; originally built as one-family dwelling\nduplex: Duplex\ntown_end: Townhouse End Unit\ntown_inside: Townhouse Inside Unit\n\n\nLet’s do some feature engineering with ms_zoning. We can now do this formally in a recipe so that it can be used in our modeling workflow.\n\nFirst, if you noticed earlier, there are some levels for ms_zoning that are pretty infrequent. Lets make sure both data_trn and data_val have all levels set for this factor.\n\n\ndata_trn |&gt; pull(ms_zoning) |&gt; levels()\n\n[1] \"agri\"     \"commer\"   \"float\"    \"indus\"    \"res_high\" \"res_low\"  \"res_med\" \n\ndata_val |&gt; pull(ms_zoning) |&gt; levels()\n\n[1] \"commer\"   \"float\"    \"indus\"    \"res_high\" \"res_low\"  \"res_med\" \n\n\n\nAs expected, we are missing a level (agri) in data_val. Lets fix that here\n\n\ndata_val &lt;- data_val |&gt; \n  mutate(ms_zoning = factor(ms_zoning, \n                            levels = c(\"agri\", \"commer\", \"float\", \"indus\", \n                                       \"res_high\", \"res_low\", \"res_med\")))\n\n[Note: Ideally, you would go back to cleaning EDA and add this level to the full dataset and then re-split into training, validation and test. This is a sloppy shortcut!]\n\nWith that fixed, let’s proceed:\n\nWe will collapse categories down to three levels (commercial, residential, floating village) as before but now using step_mutate() combined with fct_collapse() to do this inside of our recipe.\n\nWe will convert to dummy features using step_dummy(). The first level of the factor will be set to the reference level when we call step_dummy().\nstep_dummy() is a poor choice for function name. It actually uses whatever contrast coding we have set up in R. However, the default is are dummy coded contrasts (R calls this treatment contrasts). See ?contrasts and options(\"contrasts\") for more info.\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars + ms_zoning, \n         data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\")) |&gt;\n  step_dummy(ms_zoning)\n\n\nCoding Sidebar\nYou should also read more about some other step_() functions that you might use for categorical predictors: - step_other() to combine all low frequency categories into a single “other” category. - step_unknown() to assign missing values their own category - You can use selector functions. For example, you could make dummy variables out of all of your factors in one step using step_dummy(all_nominal_predictors()).\nSee the Step Functions - Dummy Variables and Encoding section on the tidymodels website for additional useful functions.\nWe have also described these in the section on factor steps in Appendix 1\n\nLet’s see if the addition of ms_zoning helped\n\nNotice the addition of the dummy coded features to the feature matrix\nNotice the removal of the factor ms_zoning\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nskim\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n7\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\nms_zoning_floating\n0\n1\n0.05\n0.21\n0\n0\n0\n0\n1\n4.38\n17.22\n\n\nms_zoning_residential\n0\n1\n0.94\n0.23\n0\n1\n1\n1\n1\n-3.86\n12.90\n\n\n\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n7\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1493.00\n483.78\n480\n1143.5\n1436.0\n1729.50\n3608\n0.92\n1.16\n\n\nlot_area\n0\n1\n10462.08\n10422.55\n1680\n7500.0\n9563.5\n11780.75\n215245\n15.64\n301.66\n\n\nyear_built\n0\n1\n1971.08\n30.96\n1875\n1954.0\n1975.0\n2000.00\n2010\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n1.74\n0.76\n0\n1.0\n2.0\n2.00\n4\n-0.24\n0.22\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311\n129125.0\n160000.0\n213000.00\n556581\n1.42\n2.97\n\n\nms_zoning_floating\n0\n1\n0.05\n0.22\n0\n0.0\n0.0\n0.00\n1\n4.07\n14.58\n\n\nms_zoning_residential\n0\n1\n0.93\n0.25\n0\n1.0\n1.0\n1.00\n1\n-3.51\n10.33\n\n\n\n\n\n\n\nNow lets fit a model with these features\n\n\nfit_lm_6 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\nplot it\n\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_6, feat_val)$.pred)\n\n\n\n\n\n\nAnd evaluate it\n\n\n\n# A tibble: 4 × 2\n  model                              rmse_val\n  &lt;chr&gt;                                 &lt;dbl&gt;\n1 simple linear model                  51375.\n2 4 feature linear model               39903.\n3 4 feature linear model with YJ       41660.\n4 6 feature linear model w/ms_zoning   39846.\n\n\n\nRemoving Yeo Johnson transformation but adding dummy coded ms_zoning may have helped a little\n\n\n\n\n\n\n\n\nQuestion: Will the addition of new predictors/features to a model always reduce RMSE in train? in validation?\n\n\n\n\n\n\n\nShow Answer\nAs you know, the estimation procedure in linear models is OLS.  Parameter estimates\nare derived to minimize the SSE in the data set in which they are derived.  For this\nreason, adding a predictor will never increase RMSE in the training set and it will\nusually lower it even when it is not part of the DGP.   However, this is not true in\nvalidation.  A predictor will only meaningfully lower RMSE in validation if it is\npart of the DGP.  Also, a bad predictor could even increase RMSE in validation due to\noverfitting.\n\n\n\n\n\n\n\n\n3.4.3 Ordinal Predictors\nWe have two paths to pursue for ordinal predictors\n\nWe can treat them like nominal predictors (e.g., dummy code)\nWe can treat them like numeric predictors (either raw or with an added transformation if needed)\n\n\nLet’s consider overall_qual\n\ndata_trn |&gt; \n  plot_categorical(\"overall_qual\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\nObservations:\n\nLow frequency for low and to some degree high quality response options. If dummy coding, may want to collapse some (1-2)\nThere is a monotonic relationship (mostly linear) with sale_price. Treat as numeric?\nNot skewed so doesn’t likely need to be transformed if treated as numeric\nNumeric will take one feature vs. many (9?) features for dummy codes.\n\nDummy codes are more flexible but we may not need this flexibility (and unnecessary flexibility increases overfitting)\n\n\nLet’s add overall_qual to our model as numeric\nRemember that this predictor was ordinal so we paid special attention to the order of the levels when we classed this factor. Lets confirm they are in order\n\ndata_trn |&gt; pull(overall_qual) |&gt; levels()\n\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n\n\n\nTo convert overall_qual to numeric (with levels in the specified order), we can use another simple mutate inside our recipe.\n\nrec &lt;- \n  recipe(sale_price ~  ~ gr_liv_area + lot_area + year_built + garage_cars + \n           ms_zoning + overall_qual, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\"),\n              overall_qual = as.numeric(overall_qual)) |&gt;\n  step_dummy(ms_zoning)\n\nCoding Sidebar\nThere is a step function called step_ordinalscore() but it requires that the factor is classed as an ordered factor. It is also more complicated than needed in our opinion. Just use as.numeric()\n\nLet’s evaluate this model\n\nMaking features\nSkipping the skim to save space (we promised we checked it previously!)\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nFitting model\n\n\nfit_lm_7 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\nPlotting results\n\n\nplot_truth(truth = feat_val$sale_price, \n                                 estimate = predict(fit_lm_7, feat_val)$.pred)\n\n\n\n\n\n\nQuantifying held out error\n\n\n\n# A tibble: 5 × 2\n  model                              rmse_val\n  &lt;chr&gt;                                 &lt;dbl&gt;\n1 simple linear model                  51375.\n2 4 feature linear model               39903.\n3 4 feature linear model with YJ       41660.\n4 6 feature linear model w/ms_zoning   39846.\n5 7 feature linear model               34080.\n\n\n\nThat helped!"
  },
  {
    "objectID": "003_regression.html#extensions-to-interactive-models-and-non-linear-models",
    "href": "003_regression.html#extensions-to-interactive-models-and-non-linear-models",
    "title": "3  Introduction to Regression Models",
    "section": "3.5 Extensions to Interactive Models and Non-linear Models",
    "text": "3.5 Extensions to Interactive Models and Non-linear Models\n\n3.5.1 Interactions\nThere may be interactive effects among our predictors\n\nSome statistical algorithms (e.g., KNN) can naturally accommodate interactive effects without any feature engineering\nLinear models cannot\nNothing to fear, tidymodels makes it easy to feature engineer interactions\n[BUT - as we will learn, we generally think that if you expect lots of interactions, the linear model may not be the best model to use]\n\n\nFor example, it may be that the relationship between year_built and sale_price depends on overall_qual.\n\nOld houses are expensive if they are in good condition\nbut old houses are very cheap if they are in poor condition\n\n\nIn the tidymodels framework\n\nCoding interactions is done by feature engineering, not by formula (Note that formula does not change below in recipe)\nThis seems appropriate to us as we are making new features to represent interactions\nWe still use an R formula like interface to specify the interaction term features that will be created\nsee more details on the tidymodels website\n\n\nrec &lt;- \n  recipe(sale_price ~  ~ gr_liv_area + lot_area + year_built + garage_cars + \n           ms_zoning + overall_qual, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\"),\n              overall_qual = as.numeric(overall_qual)) |&gt;\n  step_dummy(ms_zoning) |&gt; \n  step_interact(~ overall_qual:year_built)\n\n\nLet’s prep, bake, fit, and evaluate!\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nNote the new interaction term (we just skim feat_trn here)\nNamed using “x” to specify the interaction\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n9\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n9\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\noverall_qual\n0\n1\n6.08\n1.41\n1\n5\n6\n7\n10\n0.20\n-0.03\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\nms_zoning_floating\n0\n1\n0.05\n0.21\n0\n0\n0\n0\n1\n4.38\n17.22\n\n\nms_zoning_residential\n0\n1\n0.94\n0.23\n0\n1\n1\n1\n1\n-3.86\n12.90\n\n\noverall_qual_x_year_built\n0\n1\n12015.69\n2907.93\n1951\n9800\n11808\n14021\n20090\n0.24\n-0.11\n\n\n\n\n\n\n\nfit model\n\n\nfit_lm_8 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~., \n      data = feat_trn)\n\n\n\nplot\n\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_8, feat_val)$.pred)\n\n\n\n\n\n\ncalculate held out error\n\n\n\n# A tibble: 6 × 2\n  model                                rmse_val\n  &lt;chr&gt;                                   &lt;dbl&gt;\n1 simple linear model                    51375.\n2 4 feature linear model                 39903.\n3 4 feature linear model with YJ         41660.\n4 6 feature linear model w/ms_zoning     39846.\n5 7 feature linear model                 34080.\n6 8 feature linear model w/interaction   32720.\n\n\n\nThat helped!\n\n\nYou can also feature engineer interactions with nominal (and ordinal predictors treated as nominal) predictors\n\nThe nominal predictors should first be converted to dummy code features\nYou will indicate the interactions using the variable names that will be assigned to these dummy code features\nUse starts_with() or matches() to make it easy if there are many features associated with a categorical predictor\nCan use “~ .^2” to include all two way interactions (be careful if you have dummy coded features!)\n\n\nLet’s code an interaction between ms_zoning & year_built.\n\nOld homes are cool\nOld commercial spaces are never cool\nMaybe this is why the main effect of ms_zoning wasn’t useful\n\n\nrec &lt;- \n  recipe(sale_price ~  ~ gr_liv_area + lot_area + year_built + garage_cars + \n           ms_zoning + overall_qual, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\"),\n              overall_qual = as.numeric(overall_qual)) |&gt;\n  step_dummy(ms_zoning) |&gt; \n  step_interact(~ overall_qual:year_built) |&gt; \n  step_interact(~ starts_with(\"ms_zoning_\"):year_built)  \n\n\n\nprep, bake\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nYup, we have two new interaction features as expected\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n11\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n11\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\noverall_qual\n0\n1\n6.08\n1.41\n1\n5\n6\n7\n10\n0.20\n-0.03\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\nms_zoning_floating\n0\n1\n0.05\n0.21\n0\n0\n0\n0\n1\n4.38\n17.22\n\n\nms_zoning_residential\n0\n1\n0.94\n0.23\n0\n1\n1\n1\n1\n-3.86\n12.90\n\n\noverall_qual_x_year_built\n0\n1\n12015.69\n2907.93\n1951\n9800\n11808\n14021\n20090\n0.24\n-0.11\n\n\nms_zoning_floating_x_year_built\n0\n1\n90.29\n415.84\n0\n0\n0\n0\n2009\n4.38\n17.22\n\n\nms_zoning_residential_x_year_built\n0\n1\n1860.03\n453.95\n0\n1948\n1968\n1997\n2010\n-3.83\n12.78\n\n\n\n\n\n\n\nFit model\n\n\nfit_lm_10 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\nPlot\n\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_10, feat_val)$.pred)\n\n\n\n\n\n\nQuantify held out error\n\n\nerror_val &lt;- error_val |&gt; \n  bind_rows(tibble(model = \"10 feature linear model w/interactions\", \n                   rmse_val = rmse_vec(feat_val$sale_price,\n                                       predict(fit_lm_10,\n                                               feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 7 × 2\n  model                                  rmse_val\n  &lt;chr&gt;                                     &lt;dbl&gt;\n1 simple linear model                      51375.\n2 4 feature linear model                   39903.\n3 4 feature linear model with YJ           41660.\n4 6 feature linear model w/ms_zoning       39846.\n5 7 feature linear model                   34080.\n6 8 feature linear model w/interaction     32720.\n7 10 feature linear model w/interactions   32708.\n\n\n\nNot really any better\nShouldn’t just include all interactions without reason\n\nEither you have done EDA to support them or\nYou have substantive interest in them (explanatory question)\nIf you want all interactions, use a statistical algorithm that supports those relationships without feature engineering (e.g., KNN, random forest and other decision trees)\n\n\n\n\n\n3.5.2 Non-linear Models\nWe may also want to model non-linear effects of our predictors\n\nSome non-parametric models can accommodate non-linear effects without feature engineering (e.g., KNN, Random Forest).\nNon-linear effects can be accommodated in a linear model with feature engineering\n\nTransformations of Y or X. See Step Functions - Individual Transformations on tidymodels website\nOrdinal predictors can be coded with dummy variables\nNumeric predictors can be split at threshold\nPolynomial contrasts for numeric or ordinal predictors (see step_poly())\n\nWe will continue to explore these options throughout the course"
  },
  {
    "objectID": "003_regression.html#knn-regression",
    "href": "003_regression.html#knn-regression",
    "title": "3  Introduction to Regression Models",
    "section": "3.6 KNN Regression",
    "text": "3.6 KNN Regression\nK Nearest Neighbor\n\nIs a non-parametric regression and classification statistical algorithm\n\nIt does not yield specific parameter estimates for features/predictors (or statistical tests for those parameter estimates)\nThere are still ways to use it to address explanatory questions (visualizations, model comparisons, feature importance)\n\nVery simple but also powerful (listed commonly among top 10 algorithms)\n\nBy powerful, it is quite flexible and can accommodate many varied DGPs without the need for much feature engineering with its predictors\nMay not need most transformations of X or Y\nMay not need to model interactions\nStill need to handle missing data, outliers, and categorical predictors\n\n\n\nK Nearest Neighbor\n\nAlgorithm “memorizes” the training set (lazy learning)\n\nLazy learning is most useful for large, continuously changing datasets with few attributes (features) that are commonly queried (e.g., online recommendation systems)\n\nPrediction for any new observation is based on \\(k\\) most similar observations from the dataset\n\n\\(k\\) provides direct control over the bias-variance trade-off for this algorithm\n\n\n\nTo better understand KNN let’s simulate training data for three different DGPs (linear - y, polynomial - y2, and step - y3)\n\nLet’s start with a simple example where the DGP for Y is linear on one predictor (X)\nDGP: \\(y = rnorm(150, x, 10)\\)\nThis figure displays:\n\nDGP\nPrediction line from a simple linear model\nRed lines to represent three new observations (X = 10, 50, 90) we want to make predictions for via a standard KNN\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion: What would 5-NN predictions look like for each of these three new values of X in the figure above?\n\n\n\n\n\n\n\nShow Answer\nFor x = 10, find the five observations that have X values closest to 10.  Average the \nY values for those 5 observations and that is your predicted Y associated with \nthat new value of X.  Repeat to make predictions for Y for any other value of X,\ne.g., 50, 90, or any other value\n\n\n\n\n\n\nKNN can easily accommodate non-linear relationships between numeric predictors and outcomes without any feature engineering for predictors\nIn fact, it can flexibly handle any shape of relationship\nDGP: \\(y2 = rnorm(150, x^4 / 800000, 8)\\)\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\nDGP: \\(y3 = if\\_else(x &lt; 40, rnorm(150, 25, 10), rnorm(150, 75, 10))\\)"
  },
  {
    "objectID": "003_regression.html#the-hyperparameter-k-in-knn",
    "href": "003_regression.html#the-hyperparameter-k-in-knn",
    "title": "3  Introduction to Regression Models",
    "section": "3.7 The Hyperparameter k in KNN",
    "text": "3.7 The Hyperparameter k in KNN\nKNN is our first example of a statistical algorithm that includes a hyperparameter, in this case \\(k\\)\n\nAlgorithm hyperparameters differ from parameters in that they cannot be estimated while fitting the algorithm to the training set\nThey must be set in advance\nk = 5 is the default for kknn(), the engine from the kknn package that we will use to fit a KNN within tidymodels.\n\n\\(kknn()\\) weights observations (neighbors) based on distance.\n\nAn option exists for unweighted as well but not likely used much (default is optimal weighting, use it!).\n\n\n\nUsing the polynomial DGP above, let’s look at a 5-NN yields\n\nNote the new category of algorithm, new engine, and the need to set a mode (because KNN can be used for regression and classification)\nWe can look in the package documentation to better understand what is being done (?kknn::train.kknn).\n\n\nnearest_neighbor() |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  translate()\n\nK-Nearest Neighbor Model Specification (regression)\n\nComputational engine: kknn \n\nModel fit template:\nkknn::train.kknn(formula = missing_arg(), data = missing_arg(), \n    ks = min_rows(5, data, 5))\n\n\n\n\nSet up simple feature engineering recipe and get training features (nothing happening but let’s follow normal routine anyway)\n\n\nrec &lt;- \n  recipe(y2 ~ x, data = data_trn_demo)\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn_demo)\n\nfeat_trn_demo &lt;- rec_prep |&gt; \n  bake(data_trn_demo)\n\n\n\nFit 5NN\n\n\nfit_5nn_demo &lt;- \n  nearest_neighbor() |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y2 ~ ., data = feat_trn_demo)\n\n\n\nGet features for a validation set (a new sample using same polynomial DGP)\n\n\nfeat_val_demo &lt;- rec_prep |&gt; \n  bake(data_val_demo)\n\n\n\nDisplay 5NN predictions in validation\n\nKNN (with k = 5) does a pretty good job of representing the shape of the DGP (low bias)\nKNN displays some (but minimal) evidence of overfitting\nSimple linear model does not perform well (clear/high bias)\n\n\n\n\n\n\n\n\nLet’s pause and consider our conceptual understanding of the impact of \\(k\\) on the bias-variance trade-off\n\n\n\n\n\n\nQuestion: How will the size of k influence model performance (e.g., bias, overfitting/variance)?\n\n\n\n\n\n\n\nShow Answer\nSmaller values of k will tend to increase overfitting (and therefore variance \nacross training samples) but decrease bias.  Larger values of k will tend to decrease\noverfitting but increase bias.  We need to find the Goldilocks \"sweet spot\"\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion: How will k = 1 perform in training and validation sets?\n\n\n\n\n\n\n\nShow Answer\nk = 1 will perfectly fit the training set.  Therefore it is very dependent on the training \nset (high variance).  It will fit both the DGP and the noise in the training set.  \nClearly it will likely not do as well in validation (it will be overfit to training).  \nk needs to be larger if there is more noise (to average over more cases).  k needs \nto be smaller if the relationships are complex. (More on choosing k by resampling in \nunit 5.\n\n\n\n\n\n\nk = 1\n\nFit new model\nRecipe and features have not changed\n\n\nfit_1nn_demo &lt;- \n1  nearest_neighbor(neighbors = 1) |&gt;\n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y2 ~ ., data = feat_trn_demo)\n\n\n1\n\nSet k with neighbors =\n\n\n\n\n\nVisualize prediction models in Train and Validation\n\n\n\n\n\n\nCalculate RMSE in validation for two KNN models\nk = 1\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_1nn_demo, feat_val_demo)$.pred)\n\n[1] 10.91586\n\n\nk = 5\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_5nn_demo, feat_val_demo)$.pred)\n\n[1] 8.387035\n\n\n\nWhat if we go the other way and increase \\(k\\) to 75\n\nfit_75nn_demo &lt;- \n  nearest_neighbor(neighbors = 75) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y2 ~ ., data = feat_trn_demo)\n\n\nVisualize prediction models in Train and Validation\n\n\n\n\n\n\nCalculate RMSE in validation for three KNN models\nThis is the bias-variance trade-off in action\n\nk = 1 - high variance\n\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_1nn_demo, feat_val_demo)$.pred)\n\n[1] 10.91586\n\n\n\nk = 5 - just right (well better at least)\n\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_5nn_demo, feat_val_demo)$.pred)\n\n[1] 8.387035\n\n\n\nk = 75 - high bias\n\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_75nn_demo, feat_val_demo)$.pred)\n\n[1] 15.34998"
  },
  {
    "objectID": "003_regression.html#distance-and-scaling-in-knn",
    "href": "003_regression.html#distance-and-scaling-in-knn",
    "title": "3  Introduction to Regression Models",
    "section": "3.8 Distance and Scaling in KNN",
    "text": "3.8 Distance and Scaling in KNN\n\n3.8.1 Defining “Nearest”\nTo make a prediction for some new observation, we need to identify the observations from the training set that are nearest to it\n\nNeed a distance measure to define “nearest”\nIMPORTANT: We care only about:\n\nDistance between a validation observation and all the training observations\nNeed to find the \\(k\\) observations in training that are nearest to the validation observation (i.e., its neighbors)\nDistance is defined based on these observations’ features, not their outcomes\n\nThere are a number of different distance measures available (e.g., Euclidean, Manhattan, Chebyshev, Cosine, Minkowski)\n\nEuclidean is most commonly used in KNN\n\n\n\nEuclidean distance between any two points is an n-dimensional extension of the Pythagorean formula (which applies explicitly with 2 features/2 dimensional space).\n\\(C^2 = A^2 + B^2\\)\n\\(C = \\sqrt{A^2 + B^2}\\)\n…where C is the distance between two points\n\nThe Euclidean distance between 2 points (p and q) in two dimensions (2 predictors, x1 = A, x2 = B)\n\\(Distance = \\sqrt{A^2 + B^2}\\)\n\\(Distance = \\sqrt{(q1 - p1)^2 + (q2 - p2)^2}\\)\n\\(Distance = \\sqrt{(2 - 1)^2 + (5 - 2)^2}\\)\n\\(Distance = 3.2\\)\n\n\n\n\n\n\nOne dimensional (one feature) is simply the subtraction of scores on that feature (x1) between p and q\n\\(Distance = \\sqrt{(q1 - p1)^2}\\)\n\\(Distance = \\sqrt{(2 - 1)^2}\\)\n\\(Distance = 1\\)\n\n\n\n\n\nN-dimensional generalization for n features:\n\\(Distance = \\sqrt{(q1 - p1)^2 + (q2 - p2)^2 + ... + (qn - pn)^2}\\)\n\nManhattan distance is also referred to as city block distance\n\nTravel down the “A” street for 1 unit\nTravel down the “B” street for 3 units\nTotal distance = 4 units\n\nFor two features/dimensions\n\\(Distance = |A + B|\\)\n\n\n\n\n\n\nkknn() uses Minkowski distance (see Wikipedia or less mathematical description)\n\nIt is a more complex parameterized distance formula\n\nThis parameter is called p, referred to as distance in kknn()\n\nEuclidean and Manhattan distances are special cases where p = 2 and 1, respectively\nThe default p in kknn() = 2 (Euclidean distance)\n\nThis default (like all defaults) can be changed when you define the algorithm using nearest_neighbor()\n\n\n\n\n3.8.2 Scaling X\nDistance is dependent on scales of all the features. We need to put all features on the same scale\n\nScale all features to SD = 1 (using step_scale(all_numeric_predictors()))\nRange correct [0, 1] all features (using step_range(all_numeric_predictors()))\n\n\n\n\n3.8.3 Categorical Predictors\nKNN requires numeric features (for distance calculation).\n\nFor categorical predictors, you will need to use dummy coding or other feature engineering that results in numeric features.\ne.g., step_dummy(all_nominal_predictors())"
  },
  {
    "objectID": "003_regression.html#knn-with-ames-housing-prices",
    "href": "003_regression.html#knn-with-ames-housing-prices",
    "title": "3  Introduction to Regression Models",
    "section": "3.9 KNN with Ames Housing Prices",
    "text": "3.9 KNN with Ames Housing Prices\nLet’s use KNN with Ames\n\nTrain a model using only numeric predictors and overall_qual as numeric\nUse the default k = 5 algorithm\nSet SD = 1 for all features\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars + overall_qual, \n         data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(overall_qual = as.numeric(overall_qual)) |&gt; \n1  step_scale(all_numeric_predictors())\n\n\n1\n\nRemember to take advantage of these selectors for easier code! See ?has_role for more details\n\n\n\n\n\n\nprep, bake\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt;\n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nSkim training features. Note all SD = 1\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n6\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n6\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n2.95\n1.00\n0.86\n2.21\n2.84e+00\n3.44\n11.03\n1.43\n5.19\n\n\nlot_area\n0\n1\n1.24\n1.00\n0.18\n0.92\n1.15e+00\n1.39\n20.14\n11.20\n182.91\n\n\nyear_built\n0\n1\n66.48\n1.00\n63.40\n65.86\n6.65e+01\n67.45\n67.79\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n2.33\n1.00\n0.00\n1.31\n2.62e+00\n2.62\n5.23\n-0.26\n0.10\n\n\noverall_qual\n0\n1\n4.30\n1.00\n0.71\n3.54\n4.24e+00\n4.95\n7.07\n0.20\n-0.03\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789.00\n129500.00\n1.60e+05\n213500.00\n745000.00\n1.64\n4.60\n\n\n\n\n\n\n\nSkim validation features. Note SD. Why not exactly 1?\n\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n6\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n6\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n2.92\n0.95\n0.94\n2.24\n2.81\n3.38\n7.05\n0.92\n1.16\n\n\nlot_area\n0\n1\n1.28\n1.27\n0.21\n0.92\n1.17\n1.44\n26.32\n15.64\n301.66\n\n\nyear_built\n0\n1\n66.47\n1.04\n63.23\n65.90\n66.61\n67.45\n67.79\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n2.27\n0.99\n0.00\n1.31\n2.62\n2.62\n5.23\n-0.24\n0.22\n\n\noverall_qual\n0\n1\n4.28\n0.98\n0.71\n3.54\n4.24\n4.95\n7.07\n0.00\n0.35\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311.00\n129125.00\n160000.00\n213000.00\n556581.00\n1.42\n2.97\n\n\n\n\n\n\n\nFit 5NN\n\n\nfit_5nn_5num &lt;- \n  nearest_neighbor() |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\nerror_val &lt;- bind_rows(error_val, \n                        tibble(model = \"5 numeric predictor 5nn\", \n                               rmse_val = rmse_vec(feat_val$sale_price, \n                                                   predict(fit_5nn_5num, feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 8 × 2\n  model                                  rmse_val\n  &lt;chr&gt;                                     &lt;dbl&gt;\n1 simple linear model                      51375.\n2 4 feature linear model                   39903.\n3 4 feature linear model with YJ           41660.\n4 6 feature linear model w/ms_zoning       39846.\n5 7 feature linear model                   34080.\n6 8 feature linear model w/interaction     32720.\n7 10 feature linear model w/interactions   32708.\n8 5 numeric predictor 5nn                  32837.\n\n\n\nNot bad!\n\n\nKNN also mostly solved the linearity problem\n\nWe might be able to improve the linear models with better transformations of X and Y\nHowever, this wasn’t needed for KNN!\n\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_5nn_5num, feat_val)$.pred)\n\n\n\n\n\nBut 5NN may be overfit. k = 5 is pretty low\nAgain with k = 20\n\nfit_20nn_5num &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\n\n# A tibble: 9 × 2\n  model                                  rmse_val\n  &lt;chr&gt;                                     &lt;dbl&gt;\n1 simple linear model                      51375.\n2 4 feature linear model                   39903.\n3 4 feature linear model with YJ           41660.\n4 6 feature linear model w/ms_zoning       39846.\n5 7 feature linear model                   34080.\n6 8 feature linear model w/interaction     32720.\n7 10 feature linear model w/interactions   32708.\n8 5 numeric predictor 5nn                  32837.\n9 5 numeric predictor 20nn                 30535.\n\n\n\nThat helped some\n\n\nOne more time with k = 50 to see where we are in the bias-variance function\n\nfit_50nn_5num &lt;- \n  nearest_neighbor(neighbors = 50) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\n\n# A tibble: 10 × 2\n   model                                  rmse_val\n   &lt;chr&gt;                                     &lt;dbl&gt;\n 1 simple linear model                      51375.\n 2 4 feature linear model                   39903.\n 3 4 feature linear model with YJ           41660.\n 4 6 feature linear model w/ms_zoning       39846.\n 5 7 feature linear model                   34080.\n 6 8 feature linear model w/interaction     32720.\n 7 10 feature linear model w/interactions   32708.\n 8 5 numeric predictor 5nn                  32837.\n 9 5 numeric predictor 20nn                 30535.\n10 5 numeric predictor 50nn                 31055.\n\n\n\nToo high, now we have bias……\nWe will learn a more rigorous method for selecting the optimal value for \\(k\\) (i.e., tuning this hyperparameter) in unit 5\n\n\nTo better understand bias-variance trade-off, let’s look at error across these three values of \\(k\\) in train and validation for Ames\nTraining\n\nRemember that training error would be 0 for k = 1\nTraining error is increasing as \\(k\\) increases b/c it KNN is overfitting less (so its not fitting the noise in train as well)\n\n\nrmse_vec(feat_trn$sale_price, \n         predict(fit_5nn_5num, feat_trn)$.pred)\n\n[1] 19012.94\n\nrmse_vec(feat_trn$sale_price, \n         predict(fit_20nn_5num, feat_trn)$.pred)\n\n[1] 27662.2\n\nrmse_vec(feat_trn$sale_price, \n         predict(fit_50nn_5num, feat_trn)$.pred)\n\n[1] 31069.12\n\n\n\nValidation\n\nValidation error is first going down as \\(k\\) increases (and it would have been very high for k = 1)\nBias is likely increasing a bit\nBut this is compensated by big decreases in overfitting variance\nThe trade-off is good for k = 20 relative to 5 and 1\nAt some point, as \\(k\\) increases the increase in bias outweighed the decrease in variance and validation error increased too.\n\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_5nn_5num, feat_val)$.pred)\n\n[1] 32837.37\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_20nn_5num, feat_val)$.pred)\n\n[1] 30535.04\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_50nn_5num, feat_val)$.pred)\n\n[1] 31054.6\n\n\n\nLet’s do one final example and add one of our nominal variables into the model: ms_zoning\n\nNeed to collapse levels and then dummy\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars + \n           overall_qual + ms_zoning, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(overall_qual = as.numeric(overall_qual)) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\")) |&gt;\n  step_dummy(ms_zoning) |&gt; \n  step_scale(all_numeric_predictors())\n\n\n\nprep, bake\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nFit\n\n\nfit_20nn_5num_mszone &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\nevaluate\n\n\n\n# A tibble: 11 × 2\n   model                                   rmse_val\n   &lt;chr&gt;                                      &lt;dbl&gt;\n 1 simple linear model                       51375.\n 2 4 feature linear model                    39903.\n 3 4 feature linear model with YJ            41660.\n 4 6 feature linear model w/ms_zoning        39846.\n 5 7 feature linear model                    34080.\n 6 8 feature linear model w/interaction      32720.\n 7 10 feature linear model w/interactions    32708.\n 8 5 numeric predictor 5nn                   32837.\n 9 5 numeric predictor 20nn                  30535.\n10 5 numeric predictor 50nn                  31055.\n11 5 numeric predictor 20nn with ms_zoning   30172.\n\n\n\nNow it helps.\n\nMight have to do with interactions with other predictors that we didn’t model in the linear model\nKNN automatically accommodates interactions. Why?\nThis model is a bit more complex and might benefit further from higher \\(k\\)\n\n\nAs a teaser, here is another performance metric for this model - \\(R^2\\). Not too shabby! Remember, there is certainly some irreducible error in sale_price that will put a ceiling on \\(R^2\\) and a floor on RMSE\n\nrsq_vec(feat_val$sale_price, \n        predict(fit_20nn_5num_mszone, feat_val)$.pred)\n\n[1] 0.8404044\n\n\nOverall, we now have a model that predicts housing prices with about 30K of RMSE and accounting for 84% of the variance. I am sure you can improve on this!"
  },
  {
    "objectID": "003_regression.html#discussion",
    "href": "003_regression.html#discussion",
    "title": "3  Introduction to Regression Models",
    "section": "3.10 Discussion",
    "text": "3.10 Discussion\n\n3.10.1 Announcements\n\nRoom change for two days\n\nThursday, 2/15\nThursday, 2/29\nRoom 121\nIf we like it……\n\nFeedback - THANKS!\n\nconsistent feedback will be implemented (as best I can!)\ncaptions\nvocabulary and concepts - new appendix\nuse of web “book” - better thought of as lecture slides\nyou can clone book_iaml. Render to slides with your notes, render to pdf\nUse of questions for dicussion\n\nDidn’t work to read directly\nRank order based on frequency and importance\nPut some in slack\nCan’t do all. Ask in slack, ask in office hours or after discussion/lab\n\n\nReprex\n\nWe need you to try to make reprex for help on application assignments\n\nHomework is basically same for unit 4\n\nNew dataset - titanic\nDo EDA but we don’t need to see it\nFit KNN and RDA models (will learn about LDA, QDA and RDA in unit)\nSubmit predictions. Free lunch!\nAnd for this free lunch….\n\n\n\n\nread_csv(here::here(path_data, \"lunch_003.csv\")) |&gt; \n  print_kbl()\n\nRows: 20 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): name\ndbl (1): rmse_test\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\n\nname\nrmse_test\n\n\n\n\nDong\n25495.53\n\n\nSimental\n28733.22\n\n\nPhipps\n28794.84\n\n\nYang\n30420.01\n\n\nLi\n31534.42\n\n\nYu\n31874.12\n\n\nNA\n32606.15\n\n\nNA\n33614.59\n\n\nNA\n33877.07\n\n\nNA\n33879.19\n\n\nNA\n34315.31\n\n\nNA\n34692.22\n\n\nNA\n35034.74\n\n\nNA\n35154.67\n\n\nNA\n35683.85\n\n\nNA\n36101.95\n\n\nNA\n36266.80\n\n\nNA\n36473.84\n\n\nNA\n38974.43\n\n\nNA\n42367.31\n\n\n\n\n\n\n\n\n\n\n3.10.2 Sources of error\n\nWhat are two broad sources of error?\nWhat are two broad sources of reducible error. Describe what they are and factors that affect them?\nWhy do we need independent validation data to select the best model configuration?\nWhy do we need test data if we used validation data to select among many model configurations\nWhat is RMSE? Connect it to metric you already know? How is it being used in lm (two ways)?; in knn (one way)?\nHow does bias and variance manifest when you look at your performance metric (RMSE) in training and validation sets?\nWill the addition of new features to a (lm?) model always reduce RMSE in train? in validation? Connect to concepts of bias and variance\n\n\n\n\n3.10.3 KNN\n\nHow does KNN use training data to make predictions\nWhat is k and how does it get used when making predictions?\nWhat is the impact of k on bias and variance/overfitting?\nk=1: performance in train? in val?\nDistance measures: use Euclidean (default in kknn)!\nTuning K: stay “tuned”\n\n\n\n\n3.10.4 Interaction in KNN - Consider bias first (but also variance) in this example\n\nSimulate data\nFit models for lm and knn with and without interaction\nTook some shortcuts (no recipe, predict back into train)\n\n\nn &lt;- 200\nset.seed(5433)\n\nd &lt;- tibble(x1 = runif(n, 0,100), # uniform\n               x2 = rep(c(0,1), n/2), # dichotomous\n               x1_x2 = x1*x2, # interaction\n               y = rnorm(n, 0 + 1*x1 + 10*x2 + 10* x1_x2, 20)) #DGP + noise\n\nfit_lm &lt;- \n  linear_reg() |&gt;   \n  set_engine(\"lm\") |&gt;   \n  fit(y ~ x1 + x2, data = d)\n\nfit_lm_int &lt;- \n  linear_reg() |&gt;   \n  set_engine(\"lm\") |&gt;   \n  fit(y ~ x1 + x2 + x1_x2, data = d)\n\nfit_knn &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y ~ x1 + x2, data = d)\n\nfit_knn_int &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y ~ x1 + x2 + x1_x2, data = d)\n\nd &lt;- d |&gt; \n  mutate(pred_lm = predict(fit_lm, d)$.pred,\n         pred_lm_int = predict(fit_lm_int, d)$.pred,\n         pred_knn = predict(fit_knn, d)$.pred,\n         pred_knn_int = predict(fit_knn_int, d)$.pred)\n\n\n\nPredictions from linear model with and without interaction\n\nYou NEED interaction features with LM\n\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_lm)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"lm without interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_lm_int)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"lm with interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\n\n\n\nPredictions from KNN with and without interaction\n\nYou do NOT need interaction features with KNN!\n\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_knn)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"KNN without interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_knn_int)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"KNN with interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\n\n\n\n\n3.10.5 LM vs. KNN better with some predictors or overall?\n\n“Why do some features seem to improve performance more in linear models or only in KNNs?”\n“What are some contexts where KNN doesn’t work well? In other words, what are the advantages/disadvantages of using KNN?”\n\nAlways comes down to bias vs. variance\nFlexibility and N are key moderators of these two key factors.\n\nk? - impact on bias, variance?\n\nKNN for explanation?\n\nVisualizations (think of interaction plot above) make clear the effect\nWill learn more (better visualizations, variable importance, model comparisons) in later unit\n\n\n\n\n\n3.10.6 Normalizing transformations - Yeo Johnson\n\nwhen needed for lm?\nwhen needed for knn?\n\n\n\n\n3.10.7 Dummy coding\n\nWhy do we do it?\nDescribe the values assigned to the dummy coded features\nWhy these values? In other words, how can you interpret the effect of a dummy coded feature?\nHow is it different from one-hot coding. When to use or not use one-hot coding?\n\n\n\n\n3.10.8 Exploration\n\n“I feel that I can come up with models that decrease the RMSE, but I don’t have good priors on whether adding any particular variable or observation will result in an improved model. I still feel a little weird just adding and dropping variables into a KNN and seeing what gets the validation RMSE the lowest (even though because we’re using validation techniques it’s a fine technique)”\n\nExploration is learning. This is research. If you knew the answer you wouldn’t be doing the study\nDomain knowledge is still VERY important\nSome algorithms (LASSO, glmnet) will help with feature selection\nstaying organized\n\nScript structure\nGood documentation - QMD as analysis notebook\n\nSome overfitting to validation will occur? Consequence? Solutions?\n\n\n\n\n\n3.10.9 “Curse of dimensionality” - Bias vs. variance\n\nMissing features produce biased models.\nUnnecessary features or even many features relative to N produce variance\nDoes your available N in your algorithm support the features you need to have low bias.\n\nMostly an empirical question - can’t really tell otherwise outside of simulated data. Validation set is critical!\nFlexible models often need more N holding features constant\nRegularization (unit 6) will work well when lots of features\n\n\n\n\n\n3.10.10 Transformations of numeric predictors\n\nUse of plot_truth() [predicted vs. observed]\nResiduals do not have mean of 0 for every \\(\\hat{y}\\)\n\nConsequence: biased parameter estimates. Linear is bad DGP\nAlso bad test of questions RE the predictor (underestimate? misinform)\n\nNon-normal residuals\n\nConsequence: lm parameter estimates still unbiased (for linear DGP) but more “efficient” solutions exist\nBad for prediction b/c higher variance than other solutions\nMay suggest omission of variables\n\nHeteroscasticity\n\nConsequence: Inefficient and inaccurate standard errors.\nStatistical tests wrong\nPoor prediction for some (where larger variance of residuals) \\(\\hat{y}\\)\nhigher variance overall than other solutions - bad again for prediction\n\nTransformation of outcome?\n\nmetric\nback to raw predictions\n\n\n\n\n\n3.10.11 “In GLM, why correlation/collinearity among predictors will cause larger variance? Is it because of overfitting?”\n\n\n3.10.12 KNN (black box) for explanatory purposes\n\n\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2023. An Introduction to Statistical Learning: With Applications in R. 2nd ed. Springer Texts in Statistics. New York: Springer-Verlag."
  },
  {
    "objectID": "004_classification.html#unit-overview",
    "href": "004_classification.html#unit-overview",
    "title": "4  Introduction to Classification Models",
    "section": "4.1 Unit Overview",
    "text": "4.1 Unit Overview\n\n4.1.1 Learning Objectives\n\nBayes classifier\nLogistic regression\n\nprobability, odds, and logit models\ndefinitions of odds and odds ratios\n\nK nearest neighbors\nLinear discriminant analysis\nQuadratic discriminant analysis\nRegularized discriminant analysis\nDecision boundaries in the two feature space\nRelative costs and benefits of these different statistical algorithms\n\n\n\n\n4.1.2 Readings\n\nJames et al. (2023) Chapter 4, pp 129 - 164\n\n\n\n4.1.3 Lecture Videos\n\nLecture 1: The Bayes Classifier\nLecture 2: Conceptual Overview of Logistic Regression\nLecture 3: EDA with the Cars Dataset\nLecture 4: Logistic Regression with Cars Dataset\nLecture 5: KNN with Cars Dataset\nLecture 6: LDA, DQA, RDA with Cars Dataset\nLecture 7: Comparisons among Classifiers\nDiscussion\n\nPost questions or discuss readings or lectures on the appropriate Slack channel\n\n\n\n4.1.4 Application Assignment and Quiz\n\ndata: raw; test\ndata dictionary\ncleaning EDA qmd\nrda qmd\nknn qmd\nsolution: modeling EDA rda; knn\n\nPost questions to application_assignments\nSubmit the application assignment here and complete the unit quiz by 8 pm on Wednesday, February 14th\n\nOur eventual goal in this unit is for you to build a machine learning classification model that can accurately predict who lived vs. died on the titanic.\n\n\nPrior to that, we will work with an example where we classify a car as high or low fuel efficient (i.e., a dichtomous outcome based on miles per gallon) using features engineered from its characteristics"
  },
  {
    "objectID": "004_classification.html#bayes-classifier",
    "href": "004_classification.html#bayes-classifier",
    "title": "4  Introduction to Classification Models",
    "section": "4.2 Bayes Classifier",
    "text": "4.2 Bayes Classifier\nFirst, lets introduce the Bayes classifier, which is the classifier that will have the lowest error rate of all classifiers using the same set of features.\n\nThe figure below displays simulated data for a classification problem for K = 2 classes as a function of X1 and X2\n\nThe Bayes classifier assigns each observation its most likely class given its conditional probabilities for the values for X1 and X2\n\n\\(Pr(Y = k | X = x_0) for\\:k = 1:K\\)\nFor K = 2, this means assigning to the class with Pr &gt; .50\nThis decision boundary for the two class problem is displayed in the figure\n\n\nThe Bayes classifier provides the minimum error rate for test data\n\nError rate for any \\(x_0\\) will be \\(1 - max (Pr( Y = k | X = x_0))\\)\nOverall error rate will be the average of this across all possible X\nThis is the irreducible error for classification problems\nThis is a theoretical model b/c (except for simulated data), we don’t know the conditional probabilities based on X\nMany classification models try to estimate these conditionals\n\nLet’s talk now about some of these classification models"
  },
  {
    "objectID": "004_classification.html#logistic-regression-a-conceptual-review",
    "href": "004_classification.html#logistic-regression-a-conceptual-review",
    "title": "4  Introduction to Classification Models",
    "section": "4.3 Logistic Regression: A Conceptual Review",
    "text": "4.3 Logistic Regression: A Conceptual Review\nLogistic regression (a special case of the generalized linear model) estimates the conditional probability for each class given X (a specific set of values for our features)\n\nIn the binary outcome case, we will often refer to the two outcomes as the positive class and the negative class\nThis makes most sense in some applied settings where we are most interested in predicting if one of the two classes is likely, e.g.,\n\nPresence of heart disease\nPositive for some psychiatric diagnoses\nLapse back to alcohol use in people with alcohol use disorder\n\n\n\nLogistic regression is used frequently for binary and multi-level outcomes because\n\nThe general linear model makes predictions that are not bounded by [0, 1] and do not represent true estimates of conditional probability for each class\nLogistic regression approaches can be modified to accommodate multi-class outcomes (i.e., more than two levels) even when they are not ordered\nNonetheless, the general linear model is still used at times to predict binary outcomes (see Linear Probability Model) so you should be aware of it. We won’t discuss it further here.\n\n\n\nLogistic regression provides predicted conditional probabilities for one class (positive class) for any specific set of values for our features (X)\n\n\\(Pr(positive\\:class | X) = \\frac{e^{\\beta_0 + \\beta_1*X_1 + \\beta_2*X_2 + ... + \\beta_p * X_p}}{1 + e^{\\beta_0 + \\beta_1*X_1 + \\beta_2*X_2 + ... + \\beta_p * X_p}}\\)\nThese conditional probabilities are bounded by [0, 1]\nTo maximize accuracy (as per Bayes classifier),\n\nwe predict the positive case if \\(Pr(positive class | X) &gt; .5\\) for any specific X\notherwise we predict the negative class\n\n\n\nAs a simple parametric model, logistic regression is commonly used for explanatory purposes as well as prediction\n\nFor these reasons, it is worthwhile to fully understand how to work with the logistic function to quantify and describe the effects of your features/predictors in terms of\n\nProbability\nOdds\n[Log-odds or logit]\nOdds ratio\n\n\nThe logistic function yields the probability of the positive class given X\n\nHowever, in some instances, it may make more sense to describe the odds of the positive case occurring (e.g., horse racing) rather than probability\n\n\n\nOdds are defined with respect to probabilities as follows:\n\n\\(odds = \\frac{Pr(positive\\:class|X)} {1 - Pr(positive\\:class|X)}\\)\n\n\nFor example, if the UW Badgers have a .5 probability of winning some upcoming game based on X, their odds of winning are 1 (to 1)\n\n\\(\\frac{0.5} {1 - 0.5}\\)\n\nIf the UW Badgers have a .75 probability of winning some upcoming game based on X, their odds of winning are 3 (:1; ‘3 to 1’)\n\\(\\frac{0.75} {1 - 0.75}\\)\n\nIf the UW Badgers have a .25 probability of winning some upcoming game based on X, their odds of winning are .33 (1:3)\n\\(\\frac{0.25} {1 - 0.25}\\)\n\n\n\n\nThe logistic function can be modified to provide odds directly:\n\nLogistic function:\n\n\\(Pr(positive\\:class | X) = \\frac{e^{\\beta_0 + \\beta_1*X_1 + \\beta_2*X_2 + ... + \\beta_p * X_p}}{1 + e^{\\beta_0 + \\beta_1*X_1 + \\beta_2*X_2 + ... + \\beta_p * X_p}}\\)\n\n\n\nDefinition of odds:\n\n\\(odds = \\frac{Pr(positive\\:class|X)} {1 - Pr(positive\\:class|X)}\\)\n\n\n\nSubstitute logistic function for \\(Pr(positive\\:class|X)\\) on top and bottom and simplify to get:\n\n\\(odds(positive\\:class|X) = e^{\\beta_0 + \\beta_1*X_1 + \\beta_2*X_2 + ... + \\beta_p * X_p}\\)\nOdds are bounded by [0, \\(\\infty\\)]\n\n\nThe logistic function can be modified further such that the outcome (log-odds/logit) is a linear function of your features\n\nIf we take the natural log (base e) of both sides of the odds equation, we get:\n\n\\(log(odds(positive\\:class|X)) = \\beta_0 + \\beta_1*X_1 + \\beta_2*X_2 + ... + \\beta_p * X_p\\)\nLog-odds are unbounded \\([-\\infty, \\infty]\\)\n\n\n\nUse of logit transformation:\n\nprovides the connection between the general linear model and generalized linear models (in this case with link = logit, family = binomial).\n\nNotice that the logit/log-odds is a linear combination of the features (just like in the general linear model)\n\n\nOdds and probability are descriptive but they are not linear functions of X\n\nTherefore, parameter estimates from these models aren’t very useful to describe the effect of features\nThis is because unit change in Y per unit change in any specific feature is not the same for all values of the feature\n\n\nLog-odds are a linear function of X\n\nTherefore, you can say that log-odds of positive class increases by \\(\\beta_1\\) for every one unit increase in \\(x_1\\)\nHowever, log-odds are NOT very descriptive/intuitive so they are not that useful for explanatory purposes\n\n\nThe odds ratio addresses these problems\n\nOdds are defined at a specific set of values across the features in your model. For example, with one feature:\n\n\\(odds = \\frac{Pr(positive\\:class|x_1)} {1 - Pr(positive\\:class|x_1)}\\)\n\n\n\nThe odds ratio describes the change in odds for a change of c units in your feature. With some manipulation:\n\n\\(Odds\\:ratio = \\frac{odds(x+c)}{odds(x)}\\)\n\\(Odds\\:ratio = \\frac{e^{\\beta_0 + \\beta_1*(x_1 + c)}}{e^{\\beta_0 + \\beta_1*x_1}}\\)\n\\(Odds\\:ratio = e^{c*\\beta_1}\\)\n\n\nAs an example, if we fit a logistic regression model to predict the probability of the Badgers winning a home football game given the attendance (measured in individual spectators at the game), we might find \\(\\beta_1\\) = .000075.\n\nGiven this, the odds ratio associated with every increase in 10,000 spectators:\n\n\\(= e^{c * \\beta_1}\\)\n\\(= e^{10000 * .000075}\\)\n\\(= 2.1\\)\nFor every increase of 10,000 spectators, the odds of the Badgers winning doubles"
  },
  {
    "objectID": "004_classification.html#the-cars-dataset",
    "href": "004_classification.html#the-cars-dataset",
    "title": "4  Introduction to Classification Models",
    "section": "4.4 The Cars Dataset",
    "text": "4.4 The Cars Dataset\nNow, let’s put this all of this together in the Cars dataset from Carnegie Mellon’s StatLib Dataset Archive\n\n\nOur goal is to build a classifier (machine learning model for a categorical outcome) that classifies cars as either high or low mpg.\n\n\n4.4.1 Cleaning EDA\nLet’s start with some cleaning EDA\n\nOpen and “skim” it RE variable names, classes & missing data\nVariable names are already tidy\nno missing data\nmins (p0) and maxes(p100) for numeric look good\nthere are two character variables (mpq and name) that will need to be re-classed\n\n\ndata_all &lt;- read_csv(here::here(path_data, \"auto_all.csv\"),\n                     col_types = cols()) \n\ndata_all |&gt; skim_some()\n\n\nData summary\n\n\nName\ndata_all\n\n\nNumber of rows\n392\n\n\nNumber of columns\n9\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n2\n\n\nnumeric\n7\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nmpg\n0\n1\n3\n4\n0\n2\n0\n\n\nname\n0\n1\n6\n36\n0\n301\n0\n\n\n\nVariable type: numeric\n\n\n\nskim_variable\nn_missing\ncomplete_rate\np0\np100\n\n\n\n\ncylinders\n0\n1\n3\n8.0\n\n\ndisplacement\n0\n1\n68\n455.0\n\n\nhorsepower\n0\n1\n46\n230.0\n\n\nweight\n0\n1\n1613\n5140.0\n\n\nacceleration\n0\n1\n8\n24.8\n\n\nyear\n0\n1\n70\n82.0\n\n\norigin\n0\n1\n1\n3.0\n\n\n\n\n\n\n\nmpg is ordinal, so lets set the levels to indicate the order.\nAfter reviewing the data dictionary, we see that origin is a nominal predictor that is coded numeric (where 1 = American, 2 = European, and 3 = Japanese). Let’s recode as character with meaningful labels and then class as a factor\nand lets not forget to re-class name too\n\n\ndata_all &lt;- data_all |&gt; \n  mutate(mpg = factor(mpg, levels = c(\"low\", \"high\")),\n         name = factor(name), \n         origin = factor (origin),\n1         origin = fct_recode(as.character(origin),\n                             \"american\" = \"1\",\n                            \"european\" = \"2\",\n                            \"japanese\" = \"3\")) \n\n\n1\n\nfct_recode() works on levels stored as characters, so convert 1, 2, 3, to character first.\n\n\n\n\n\nNow, we can explore responses for categorical variables\n\nOther than name, responses for all other variables are tidy\nname has many different responses\nWe won’t know how to handle this until we get to later units in the class on natural language processing!\n\n\ndata_all |&gt; \n  select(where(is.factor)) |&gt;\n  walk(\\(column) print(levels(column)))\n\n[1] \"low\"  \"high\"\n[1] \"american\" \"european\" \"japanese\"\n  [1] \"amc ambassador brougham\"             \n  [2] \"amc ambassador dpl\"                  \n  [3] \"amc ambassador sst\"                  \n  [4] \"amc concord\"                         \n  [5] \"amc concord d/l\"                     \n  [6] \"amc concord dl 6\"                    \n  [7] \"amc gremlin\"                         \n  [8] \"amc hornet\"                          \n  [9] \"amc hornet sportabout (sw)\"          \n [10] \"amc matador\"                         \n [11] \"amc matador (sw)\"                    \n [12] \"amc pacer\"                           \n [13] \"amc pacer d/l\"                       \n [14] \"amc rebel sst\"                       \n [15] \"amc spirit dl\"                       \n [16] \"audi 100 ls\"                         \n [17] \"audi 100ls\"                          \n [18] \"audi 4000\"                           \n [19] \"audi 5000\"                           \n [20] \"audi 5000s (diesel)\"                 \n [21] \"audi fox\"                            \n [22] \"bmw 2002\"                            \n [23] \"bmw 320i\"                            \n [24] \"buick century\"                       \n [25] \"buick century 350\"                   \n [26] \"buick century limited\"               \n [27] \"buick century luxus (sw)\"            \n [28] \"buick century special\"               \n [29] \"buick electra 225 custom\"            \n [30] \"buick estate wagon (sw)\"             \n [31] \"buick lesabre custom\"                \n [32] \"buick opel isuzu deluxe\"             \n [33] \"buick regal sport coupe (turbo)\"     \n [34] \"buick skyhawk\"                       \n [35] \"buick skylark\"                       \n [36] \"buick skylark 320\"                   \n [37] \"buick skylark limited\"               \n [38] \"cadillac eldorado\"                   \n [39] \"cadillac seville\"                    \n [40] \"capri ii\"                            \n [41] \"chevroelt chevelle malibu\"           \n [42] \"chevrolet bel air\"                   \n [43] \"chevrolet camaro\"                    \n [44] \"chevrolet caprice classic\"           \n [45] \"chevrolet cavalier\"                  \n [46] \"chevrolet cavalier 2-door\"           \n [47] \"chevrolet cavalier wagon\"            \n [48] \"chevrolet chevelle concours (sw)\"    \n [49] \"chevrolet chevelle malibu\"           \n [50] \"chevrolet chevelle malibu classic\"   \n [51] \"chevrolet chevette\"                  \n [52] \"chevrolet citation\"                  \n [53] \"chevrolet concours\"                  \n [54] \"chevrolet impala\"                    \n [55] \"chevrolet malibu\"                    \n [56] \"chevrolet malibu classic (sw)\"       \n [57] \"chevrolet monte carlo\"               \n [58] \"chevrolet monte carlo landau\"        \n [59] \"chevrolet monte carlo s\"             \n [60] \"chevrolet monza 2+2\"                 \n [61] \"chevrolet nova\"                      \n [62] \"chevrolet nova custom\"               \n [63] \"chevrolet vega\"                      \n [64] \"chevrolet vega (sw)\"                 \n [65] \"chevrolet vega 2300\"                 \n [66] \"chevrolet woody\"                     \n [67] \"chevy c10\"                           \n [68] \"chevy c20\"                           \n [69] \"chevy s-10\"                          \n [70] \"chrysler cordoba\"                    \n [71] \"chrysler lebaron medallion\"          \n [72] \"chrysler lebaron salon\"              \n [73] \"chrysler lebaron town @ country (sw)\"\n [74] \"chrysler new yorker brougham\"        \n [75] \"chrysler newport royal\"              \n [76] \"datsun 1200\"                         \n [77] \"datsun 200-sx\"                       \n [78] \"datsun 200sx\"                        \n [79] \"datsun 210\"                          \n [80] \"datsun 210 mpg\"                      \n [81] \"datsun 280-zx\"                       \n [82] \"datsun 310\"                          \n [83] \"datsun 310 gx\"                       \n [84] \"datsun 510\"                          \n [85] \"datsun 510 (sw)\"                     \n [86] \"datsun 510 hatchback\"                \n [87] \"datsun 610\"                          \n [88] \"datsun 710\"                          \n [89] \"datsun 810\"                          \n [90] \"datsun 810 maxima\"                   \n [91] \"datsun b-210\"                        \n [92] \"datsun b210\"                         \n [93] \"datsun b210 gx\"                      \n [94] \"datsun f-10 hatchback\"               \n [95] \"datsun pl510\"                        \n [96] \"dodge aries se\"                      \n [97] \"dodge aries wagon (sw)\"              \n [98] \"dodge aspen\"                         \n [99] \"dodge aspen 6\"                       \n[100] \"dodge aspen se\"                      \n[101] \"dodge challenger se\"                 \n[102] \"dodge charger 2.2\"                   \n[103] \"dodge colt\"                          \n[104] \"dodge colt (sw)\"                     \n[105] \"dodge colt hardtop\"                  \n[106] \"dodge colt hatchback custom\"         \n[107] \"dodge colt m/m\"                      \n[108] \"dodge coronet brougham\"              \n[109] \"dodge coronet custom\"                \n[110] \"dodge coronet custom (sw)\"           \n[111] \"dodge d100\"                          \n[112] \"dodge d200\"                          \n[113] \"dodge dart custom\"                   \n[114] \"dodge diplomat\"                      \n[115] \"dodge magnum xe\"                     \n[116] \"dodge monaco (sw)\"                   \n[117] \"dodge monaco brougham\"               \n[118] \"dodge omni\"                          \n[119] \"dodge rampage\"                       \n[120] \"dodge st. regis\"                     \n[121] \"fiat 124 sport coupe\"                \n[122] \"fiat 124 tc\"                         \n[123] \"fiat 124b\"                           \n[124] \"fiat 128\"                            \n[125] \"fiat 131\"                            \n[126] \"fiat strada custom\"                  \n[127] \"fiat x1.9\"                           \n[128] \"ford country\"                        \n[129] \"ford country squire (sw)\"            \n[130] \"ford escort 2h\"                      \n[131] \"ford escort 4w\"                      \n[132] \"ford f108\"                           \n[133] \"ford f250\"                           \n[134] \"ford fairmont\"                       \n[135] \"ford fairmont (auto)\"                \n[136] \"ford fairmont (man)\"                 \n[137] \"ford fairmont 4\"                     \n[138] \"ford fairmont futura\"                \n[139] \"ford fiesta\"                         \n[140] \"ford futura\"                         \n[141] \"ford galaxie 500\"                    \n[142] \"ford gran torino\"                    \n[143] \"ford gran torino (sw)\"               \n[144] \"ford granada\"                        \n[145] \"ford granada ghia\"                   \n[146] \"ford granada gl\"                     \n[147] \"ford granada l\"                      \n[148] \"ford ltd\"                            \n[149] \"ford ltd landau\"                     \n[150] \"ford maverick\"                       \n[151] \"ford mustang\"                        \n[152] \"ford mustang gl\"                     \n[153] \"ford mustang ii\"                     \n[154] \"ford mustang ii 2+2\"                 \n[155] \"ford pinto\"                          \n[156] \"ford pinto (sw)\"                     \n[157] \"ford pinto runabout\"                 \n[158] \"ford ranger\"                         \n[159] \"ford thunderbird\"                    \n[160] \"ford torino\"                         \n[161] \"ford torino 500\"                     \n[162] \"hi 1200d\"                            \n[163] \"honda accord\"                        \n[164] \"honda accord cvcc\"                   \n[165] \"honda accord lx\"                     \n[166] \"honda civic\"                         \n[167] \"honda civic (auto)\"                  \n[168] \"honda civic 1300\"                    \n[169] \"honda civic 1500 gl\"                 \n[170] \"honda civic cvcc\"                    \n[171] \"honda prelude\"                       \n[172] \"maxda glc deluxe\"                    \n[173] \"maxda rx3\"                           \n[174] \"mazda 626\"                           \n[175] \"mazda glc\"                           \n[176] \"mazda glc 4\"                         \n[177] \"mazda glc custom\"                    \n[178] \"mazda glc custom l\"                  \n[179] \"mazda glc deluxe\"                    \n[180] \"mazda rx-4\"                          \n[181] \"mazda rx-7 gs\"                       \n[182] \"mazda rx2 coupe\"                     \n[183] \"mercedes benz 300d\"                  \n[184] \"mercedes-benz 240d\"                  \n[185] \"mercedes-benz 280s\"                  \n[186] \"mercury capri 2000\"                  \n[187] \"mercury capri v6\"                    \n[188] \"mercury cougar brougham\"             \n[189] \"mercury grand marquis\"               \n[190] \"mercury lynx l\"                      \n[191] \"mercury marquis\"                     \n[192] \"mercury marquis brougham\"            \n[193] \"mercury monarch\"                     \n[194] \"mercury monarch ghia\"                \n[195] \"mercury zephyr\"                      \n[196] \"mercury zephyr 6\"                    \n[197] \"nissan stanza xe\"                    \n[198] \"oldsmobile cutlass ciera (diesel)\"   \n[199] \"oldsmobile cutlass ls\"               \n[200] \"oldsmobile cutlass salon brougham\"   \n[201] \"oldsmobile cutlass supreme\"          \n[202] \"oldsmobile delta 88 royale\"          \n[203] \"oldsmobile omega\"                    \n[204] \"oldsmobile omega brougham\"           \n[205] \"oldsmobile starfire sx\"              \n[206] \"oldsmobile vista cruiser\"            \n[207] \"opel 1900\"                           \n[208] \"opel manta\"                          \n[209] \"peugeot 304\"                         \n[210] \"peugeot 504\"                         \n[211] \"peugeot 504 (sw)\"                    \n[212] \"peugeot 505s turbo diesel\"           \n[213] \"peugeot 604sl\"                       \n[214] \"plymouth 'cuda 340\"                  \n[215] \"plymouth arrow gs\"                   \n[216] \"plymouth champ\"                      \n[217] \"plymouth cricket\"                    \n[218] \"plymouth custom suburb\"              \n[219] \"plymouth duster\"                     \n[220] \"plymouth fury\"                       \n[221] \"plymouth fury gran sedan\"            \n[222] \"plymouth fury iii\"                   \n[223] \"plymouth grand fury\"                 \n[224] \"plymouth horizon\"                    \n[225] \"plymouth horizon 4\"                  \n[226] \"plymouth horizon miser\"              \n[227] \"plymouth horizon tc3\"                \n[228] \"plymouth reliant\"                    \n[229] \"plymouth sapporo\"                    \n[230] \"plymouth satellite\"                  \n[231] \"plymouth satellite custom\"           \n[232] \"plymouth satellite custom (sw)\"      \n[233] \"plymouth satellite sebring\"          \n[234] \"plymouth valiant\"                    \n[235] \"plymouth valiant custom\"             \n[236] \"plymouth volare\"                     \n[237] \"plymouth volare custom\"              \n[238] \"plymouth volare premier v8\"          \n[239] \"pontiac astro\"                       \n[240] \"pontiac catalina\"                    \n[241] \"pontiac catalina brougham\"           \n[242] \"pontiac firebird\"                    \n[243] \"pontiac grand prix\"                  \n[244] \"pontiac grand prix lj\"               \n[245] \"pontiac j2000 se hatchback\"          \n[246] \"pontiac lemans v6\"                   \n[247] \"pontiac phoenix\"                     \n[248] \"pontiac phoenix lj\"                  \n[249] \"pontiac safari (sw)\"                 \n[250] \"pontiac sunbird coupe\"               \n[251] \"pontiac ventura sj\"                  \n[252] \"renault 12 (sw)\"                     \n[253] \"renault 12tl\"                        \n[254] \"renault 5 gtl\"                       \n[255] \"saab 99e\"                            \n[256] \"saab 99gle\"                          \n[257] \"saab 99le\"                           \n[258] \"subaru\"                              \n[259] \"subaru dl\"                           \n[260] \"toyota carina\"                       \n[261] \"toyota celica gt\"                    \n[262] \"toyota celica gt liftback\"           \n[263] \"toyota corolla\"                      \n[264] \"toyota corolla 1200\"                 \n[265] \"toyota corolla 1600 (sw)\"            \n[266] \"toyota corolla liftback\"             \n[267] \"toyota corolla tercel\"               \n[268] \"toyota corona\"                       \n[269] \"toyota corona hardtop\"               \n[270] \"toyota corona liftback\"              \n[271] \"toyota corona mark ii\"               \n[272] \"toyota cressida\"                     \n[273] \"toyota mark ii\"                      \n[274] \"toyota starlet\"                      \n[275] \"toyota tercel\"                       \n[276] \"toyouta corona mark ii (sw)\"         \n[277] \"triumph tr7 coupe\"                   \n[278] \"vokswagen rabbit\"                    \n[279] \"volkswagen 1131 deluxe sedan\"        \n[280] \"volkswagen 411 (sw)\"                 \n[281] \"volkswagen dasher\"                   \n[282] \"volkswagen jetta\"                    \n[283] \"volkswagen model 111\"                \n[284] \"volkswagen rabbit\"                   \n[285] \"volkswagen rabbit custom\"            \n[286] \"volkswagen rabbit custom diesel\"     \n[287] \"volkswagen rabbit l\"                 \n[288] \"volkswagen scirocco\"                 \n[289] \"volkswagen super beetle\"             \n[290] \"volkswagen type 3\"                   \n[291] \"volvo 144ea\"                         \n[292] \"volvo 145e (sw)\"                     \n[293] \"volvo 244dl\"                         \n[294] \"volvo 245\"                           \n[295] \"volvo 264gl\"                         \n[296] \"volvo diesel\"                        \n[297] \"vw dasher (diesel)\"                  \n[298] \"vw pickup\"                           \n[299] \"vw rabbit\"                           \n[300] \"vw rabbit c (diesel)\"                \n[301] \"vw rabbit custom\"                    \n\n\n\nRemove name\n\n\ndata_all &lt;- data_all |&gt; \n  select(-name)\n\n\nFinally, let’s make and save our training and validation sets. If we were doing model building for prediction we would also need a test set but we will focus this unit on just selecting the best model but not rigorously evaluating it.\n\nLet’s use a 75/25 split, stratified on mpg\nDon’t forget to set a seed in case you need to re-split again in the future!\n\n\nset.seed(20110522) \n\nsplits &lt;- data_all |&gt; \n  initial_split(prop = .75, strata = \"mpg\")\n\nsplits |&gt; \n  analysis() |&gt; \n  glimpse() |&gt; \n  write_csv(here::here(path_data, \"auto_trn.csv\"))\n\nRows: 294\nColumns: 8\n$ mpg          &lt;fct&gt; high, high, high, high, high, high, high, high, high, hig…\n$ cylinders    &lt;dbl&gt; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, …\n$ displacement &lt;dbl&gt; 113.0, 97.0, 97.0, 110.0, 107.0, 104.0, 121.0, 97.0, 140.…\n$ horsepower   &lt;dbl&gt; 95, 88, 46, 87, 90, 95, 113, 88, 90, 95, 86, 90, 70, 76, …\n$ weight       &lt;dbl&gt; 2372, 2130, 1835, 2672, 2430, 2375, 2234, 2130, 2264, 222…\n$ acceleration &lt;dbl&gt; 15.0, 14.5, 20.5, 17.5, 14.5, 17.5, 12.5, 14.5, 15.5, 14.…\n$ year         &lt;dbl&gt; 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 7…\n$ origin       &lt;fct&gt; japanese, japanese, european, european, european, europea…\n\nsplits |&gt; \n  assessment() |&gt; \n  glimpse() |&gt; \n  write_csv(here::here(path_data, \"auto_val.csv\"))\n\nRows: 98\nColumns: 8\n$ mpg          &lt;fct&gt; low, low, low, low, low, low, low, low, low, low, low, lo…\n$ cylinders    &lt;dbl&gt; 8, 8, 8, 8, 8, 6, 6, 6, 6, 8, 8, 4, 4, 4, 8, 8, 8, 4, 8, …\n$ displacement &lt;dbl&gt; 350, 304, 302, 440, 455, 198, 200, 225, 250, 400, 318, 14…\n$ horsepower   &lt;dbl&gt; 165, 150, 140, 215, 225, 95, 85, 105, 100, 175, 150, 72, …\n$ weight       &lt;dbl&gt; 3693, 3433, 3449, 4312, 4425, 2833, 2587, 3439, 3329, 446…\n$ acceleration &lt;dbl&gt; 11.5, 12.0, 10.5, 8.5, 10.0, 15.5, 16.0, 15.5, 15.5, 11.5…\n$ year         &lt;dbl&gt; 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 72, 7…\n$ origin       &lt;fct&gt; american, american, american, american, american, america…\n\n\n\n\n\n\n\n\n\nQuestion: Any concerns about using this training-validation split?\n\n\n\n\n\n\n\nShow Answer\nThese sample sizes are starting to get a little small.  Fitted models will have \nhigher variance with only 75% (N = 294) observations and performance in validation \n(with only N = 98 observations) may not be a very precise estimate of true validation \nerror.  We will learn more robust methods in the unit on resampling.\n\n\n\n\n\n\n\n\n4.4.2 Modeling EDA\nLet’s do some quick modeling EDA to get a sense of the data.\n\nWe will keep it quick and dirty.\nFirst, we should problem make a function to class Cars since we may open it frequently\nEven though its simple, still better this way (e.g., what if we decide to change how to handle classing - will only need to make that change in one place!)\n\n\nclass_cars &lt;- function(d) { \n  d |&gt; \n    mutate(mpg = factor(mpg, levels = c(\"low\", \"high\")),\n           origin = factor (origin))\n}\n\n\n\nOpen train (we don’t need validate for modeling EDA)\n[We are pretending this is a new script….]\nClass the predictors\n\n\ndata_trn &lt;- read_csv(here::here(path_data, \"auto_trn.csv\"),\n                     col_type = cols()) |&gt; \n  class_cars() |&gt; \n  glimpse()\n\nRows: 294\nColumns: 8\n$ mpg          &lt;fct&gt; high, high, high, high, high, high, high, high, high, hig…\n$ cylinders    &lt;dbl&gt; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, …\n$ displacement &lt;dbl&gt; 113.0, 97.0, 97.0, 110.0, 107.0, 104.0, 121.0, 97.0, 140.…\n$ horsepower   &lt;dbl&gt; 95, 88, 46, 87, 90, 95, 113, 88, 90, 95, 86, 90, 70, 76, …\n$ weight       &lt;dbl&gt; 2372, 2130, 1835, 2672, 2430, 2375, 2234, 2130, 2264, 222…\n$ acceleration &lt;dbl&gt; 15.0, 14.5, 20.5, 17.5, 14.5, 17.5, 12.5, 14.5, 15.5, 14.…\n$ year         &lt;dbl&gt; 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 7…\n$ origin       &lt;fct&gt; japanese, japanese, european, european, european, europea…\n\n\n\n\nBar plot for outcome\n\nOutcome is balanced\nUnbalanced outcomes can be more complicated (more on this later)\n\n\n\ndata_trn |&gt; plot_bar(\"mpg\")\n\n\n\n\n\n\nGrouped (by mpg) box/violin plots for numeric predictors\n\n\ndata_trn |&gt; \n  select(where(is.numeric)) |&gt; \n  names() |&gt; \n  map(\\(name) plot_grouped_box_violin(df = data_trn, x = \"mpg\", y = name)) |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\n\n\nGrouped barplot for origin\n\n\ndata_trn |&gt; \n  plot_grouped_barplot_percent(x = \"origin\", y = \"mpg\")\n\n\n\n\n\ndata_trn |&gt; \n  plot_grouped_barplot_percent(x = \"mpg\", y = \"origin\")\n\n\n\n\n\n\nCorrelation plots for numeric\nCan dummy code categorical predictors to examine correlations (point biserial, phi) including them\nWe will do this manually using tidyverse here.\nSet american to be reference level (its the first level)\ncylinders, displacement, horsepower, and weight are all essentially the same construct (big, beefy car!)\nAll are strongly correlated with mpg\n\n\ndata_trn |&gt; \n1  mutate(mpg_high = if_else(mpg == \"high\", 1, 0),\n         origin_japan = if_else(origin == \"japanese\", 1, 0),\n         origin_europe = if_else(origin == \"european\", 1, 0)) |&gt; \n2  select(-origin, -mpg) |&gt;\n  cor() |&gt; \n  corrplot::corrplot.mixed() \n\n\n1\n\nIf manually coding a binary outcome variable, best practice is to set the positive class to be 1\n\n2\n\nRemove origin and mpg after converting to dummy-coded features"
  },
  {
    "objectID": "004_classification.html#logistic-regression---model-building",
    "href": "004_classification.html#logistic-regression---model-building",
    "title": "4  Introduction to Classification Models",
    "section": "4.5 Logistic Regression - Model Building",
    "text": "4.5 Logistic Regression - Model Building\nNow that we understand our data a little better, let’s build some models\n\nLet’s also try to simultaneously pretend that we:\n\nAre building and selecting a best prediction model that will be evaluated with some additional held out test data (how bad would it have been to split into three sets??!!)\nHave an explanatory question about production year - Are we more likely to have efficient cars more recently because of improvements in “technology”, above and beyond broad car characteristics (e.g., the easy stuff like weight, displacement, etc.)\n\n\n\nTo be clear, prediction and explanation goals are often separate (though prediction is an important foundation explanation)\n\nEither way, we need a validation set\n\nOpen it and class variables\n\n\ndata_val &lt;- read_csv(here::here(path_data, \"auto_val.csv\"),\n                     col_type = cols()) |&gt; \n  class_cars() |&gt; \n  glimpse()\n\nRows: 98\nColumns: 8\n$ mpg          &lt;fct&gt; low, low, low, low, low, low, low, low, low, low, low, lo…\n$ cylinders    &lt;dbl&gt; 8, 8, 8, 8, 8, 6, 6, 6, 6, 8, 8, 4, 4, 4, 8, 8, 8, 4, 8, …\n$ displacement &lt;dbl&gt; 350, 304, 302, 440, 455, 198, 200, 225, 250, 400, 318, 14…\n$ horsepower   &lt;dbl&gt; 165, 150, 140, 215, 225, 95, 85, 105, 100, 175, 150, 72, …\n$ weight       &lt;dbl&gt; 3693, 3433, 3449, 4312, 4425, 2833, 2587, 3439, 3329, 446…\n$ acceleration &lt;dbl&gt; 11.5, 12.0, 10.5, 8.5, 10.0, 15.5, 16.0, 15.5, 15.5, 11.5…\n$ year         &lt;dbl&gt; 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 72, 7…\n$ origin       &lt;fct&gt; american, american, american, american, american, america…\n\n\n\nLet’s predict high mpg from car beefiness and year\n\nWe likely want to combine the beefy variables into one construct/factor (beef)\n\nWe can use PCA to extract one factor\nInput variables should be centered and scaled for PCA. Easy peasy\nPCA will be calculated with data_trn during prep(). These statistics from data_trn will be used to bake()\n\n\n1rec &lt;- recipe(mpg ~ ., data = data_trn) |&gt;\n  step_pca(cylinders, displacement, horsepower, weight, \n           options = list(center = TRUE, scale. = TRUE), \n           num_comp = 1, \n2           prefix = \"beef_\")\n\n\n1\n\nUsing . now in the recipe to leave all variables in the feature matrix. We can later select the ones we want use for prediction\n\n2\n\nWe will have one PCA component, it will be called beef_1\n\n\n\n\n\nNow, prep() the recipe and bake() some feature for training and validation sets\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nLets skim our training features\nWe can see there are features in there we won’t use\nmpg, year, and beef_1 look good\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n294\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n2\n\n\nnumeric\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nn_unique\ntop_counts\n\n\n\n\norigin\n0\n1\n3\name: 187, jap: 56, eur: 51\n\n\nmpg\n0\n1\n2\nlow: 147, hig: 147\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\nacceleration\n0\n1\n15.54\n2.64\n8.00\n14.00\n15.50\n17.0\n24.80\n0.24\n0.58\n\n\nyear\n0\n1\n75.94\n3.68\n70.00\n73.00\n76.00\n79.0\n82.00\n0.03\n-1.17\n\n\nbeef_1\n0\n1\n0.00\n1.92\n-2.36\n-1.64\n-0.85\n1.4\n4.36\n0.63\n-0.96\n\n\n\n\n\n\n\nFit the model configuration in train\n\n\nfit_lr_2 &lt;- \n1  logistic_reg() |&gt;\n2  set_engine(\"glm\") |&gt;\n3  fit(mpg ~ beef_1 + year, data = feat_trn)\n\n\n1\n\ncategory of algorithm is logistic regression\n\n2\n\nSet engine to be generalized linear model. No need to `set_mode(“classification”) because logistic regression glm is only used for classification\n\n3\n\nNotice that we explicitly indicate which features to use because our feature matrix has more than just these two in it because we used . in our recipe and our datasets have more columns.\n\n\n\n\n\nLet’s look at the logistic model and its parameter estimates from train\n\nfit_lr_2 |&gt; tidy()\n\n# A tibble: 3 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)  -23.4      5.55       -4.23 2.38e- 5\n2 beef_1        -2.49     0.316      -7.87 3.49e-15\n3 year           0.292    0.0718      4.07 4.71e- 5\n\n\n\n\n\n\\(Pr(high|(beef, year)) = \\frac{e^{b0 + b1*beef + b2*year}}{1 + e^{b0 + b1*beef + b2*year}}\\)\n\nUse predict() to get \\(Pr(high|year)\\) (or predicted class, more on that later) directly from the model for any data\n\nFirst make a dataframe for feature values for prediction\nWe will use this for a plot\nGet probabilities for a range of years (incrementing by .1 year)\nHold beef constant at its mean\n\n\np_high &lt;- \n  tibble(year = seq(min(feat_val$year), max(feat_val$year), .1),\n         beef_1 = mean(feat_val$beef_1)) \n\n\npredict() will:\n\nGive us probabilities for high and low (type = \"prob\"). We will select out the low columns\nAlso provides the 95% conf int around these probabilities (type = \"conf_int\")\nAmbiguity is removed by their choice to label by the actual outcome labels (Nice!)\nWe will bind these predictions to the dataframe we made above\n\n\np_high &lt;- p_high |&gt; \n  bind_cols(predict(fit_lr_2, new_data = p_high, type = \"prob\")) |&gt; \n  bind_cols(predict(fit_lr_2, new_data = p_high, type = \"conf_int\")) |&gt; \n  select(-.pred_low, -.pred_lower_low, -.pred_upper_low) |&gt; \n  glimpse()\n\nRows: 121\nColumns: 5\n$ year             &lt;dbl&gt; 70.0, 70.1, 70.2, 70.3, 70.4, 70.5, 70.6, 70.7, 70.8,…\n$ beef_1           &lt;dbl&gt; 0.008438869, 0.008438869, 0.008438869, 0.008438869, 0…\n$ .pred_high       &lt;dbl&gt; 0.04733721, 0.04867270, 0.05004389, 0.05145161, 0.052…\n$ .pred_lower_high &lt;dbl&gt; 0.01495325, 0.01557265, 0.01621651, 0.01688572, 0.017…\n$ .pred_upper_high &lt;dbl&gt; 0.1398943, 0.1419807, 0.1440989, 0.1462495, 0.1484331…\n\n\n\nHere is a quick look at the head\n\np_high |&gt; head()\n\n# A tibble: 6 × 5\n   year  beef_1 .pred_high .pred_lower_high .pred_upper_high\n  &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;\n1  70   0.00844     0.0473           0.0150            0.140\n2  70.1 0.00844     0.0487           0.0156            0.142\n3  70.2 0.00844     0.0500           0.0162            0.144\n4  70.3 0.00844     0.0515           0.0169            0.146\n5  70.4 0.00844     0.0529           0.0176            0.148\n6  70.5 0.00844     0.0544           0.0183            0.151\n\n\n\nCan plot this relationship using the predicted probabilities\n\nplot both prediction line\nand observed Y (with a little jitter)\n\n\nggplot() +\n  geom_point(data = feat_val, aes(x = year, y = 2 - as.numeric(mpg)), \n             position = position_jitter(height = 0.05, width = 0.05)) +\n  geom_line(data = p_high, mapping = aes(x = year, y = .pred_high)) +\n  geom_ribbon(data = p_high, \n              aes(x = year, ymin = .pred_lower_high, ymax = .pred_upper_high), \n              linetype = 2, alpha = 0.1) +\n  scale_x_continuous(name = \"Production Year (19XX)\", breaks = seq(70,82,2)) +\n  ylab(\"Pr(High MPG)\")\n\n\n\n\n\nCan plot odds instead of probabilities using odds equation and coefficients from the model\n\n\\(odds = \\frac{Pr(positive\\:class|x_1)} {1 - Pr(positive\\:class|x_1)}\\)\n\n\np_high &lt;- p_high |&gt; \n  mutate(.odds_high = .pred_high / (1 - .pred_high),\n         .odds_lower_high = .pred_lower_high / (1 - .pred_lower_high),\n         .odds_upper_high = .pred_upper_high / (1 - .pred_upper_high))\n\n\n\nNOTE: Harder to also plot raw data as scatter plot when plotting odds vs. probabilities. Maybe use second Y axis?\n\n\np_high |&gt; \n  ggplot() +\n    geom_line(mapping = aes(x = year, y = .odds_high)) +\n    geom_ribbon(aes(x = year, ymin = .odds_lower_high, ymax = .odds_upper_high), \n                linetype = 2, alpha = 0.1) +\n    scale_x_continuous(name = \"Production Year (19XX)\", breaks = seq(70, 82, 2)) +\n    ylab(\"Odds(High MPG)\")\n\n\n\n\n\nOdds ratio for year:\n\n\\(Odds\\:ratio = e^{c*\\beta_1}\\)\n\n\n\nGet the parameter estimate/coefficient from the model\n\nFor every one year increase (holding beef constant), the odds of a car being categorized as high mpg increase by a factor of 1.3394301\n\n\nexp(get_estimate(fit_lr_2, \"year\"))\n\n[1] 1.33943\n\n\n\nYou can do this for other values of c as well (not really needed here because a 1 year unit makes sense)\n\n\\(Odds\\:ratio = e^{c*\\beta_1}\\)\nFor every 10 year increase (holding beef constant), the odds of a car being categorized as high mpg increase by a factor of 18.5866278\n\n\nexp(10 * get_estimate(fit_lr_2, \"year\"))\n\n[1] 18.58663\n\n\n\nTesting parameter estimates\n\ntidy() provides z-tests for the parameter estimates\nThis is NOT the recommended statistical test from 610\n\n\nfit_lr_2 |&gt; tidy()\n\n# A tibble: 3 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)  -23.4      5.55       -4.23 2.38e- 5\n2 beef_1        -2.49     0.316      -7.87 3.49e-15\n3 year           0.292    0.0718      4.07 4.71e- 5\n\n\n\nThe preferred test for parameter estimates from logistic regression is the likelihood ratio test\n\nYou can get this using Anova() from the car package (as you learn in 610/710)\nThe glm object is returned using $fit\n\n\ncar::Anova(fit_lr_2$fit, type = 3)\n\nAnalysis of Deviance Table (Type III tests)\n\nResponse: mpg\n       LR Chisq Df Pr(&gt;Chisq)    \nbeef_1  239.721  1  &lt; 2.2e-16 ***\nyear     20.317  1  6.562e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nAccuracy is a very common performance metric for classification models\n\nHow accurate is our two feature model?\n\nNote the use of type = \"class\"\n\n\n\nWe can calculate accuracy in the training set. This may be somewhat overfit and optimistic!\n\naccuracy_vec(feat_trn$mpg, predict(fit_lr_2, feat_trn, type = \"class\")$.pred_class)\n\n[1] 0.9217687\n\n\n\nAnd in the validation set (better estimate of performance in new data. Though if we use this set multiple times to select a best configuration, it will become overfit eventually too!)\n\naccuracy_vec(feat_val$mpg, predict(fit_lr_2, feat_val, type = \"class\")$.pred_class)\n\n[1] 0.8877551\n\n\n\n\nYou can see some evidence of over-fitting to the training set in that model performance is a bit lower in validation\n\nLet’s take a look at the decision boundary for this model in the validation set\n\nWe need a function to plot the decision boundary because we will use it repeatedly to compare decision boundaries across statistical models\n\nDisplayed here as another example of a function that uses quoted variable names\nThis function is useful for book examples with two features.\n\nOnly can be used with two features, so not that useful in real life!\nNot included in my function scripts (just here to helpy you understand the material)\n\n\nplot_decision_boundary &lt;- function(data, model, x_names, y_name, n_points = 100) {\n  \n  preds &lt;- crossing(X1 = seq(min(data[[x_names[1]]]), \n                                 max(data[[x_names[1]]]), \n                                 length = n_points),\n                   X2 = seq(min(data[[x_names[2]]]), \n                                 max(data[[x_names[2]]]), \n                                 length = n_points))\n  names(preds) &lt;- x_names\n  preds[[y_name]] &lt;- predict(model, preds)$.pred_class\n  preds[[y_name]] &lt;- as.numeric(preds[[y_name]])-1\n  \n  ggplot(data = data, \n         aes(x = .data[[x_names[1]]], \n             y = .data[[x_names[2]]], \n             color = .data[[y_name]])) +\n    geom_contour(data = preds, \n                 aes(x = .data[[x_names[1]]], \n                     y = .data[[x_names[2]]], \n                     z = .data[[y_name]]), \n                 color = \"black\", breaks = .5, linewidth = 2) +\n    geom_point(size = 2, alpha = .5) +\n    labs(x = x_names[1], y = x_names[2], color = y_name)\n}\n\n\nLogistic regression produces a linear decision boundary when you consider a scatter plot of the points by the two features.\n\nPoints on one side of the line are assigned to one class and points on the other side of the line are assigned to the other class.\n\nThis decision boundary would be a plane if there were three features Harder to visualize in higher dimensional space.\nWe will contrast this decision boundary from logistic regression with other statistical algorithms in a bit.\n\n\n\nHere is the decision boundary for this model in both train and validation sets\n\np_train &lt;- feat_trn |&gt; \n  plot_decision_boundary(fit_lr_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\", n_points = 400)\n\np_val &lt;- feat_val |&gt; \n  plot_decision_boundary(fit_lr_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\", n_points = 400)\n\ncowplot::plot_grid(p_train, p_val, labels = list(\"Train\", \"Validation\"), hjust = -1.5)\n\n\n\n\n\nWhat if you wanted to try to improve our predictions?\n\nYou could find the best set of covariates to test the effect of year. [Assuming the best covariates are those that account for the most variance in mpg]?\nFor either prediction or explanation, you need to find this best model\n\n\n\nWe can compare model performance in validation set to find this best model\n\nWe can use that one for our prediction goal\nWe can test the effect of year in that model for our explanation goal\n\nThis is a principled way to decide on the best model for our explanatory goal (vs. p-hacking)\nWe get to explore and we end up with the best model to provide our focal test\n\n\n\nLet’s quickly fit another model we might have considered.\n\nThis model will contain the 4 variables from our PCA but as individual features rather than one PCA component score (beef)\nMake features for this model\n\nNo feature engineering needed because raw variables are all numeric already)\nWe will give the features dfs new names to retain the old features that included beef_1\n\n\n\nrec_raw &lt;- recipe(mpg ~ ., data = data_trn) \n\nrec_raw_prep &lt;- rec_raw |&gt; \n  prep(data_trn)\n\nfeat_raw_trn &lt;- rec_raw_prep |&gt; \n  bake(data_trn)\n\nfeat_raw_val &lt;- rec_raw_prep |&gt; \n  bake(data_val)\n\n\nFit PCA features individually + year\n\nfit_lr_raw &lt;- \n  logistic_reg() |&gt; \n  set_engine(\"glm\") |&gt; \n  fit(mpg ~ cylinders + displacement + horsepower + weight + year, \n      data = feat_raw_trn)\n\n\nWhich is the best prediction model?\n\nBeef PCA\n\n\naccuracy_vec(feat_val$mpg, predict(fit_lr_2, feat_val)$.pred_class)\n\n[1] 0.8877551\n\n\n\nIndividual raw features from PCA\n\n\naccuracy_vec(feat_raw_val$mpg, predict(fit_lr_raw, feat_raw_val)$.pred_class)\n\n[1] 0.8673469\n\n\n\n\nThe PCA beef model fits best. The model with individual features likely increases overfitting a bit but doesn’t yield a reduction in bias because all the other variables are so highly correlated.\n\nfit_lr_2 is your choice for best model for prediction (at least it is descriptively better)\n\nIf you had an explanatory question about year, how would you have chosen between these two tests of year in these two different but all reasonable models\n\nYou might have chose the model with individual features because the effect of year is stronger.\n\nThat is NOT the model that comes closes to the DGP.\n\nWe believe the appropriate model is the beef model that has higher overall accuracy!\nThis is a start for us to start to consider the use of resampling methods to make decisions about how to best pursue explanatory goals.\nCould you now test your year effect in the full sample? Let’s discuss.\n\n\ncar::Anova(fit_lr_2$fit, type = 3)\n\nAnalysis of Deviance Table (Type III tests)\n\nResponse: mpg\n       LR Chisq Df Pr(&gt;Chisq)    \nbeef_1  239.721  1  &lt; 2.2e-16 ***\nyear     20.317  1  6.562e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\ncar::Anova(fit_lr_raw$fit, type = 3)\n\nAnalysis of Deviance Table (Type III tests)\n\nResponse: mpg\n             LR Chisq Df Pr(&gt;Chisq)    \ncylinders      0.4199  1    0.51697    \ndisplacement   1.3239  1    0.24990    \nhorsepower     6.4414  1    0.01115 *  \nweight        15.6669  1  7.553e-05 ***\nyear          27.0895  1  1.942e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "004_classification.html#k-nearest-neighbors---a-conceptual-overview",
    "href": "004_classification.html#k-nearest-neighbors---a-conceptual-overview",
    "title": "4  Introduction to Classification Models",
    "section": "4.6 K Nearest Neighbors - A Conceptual Overview",
    "text": "4.6 K Nearest Neighbors - A Conceptual Overview\nLet’s switch gears to a non-parametric method we already know - KNN.\n\nKNN can be used as a classifier as well as for regression problems\nKNN tries to determine conditional class possibilities for any set of features by looking at observed classes for similar values of for these features in the training set\n\n\nThis figure illustrates the application of 3-NN to a small sample training set (N = 12) with 2 predictors\n\nFor test observation X in the left panel, we would predict class = blue because blue is the majority class (highest probability) among the 3 nearest training observations\nIf we calculated these probabilities for all possible combinations of the two predictors in the training set, it would yield the decision boundaries depicted in the right panel\n\n\n\nKNN can produce complex decision boundaries\n\nThis makes it flexible (can reduce bias)\nThis makes it susceptible to variance/overfitting problems\n\n\n\nRemember that we can control this bias-variance trade-off with K.\n\nAs K increases, variance reduces (but bias may increase).\n\nAs K decreases, bias may be reduced but variance increases.\nChoose a K that produces good performance in new (validation) data\n\n\nThese figures depict the KNN (and Bayes classifier) decision boundaries for the earlier simulated 2 class problem with X1 and X2\n\nK = 10 appears to provide the sweet spot b/c it closely approximates the Bayes decision boundary\nOf course, you wouldn’t know the true Bayes decision boundary if the data were real (not simulated)\nBut K = 10 would also yield the lowest test error (which is how it should be chosen)\n\nBayes classifier test error: .1304\nK = 10 test error: 1363\nK = 1 test error: .1695\nK = 100 test err: .1925\n\n\n\n\n\nYou can NOT make the decision about K based on training error\n\nThis figure depicts training and test error for simulated data example as function of 1/K\n\nTraining error decreases as 1/K increases. At 1 (K=1) training error is 0\nTest error shows expected inverted U\n\nFor high K (left side), error is high because of high variance\nAs move right (lower K), variance is reduced rapidly with little increase in bias. Error is reduced.\nEventually, there is diminishing return from reducing variance but bias starts to increase rapidly. Error increases again."
  },
  {
    "objectID": "004_classification.html#a-return-to-cars---now-with-knn",
    "href": "004_classification.html#a-return-to-cars---now-with-knn",
    "title": "4  Introduction to Classification Models",
    "section": "4.7 A Return to Cars - Now with KNN",
    "text": "4.7 A Return to Cars - Now with KNN\nLet’s demonstrate KNN using the Cars dataset\n\nCalculate beef_1 PCA component\nScale both features\nMake train and validation feature matrices\n\n\nrec &lt;- recipe(mpg ~ ., data = data_trn) |&gt; \n  step_pca(cylinders, displacement, horsepower, weight,\n           options = list(center = TRUE, scale. = TRUE), \n           num_comp = 1, prefix = \"beef_\") |&gt; \n  step_scale(year, beef_1)\n\nrec_prep &lt;- rec |&gt; \n  prep(data = data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\nFit models with varying K.\n\nK = 1\n\n\nfit_1nn_2 &lt;- \n  nearest_neighbor(neighbors = 1) |&gt; \n  set_engine(\"kknn\") |&gt;\n1  set_mode(\"classification\") |&gt;\n  fit(mpg ~ beef_1 + year, data = feat_trn)\n\n\n1\n\nNotice that we now use set_mode(\"classification\")\n\n\n\n\n\nK = 5\n\n\nfit_5nn_2 &lt;- \n  nearest_neighbor(neighbors = 5) |&gt; \n  set_engine(\"kknn\") |&gt; \n  set_mode(\"classification\") |&gt;   \n  fit(mpg ~ beef_1 + year, data = feat_trn)\n\n\nK = 10\n\n\nfit_10nn_2 &lt;- \n  nearest_neighbor(neighbors = 10) |&gt; \n  set_engine(\"kknn\") |&gt; \n  set_mode(\"classification\") |&gt;   \n  fit(mpg ~ beef_1 + year, data = feat_trn)\n\n\nK = 20\n\n\nfit_20nn_2 &lt;- \n  nearest_neighbor(neighbors = 20) |&gt; \n  set_engine(\"kknn\") |&gt; \n  set_mode(\"classification\") |&gt;   \n  fit(mpg ~ beef_1 + year, data = feat_trn)\n\n\nOf course, training accuracy goes down with decreasing flexibility as k increases\n\nK = 1\n\n\naccuracy_vec(feat_trn$mpg, predict(fit_1nn_2, feat_trn)$.pred_class)\n\n\nK = 5\n\n\naccuracy_vec(feat_trn$mpg, predict(fit_5nn_2, feat_trn)$.pred_class)\n\n[1] 0.9489796\n\n\n\nK = 10\n\n\naccuracy_vec(feat_trn$mpg, predict(fit_10nn_2, feat_trn)$.pred_class)\n\n[1] 0.9455782\n\n\n\nK = 20\n\n\naccuracy_vec(feat_trn$mpg, predict(fit_20nn_2, feat_trn)$.pred_class)\n\n[1] 0.9285714\n\n\n\nIn contrast, validation accuracy first increases and then eventually decreases as k increase.\n\nK = 1\n\n\naccuracy_vec(feat_val$mpg, predict(fit_1nn_2, feat_val)$.pred_class)\n\n[1] 0.8163265\n\n\n\nK = 5\n\n\naccuracy_vec(feat_val$mpg, predict(fit_5nn_2, feat_val)$.pred_class)\n\n[1] 0.877551\n\n\n\nK = 10 (preferred based on validation accuracy)\n\n\naccuracy_vec(feat_val$mpg, predict(fit_10nn_2, feat_val)$.pred_class)\n\n[1] 0.8877551\n\n\n\nK = 20\n\n\naccuracy_vec(feat_val$mpg, predict(fit_20nn_2, feat_val)$.pred_class)\n\n[1] 0.8673469\n\n\n\nLet’s look at the decision boundaries for 10-NN in training and validation sets\n\nA very complex decision boundary\nClearly trying hard to segregate the points\nIn Ames, the relationships were non-linear and therefore KNN did much better than the linear model\nHere, the decision boundary is pretty linear so the added flexibility of KNN doesn’t get us much.\n\nMaybe we gain a little in bias reduction but lose a little in overfitting\nEnds up performing comparable to logistic regression (a generalized linear model)\n\n\n\np_train &lt;- feat_trn |&gt; \n  plot_decision_boundary(fit_10nn_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\")\n\np_val &lt;- feat_val |&gt; \n  plot_decision_boundary(fit_10nn_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\")\n\ncowplot::plot_grid(p_train, p_val, labels = list(\"Train\", \"Validation\"), hjust = -1.5)\n\n\n\n\n\n\n\n\n\n\n\nQuestion: How do you think the parametric logistic regression compares to the non-parametric KNN with respect to explanatory goals? Consider our (somewhat artificial) question about the effect of year.\n\n\n\n\n\n\n\nShow Answer\nThe logistic regression provides coefficients (parameter estimates) that can be \nused to describe changes in probability, odds and odds ratio associated with \nchange in year.  These parameter estimates can be tested via inferential procedures.  \nKNN does not provide any parameter estimates.  With KNN, we can visualize decision boundary \n(only in 2 or three dimensions) or the predicted outcome by any feature, controlling for \nother features but these relationships may be complex in shape.  \nOf course, if the relationships are complex, we might not want to hide that.  \nWe will learn more about feature importance for explanation in a later unit.\n\n\n\n\n\n\nPlot of probability of high_mpg by year, holding beef_1 constant at its mean based on 10-NN\n\nGet \\(Pr(high|year)\\) holding beef constant at its mean\npredict() returns probabilities for high and low.\n\n\np_high &lt;- \n  tibble(year = seq(min(feat_val$year), max(feat_val$year), .1),\n         beef_1 = mean(feat_val$beef_1)) \n\np_high &lt;- p_high |&gt; \n  bind_cols(predict(fit_10nn_2, p_high, type = \"prob\")) |&gt; \n  glimpse()\n\nRows: 33\nColumns: 4\n$ year       &lt;dbl&gt; 18.99759, 19.09759, 19.19759, 19.29759, 19.39759, 19.49759,…\n$ beef_1     &lt;dbl&gt; 0.004400185, 0.004400185, 0.004400185, 0.004400185, 0.00440…\n$ .pred_low  &lt;dbl&gt; 0.96, 0.99, 0.99, 0.99, 0.97, 0.87, 0.81, 0.81, 0.81, 0.81,…\n$ .pred_high &lt;dbl&gt; 0.04, 0.01, 0.01, 0.01, 0.03, 0.13, 0.19, 0.19, 0.19, 0.19,…\n\n\n\n\nPlot it\nIn a later unit, we will learn about feature ablation that we can combine with model comparisons to potentially test predictor effects in non-parametric models\n\n\nggplot() +\n  geom_point(data = feat_val, aes(x = year, y = 2 - as.numeric(mpg)), \n             position = position_jitter(height = 0.05, width = 0.05)) +\n  geom_line(data = p_high, mapping = aes(x = year, y = .pred_high)) +\n  scale_x_continuous(name = \"Production Year (19XX)\", \n                     breaks = seq(0, 1, length.out = 7), \n                     labels = as.character(seq(70, 82, length.out = 7))) +\n  ylab(\"Pr(High MPG)\")"
  },
  {
    "objectID": "004_classification.html#linear-discriminant-analysis",
    "href": "004_classification.html#linear-discriminant-analysis",
    "title": "4  Introduction to Classification Models",
    "section": "4.8 Linear Discriminant Analysis",
    "text": "4.8 Linear Discriminant Analysis\nLDA models the distributions of the Xs separately for each class\n\nThen uses Bayes theorem to estimate \\(Pr(Y = k | X)\\) for each k and assigns the observation to the class with the highest probability\n\\(Pr(Y = k|X) = \\frac{\\pi_k * f_k(X)}{\\sum_{l = 1}^{K} f_l(X)}\\)\nwhere\n\n\\(\\pi_k\\) is the prior probability that an observation comes from class k (estimated from frequencies of k in training)\n\\(f_k(X)\\) is the density function of X for an observation from class k\n\n\\(f_k(X)\\) is large if there is a high probability that an observation in class k has that set of values for X and small if that probability is low\n\\(f_k(X)\\) is difficult to estimate unless we make some simplifying assumptions (i.e., X is multivariate normal and common covariance matrix (\\(\\sum\\)) across K classes)\nWith these assumptions, we can estimate \\(\\pi_k\\), \\(\\mu_k\\), and \\(\\sigma^2\\) from the training set and calculate \\(Pr(Y = k|X)\\) for each k\n\n\n\nWith a single feature, the probability of any class k, given X is:\n\n\\(Pr(Y = k|X) = \\frac{\\pi_k \\frac{1}{\\sqrt{2\\pi\\sigma}}\\exp(-\\frac{1}{2\\sigma^2}(x-\\mu_k)^2)}{\\sum_{l=1}^{K}\\pi_l\\frac{1}{2\\sigma^2}\\exp(-\\frac{1}{2\\sigma^2}(x-\\mu_l)^2)}\\)\nLDA is a parametric model, but is it interpretable?\n\n\nApplication of LDA to Cars data set with two predictors\n\nNotice that LDA produces linear decision boundary (see James et al. (2023) for formula for discriminant function derived from the probability function on last slide)\n\nrec &lt;- recipe(mpg ~ ., data = data_trn) |&gt; \n  step_pca(cylinders, displacement, horsepower, weight, \n           options = list(center = TRUE, scale. = TRUE), \n           num_comp = 1, \n           prefix = \"beef_\")\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\n\nNeed to load the discrm package\nLets look at how the function is called\n\n\nlibrary(discrim, exclude = \"smoothness\")\n\ndiscrim_linear() |&gt; \n  set_engine(\"MASS\") |&gt; \n  translate()\n\nLinear Discriminant Model Specification (classification)\n\nComputational engine: MASS \n\nModel fit template:\nMASS::lda(formula = missing_arg(), data = missing_arg())\n\n\n\nFit the LDA in train\n\nfit_lda_2 &lt;- \n  discrim_linear() |&gt; \n  set_engine(\"MASS\") |&gt; \n  fit(mpg ~ beef_1 + year, data = feat_trn)\n\n\nAccuracy and decision boundary\n\naccuracy_vec(feat_val$mpg, predict(fit_lda_2, feat_val)$.pred_class)\n\n[1] 0.8469388\n\n\n\np_train &lt;- feat_trn |&gt; \n  plot_decision_boundary(fit_lda_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\", n_points = 400)\n\np_val &lt;- feat_val |&gt; \n  plot_decision_boundary(fit_lda_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\", n_points = 400)\n\ncowplot::plot_grid(p_train, p_val, labels = list(\"Train\", \"Validation\"), hjust = -1.5)"
  },
  {
    "objectID": "004_classification.html#quadratic-discriminant-analysis",
    "href": "004_classification.html#quadratic-discriminant-analysis",
    "title": "4  Introduction to Classification Models",
    "section": "4.9 Quadratic Discriminant Analysis",
    "text": "4.9 Quadratic Discriminant Analysis\nQDA relaxes one restrictive assumption of LDA\n\nStill required multivariate normal X\nBut it allows each class to have its own \\(\\sum\\)\nThis makes it:\n\nMore flexible\nAble to model non-linear decision boundaries (see formula for discriminant in James et al. (2023))\nBut requires substantial increase in parameter estimation (more potential to overfit)\n\n\n\nApplication of RDA (Regularized Discriminant Analysis) algorithm to Car data set with two features\n\nThe algorithm that is available in tidymodels is actually a regularized discriminant analysis, rda() from the klaR package\nThere are two hyperparameters, frac_common_cov and frac_identity, that can each vary between 0 - 1\n\nWhen frac_common_cov = 1 and frac_identity = 0, this is an LDA\nWhen frac_common_cov = 0 and frac_identity = 0, this is a QDA\nThese hyperparameters can be tuned to different values to improve the fit dependent on the true DGP\nMore on hyperparameter tuning in unit 5\nThis is a flexible algorithm that likely replaces the need to fit separate LDA and QDA models\n\nsee https://discrim.tidymodels.org/reference/discrim_regularized.html\n\n\nHere is a true QDA using frac_common_cov = 1 and frac_identity = 0\n\ndiscrim_regularized(frac_common_cov = 0, frac_identity = 0) |&gt; \n  set_engine(\"klaR\") |&gt; \n  translate()\n\nRegularized Discriminant Model Specification (classification)\n\nMain Arguments:\n  frac_common_cov = 0\n  frac_identity = 0\n\nComputational engine: klaR \n\nModel fit template:\nklaR::rda(formula = missing_arg(), data = missing_arg(), lambda = 0, \n    gamma = 0)\n\n\n\n\nNow fit it\n\n\nfit_qda_2 &lt;- \n  discrim_regularized(frac_common_cov = 0, frac_identity = 0) |&gt; \n  set_engine(\"klaR\") |&gt; \n  fit(mpg ~ beef_1 + year, data = feat_trn)\n\n\nAccuracy and decision boundary\n\naccuracy_vec(feat_val$mpg, \n             predict(fit_qda_2, feat_val)$.pred_class)\n\n[1] 0.877551\n\n\n\np_train &lt;- feat_trn |&gt; \n  plot_decision_boundary(fit_qda_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\", n_points = 400)\n\np_val &lt;- feat_val |&gt; \n  plot_decision_boundary(fit_qda_2, x_names = c(\"year\", \"beef_1\"), y_name = \"mpg\", n_points = 400)\n\ncowplot::plot_grid(p_train, p_val, labels = list(\"Train\", \"Validation\"), hjust = -1.5)"
  },
  {
    "objectID": "004_classification.html#comparisons-between-these-four-classifiers",
    "href": "004_classification.html#comparisons-between-these-four-classifiers",
    "title": "4  Introduction to Classification Models",
    "section": "4.10 Comparisons between these four classifiers",
    "text": "4.10 Comparisons between these four classifiers\n\nBoth logistic and LDA are linear functions of X and therefore produce linear decision boundaries\nLDA makes additional assumptions about X (multivariate normal and common \\(\\sum\\)) beyond logistic regression. Relative performance is based on the quality of this assumption\nQDA relaxes the LDA assumption about common \\(\\sum\\) (and RDA can relax it partially)\n\nThis also allows for nonlinear decision boundaries\nQDA is therefore more flexible, which means possibly less bias but more potential for overfitting\n\nBoth QDA and LDA assume multivariate normal X so may not accommodate categorical predictors very well. Logistic and KNN do accommodate categorical predictors\nKNN is non-parametric and therefore the most flexible\n\nIncreased overfitting, decreased bias?\nNot very interpretable. But LDA/QDA, although parametric, aren’t as interpretable as logistic regression\n\nLogistic regression fails when classes are perfectly separated (but does that ever happen?) and is less stable when classes are well separated\nLDA, KNN, and QDA naturally accommodate more than two classes\n\nLogistic requires additional tweak (Briefly describe: multiple one vs other classes models approach)\n\nLogisitic regression requires relatively large sample sizes. LDA/QDA may perform better with smaller sample sizes if X is multivariate normal."
  },
  {
    "objectID": "004_classification.html#a-quick-tour-of-many-classifiers",
    "href": "004_classification.html#a-quick-tour-of-many-classifiers",
    "title": "4  Introduction to Classification Models",
    "section": "4.11 A quick tour of many classifiers",
    "text": "4.11 A quick tour of many classifiers\nThe Cars dataset had strong predictors and a mostly linear decision boundary for the two predictors we considered\n\nThis will not be true in many cases\nLet’s consider a more complex two predictor decision boundary in the circle dataset from the mlbench package (lots of cool datasets for ML)\nThis will hopefully demonstrate that the key is to have a algorithm that can model the DGP\nThere is NO best algorithm\nThe best algorithm depends on\n\nThe DGP\nThe goal (prediction vs. explanation)\n\n\n\nThis will also demonstrate the power of tidymodels to allow us to fit many different statistical algorithms which all have their own syntax using a common syntax provided by tidymodels.\n\nThis example has been adapted to tidymodels from a demonstration by Michael Hahsler\nSimulate train and test data\n\n\nlibrary(mlbench, include.only = \"mlbench.circle\")\n\nset.seed(20140102)\ndata_trn &lt;- as_tibble(mlbench.circle(200)) |&gt; \n  rename(x_1 = x.1, x_2 = x.2) |&gt; \n  glimpse()\n\nRows: 200\nColumns: 3\n$ x_1     &lt;dbl&gt; -0.514721263, 0.763312056, 0.312073042, 0.162981535, -0.320294…\n$ x_2     &lt;dbl&gt; 0.47513532, 0.65803777, -0.89824011, 0.38680494, -0.47313964, …\n$ classes &lt;fct&gt; 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2,…\n\ntest &lt;- as_tibble(mlbench.circle(200)) |&gt; \n  rename(x_1 = x.1, x_2 = x.2)\n\n\n\nPlot train data\n\n\ndata_trn |&gt; ggplot(aes(x = x_1, y = x_2, color = classes)) +\n  geom_point(size = 2, alpha = .5)\n\n\n\n\n\n\n4.11.1 Logistic Regression\n\nFit\n\n\nfit_lr_bench &lt;- \n  logistic_reg() |&gt; \n  set_engine(\"glm\") |&gt; \n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\n\n\naccuracy_vec(test$classes, \n             predict(fit_lr_bench, test)$.pred_class)\n\n[1] 0.62\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_lr_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_lr_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.2 KNN with K = 5 (somewhat arbitrary default)\n\nFit\nNote same syntax as logistic regression (and for all others!)\n\n\nfit_knn_bench &lt;- \n  nearest_neighbor() |&gt; \n  set_engine(\"kknn\") |&gt; \n  set_mode(\"classification\") |&gt; \n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\nNote same syntax as logistic regression (and for all others!)\nSee what KNN can do relative to LR when the boundaries are non-linear!\n\n\naccuracy_vec(test$classes, \n             predict(fit_knn_bench, test)$.pred_class)\n\n[1] 0.985\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_knn_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) + \n  coord_obs_pred()\n  \np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_knn_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n  \ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.3 Linear Discriminant Analysis\n\nFit\n\n\nfit_lda_bench &lt;- \n  discrim_linear() |&gt; \n  set_engine(\"MASS\") |&gt; \n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\n\n\naccuracy_vec(test$classes, \n             predict(fit_lda_bench, test)$.pred_class)\n\n[1] 0.62\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_lda_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_lda_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.4 Regularized Discrinant Analysis\n\nFit\nLetting rda() select optimal hyperparameter values\n\n\nfit_rda_bench &lt;- \n  discrim_regularized() |&gt; \n  set_engine(\"klaR\") |&gt;\n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\nLess overfitting?\n\n\naccuracy_vec(test$classes, \n             predict(fit_rda_bench, test)$.pred_class)\n\n[1] 0.985\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_rda_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) + \n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_rda_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) + \n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.5 Naive Bayes Classifier\nThe Naïve Bayes classifier is a simple probabilistic classifier which is based on Bayes theorem\n\nBut, we assume that the predictor variables are conditionally independent of one another given the response value\nThis algorithm can be fit with either klaR or naivebayes engines\nThere are many tutorials available on this classifier\nFit it\n\n\nfit_bayes_bench &lt;- \n  naive_Bayes() |&gt; \n  set_engine(\"naivebayes\") |&gt;\n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\n\n\naccuracy_vec(test$classes, \n             predict(fit_bayes_bench, test)$.pred_class)\n\n[1] 0.99\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_bayes_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_bayes_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.6 Random Forest\nRandom Forest is a variant of decision trees\n\nIt uses bagging which involves resampling the data to produce many trees and then aggregating across trees for the final classification\nWe will discuss Random Forest in a later unit\nHere we fit it with defaults for its hyperparameters\nFit it\n\n\nfit_rf_bench &lt;- \n  rand_forest() |&gt; \n  set_engine(\"ranger\") |&gt; \n  set_mode(\"classification\") |&gt; \n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\n\n\naccuracy_vec(test$classes, \n             predict(fit_rf_bench, test)$.pred_class)\n\n[1] 0.985\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_rf_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_rf_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.7 Neural networks\nIt is easy to fit a single layer neural network\n\nWe do this below with varying number of hidden units and all other hyperparameters set to defaults\nWe will have a unit on this later in the semester\n\n\n\n4.11.7.1 Single Layer NN with 1 hidden unit:\n\nFit\n\n\nfit_nn1_bench &lt;- \n mlp(hidden_units = 1) |&gt; \n  set_engine(\"nnet\") |&gt; \n  set_mode(\"classification\") |&gt; \n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\n\n\naccuracy_vec(test$classes, \n             predict(fit_nn1_bench, test)$.pred_class)\n\n[1] 0.66\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_nn1_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_nn1_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.7.2 Single Layer NN with 2 hidden units\n\nFit\n\n\nfit_nn2_bench &lt;- \n mlp(hidden_units = 2) |&gt; \n  set_engine(\"nnet\") |&gt; \n  set_mode(\"classification\") |&gt; \n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\n\n\naccuracy_vec(test$classes, \n             predict(fit_nn2_bench, test)$.pred_class)\n\n[1] 0.765\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_nn2_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) + \n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_nn2_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)\n\n\n\n\n\n\n\n4.11.7.3 Single Layer NN with 5 hidden units\n\nFit\n\n\nfit_nn5_bench &lt;- \n mlp(hidden_units = 5) |&gt; \n  set_engine(\"nnet\") |&gt; \n  set_mode(\"classification\") |&gt; \n  fit(classes ~ x_1 + x_2, data = data_trn)\n\n\n\nAccuracy and Decision Boundary\n\n\naccuracy_vec(test$classes, \n             predict(fit_nn5_bench, test)$.pred_class)\n\n[1] 0.96\n\n\n\np_train &lt;- data_trn |&gt; \n  plot_decision_boundary(fit_nn5_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\np_test &lt;- test |&gt; \n  plot_decision_boundary(fit_nn5_bench, x_names = c(\"x_1\", \"x_2\"), y_name = \"classes\", n_points = 400) +\n  coord_obs_pred()\n\ncowplot::plot_grid(p_train, p_test, labels = list(\"Train\", \"Test\"), hjust = -1.5)"
  },
  {
    "objectID": "004_classification.html#discussion",
    "href": "004_classification.html#discussion",
    "title": "4  Introduction to Classification Models",
    "section": "4.12 Discussion",
    "text": "4.12 Discussion\n\n4.12.1 And the winner is….\n\nTop 3:\nNext 3:\nEveryone else:\n\n\n\n4.12.2 Other announcements\n\nUpdated use of discussion\nQuiz performance\nFeedback, captions, slack feedback\nDummy coding concepts (options for instruction)\n\n\n\n4.12.3 Student Questions\n\nBayes classifier\n\nCould you explain this statement about the Bayes classifier?: Pr(Y=k|X=x0) for k=1:K\nI really don’t understand Bayes classifier after searching additional information. terminology to this concept is confusing.\n\nLogistic Regression\n\nLogistic Regression and its figure\n\nLDA/QDA\n\nIt would be great if you could talk through the broad logic of what generative classifiers are doing (e.g., James pg 141-2). I feel like I sort of get it; instead of estimating distributions of classes conditioned on features, they’re estimating distributions of features conditioned on classes, and then using Bayes’ rule? but it would be helpful to talk through this in the context of an example.\nWhat is the difference between LDA and QDA? Comparison\nWhat makes QDA model more flexible? And why that makes less bias but more potential for overfitting in QDA?\n\nComparisons among algorithms\n\nI do not understand how logistic regression is different than linear discriminant analysis? It seems in LDA, the goal is to find an optimal line to classify on. However, isn’t logistic regression effectively doing the same by trying to create a model that is most predictive? How is the boundary line different?\nI think I understand when you would use a LDA versus QDA, but I would like to know more about when to choose the logistic regression. Are LDA and QDAs completely different from the logistic regression conceptually?\nWe haven’t talk about logistic regression yet in psych610. What are some advantages and disadvantages of logistic regression compared to other classification methods?\nCould you please go over the differences between LDA/QDA and logistic regression. I understand these parametric models are intermediate models between logistic regression and knn, but I don’t understand the advantage of using them over knn or logistic regression.\n\nCategorical predictors\n\nCan knn classification deal with data having a 2+ category outcome variable?\nAlso, best practices for dummy coding or creating grouped levels or if this is just trial and error and what seems to make the most sense.\n\nMissing data\n\nWe had a lot of missing data this week. I am curious about the best ways to impute this data, and whether or not that should differ between classification and regression models\nHow to select the right algorithm for missing data?\n\nGeneric modeling questions\n\nHow do I figure out why my model is doing worse? How to think about this without visualization?\nI’m still a bit confused about what would take place in modeling EDA vs. model fitting and evaluation. For example, if I want to separate the Titanic variable cabin into cabin letter and number, would that be a step that takes place in recipes only?\nHow can we quickly decide which predictors to include in our model when we have so many predictors and multicollinearity issues may happen?\nCan we extrapolate more classification questions from the data we already collected? For example, if you are collecting heart rate of a person, while exercising. Can you then create a new variable that says if the person was tired or not?\n\nOther questions\n\nIn 610, we plotted predicted points along with our predicted data points along in our final graphs. Do you recommend plotting predicted points on our graphs for publication?\nCan you review the variable “beef” that you create in the “step_pca” function? How do the numeric variables get combined?\nuse cases for random forest models\nFor all of these classifiers, will they work differently on large datasets with different types of data such as texts and images? If yes, which ones may work faster with large text data and large image data?\n\n\n\n\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2023. An Introduction to Statistical Learning: With Applications in R. 2nd ed. Springer Texts in Statistics. New York: Springer-Verlag."
  },
  {
    "objectID": "005_resampling.html#overview-of-unit",
    "href": "005_resampling.html#overview-of-unit",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.1 Overview of Unit",
    "text": "5.1 Overview of Unit\n\n5.1.1 Learning Objectives\n\nBias vs. variance wrt model performance estimates\n\nHow is this different from bias vs. variable of model itself\n\nHow to do parallel processing\nTypes of resampling\n\nValidation set approach\nLeave One Out CV\nK-Fold and Repeated K-Fold\nGrouped K-Fold\nBootstrap resampling\n\nUse of resampling for tuning hyperparameters\n\nCombining these resampling approaches with a Test set\n\nUsed for simultaneous model selection and evaluation\nSingle independent test set\nAdvanced topic: Nested resampling\n\n\n\n\n\n5.1.2 Readings\n\nKuhn and Johnson (2018) Chapter 4, pp 61 - 80\nSupplemental: James et al. (2023) Chapter 5, pp 197 - 208 186\n\n\n\n5.1.3 Lecture Videos\n\nLecture 1: Overview & Parallel Processing\nLecture 2: Single Validation/Test Set Approach\nLecture 3: Leave One Out Cross Validation\nLecture 4: K-fold Cross Validation Approaches\nLecture 5: Bootstrap Resampling\nLecture 6: Tuning Hyperparameters via Resampling\nLecture 7: Resampling for Both Model Selection and Evaluation\nLecture 8: Nested Resampling\nDiscussion\n\nPost questions or discuss readings or lectures on Slack\n\n\n\n5.1.4 Application Assignment and Quiz\n\ndata\ndata dictionary\nrmd shell\nsolution\n\nPost questions to application_assignments Slack channel\nSubmit the application assignment here and complete the unit quiz by 8 pm on Wednesday, February 21st"
  },
  {
    "objectID": "005_resampling.html#introduction",
    "href": "005_resampling.html#introduction",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.2 Introduction",
    "text": "5.2 Introduction\nWe use resampling for two goals:\n\nTo select among model configurations based on relative performance estimates of these configurations in new data\nTo evaluate the performance of our best/final model configuration in new data\n\nFor both of these goals we are using new data to estimate performance of model configuration(s)\n\nThere are two kinds of problems that can emerge from using a sub-optimal resampling approach\n\nWe can get a biased estimate of model performance (i.e., we can systematically under or over-estimate its performance)\nWe can get an imprecise estimate of model performance (i.e., high variance in our model performance metric if it was repeatedly calculated in different samples of held-out data)\n\n\nEssentially, this is the bias and variance problem again, but now not with respect to the model’s actual performance but instead with our estimate of how the model will perform\nThis is a very important distinction to keep in mind or you will be confused as we discuss bias and variance into the future. We have:\n\nbias and variance of model performance (i.e., the predictions the model makes)\nbias and variance of our estimate of how well the model will perform in new data\ndifferent factors affect each\n\n\nLet’s get a dataset for this unit. We will use the heart disease dataset from the UCI Machine Learning Repository. We will focus on the Cleveland data subset, whose variable are defined in this data dictionary\nThese data are less well prepared\n\nNo variable/column names exist\nNA is coded with ?\nUse rename() to add tidy variable names\n\n\ndata_all &lt;- read_csv(here::here(path_data, \"cleveland.csv\"), \n1                     col_names = FALSE,\n2                     na = \"?\") |&gt;\n  rename(age = X1,\n         sex = X2,\n         cp = X3,\n         rest_bp = X4,\n         chol = X5,\n         fbs = X6,\n         rest_ecg = X7,\n         max_hr = X8,\n         exer_ang = X9,\n         exer_st_depress = X10,\n         exer_st_slope = X11,\n         ca = X12,\n         thal = X13,\n         disease = X14) |&gt; \n  glimpse()\n\n\n1\n\nIndicating that column names are NOT on the first row. First row begins with data\n\n2\n\nSpecifying a non-standard value for NA\n\n\n\n\nRows: 303 Columns: 14\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (14): X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nRows: 303\nColumns: 14\n$ age             &lt;dbl&gt; 63, 67, 67, 37, 41, 56, 62, 57, 63, 53, 57, 56, 56, 44…\n$ sex             &lt;dbl&gt; 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, …\n$ cp              &lt;dbl&gt; 1, 4, 4, 3, 2, 2, 4, 4, 4, 4, 4, 2, 3, 2, 3, 3, 2, 4, …\n$ rest_bp         &lt;dbl&gt; 145, 160, 120, 130, 130, 120, 140, 120, 130, 140, 140,…\n$ chol            &lt;dbl&gt; 233, 286, 229, 250, 204, 236, 268, 354, 254, 203, 192,…\n$ fbs             &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, …\n$ rest_ecg        &lt;dbl&gt; 2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, …\n$ max_hr          &lt;dbl&gt; 150, 108, 129, 187, 172, 178, 160, 163, 147, 155, 148,…\n$ exer_ang        &lt;dbl&gt; 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, …\n$ exer_st_depress &lt;dbl&gt; 2.3, 1.5, 2.6, 3.5, 1.4, 0.8, 3.6, 0.6, 1.4, 3.1, 0.4,…\n$ exer_st_slope   &lt;dbl&gt; 3, 2, 2, 3, 1, 1, 3, 1, 2, 3, 2, 2, 2, 1, 1, 1, 3, 1, …\n$ ca              &lt;dbl&gt; 0, 3, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, …\n$ thal            &lt;dbl&gt; 6, 3, 7, 3, 3, 3, 3, 3, 7, 7, 6, 3, 6, 7, 7, 3, 7, 3, …\n$ disease         &lt;dbl&gt; 0, 2, 1, 0, 0, 0, 3, 0, 2, 1, 0, 0, 2, 0, 0, 0, 1, 0, …\n\n\n\n\nCode categorical variables as factors with meaningful text labels (and no spaces)\n\nCan use if_else() for binary recode\nUse recode() for more complicated recodes (don’t forget namespace. dplyr::)\n\n\n\ndata_all &lt;- data_all |&gt; \n  mutate(disease = factor(disease, levels = 0:2, \n                          labels = c(\"no\", \"yes1\", \"yes2\")),\n         disease = fct_collapse(disease, \n                                yes = c(\"yes1\", \"yes2\")),\n         sex = factor(sex,  levels = c(0, 1), labels = c(\"female\", \"male\")),\n         fbs = factor(fbs, levels = c(0, 1), labels = c(\"no\", \"yes\")),\n         exer_ang = factor(exer_ang, levels = c(0, 1), labels = c(\"no\", \"yes\")),\n         exer_st_slope = factor(exer_st_slope, levels = 1:3, \n                                labels = c(\"upslope\", \"flat\", \"downslope\")),\n         cp = factor(cp, levels = 1:4, \n                     labels = c(\"typ_ang\", \"atyp_ang\", \"non_anginal\", \"non_anginal\")),\n         rest_ecg = factor(rest_ecg, levels = 0:2, \n                           labels = c(\"normal\", \"wave_abn\", \"ventric_hypertrophy\")),\n         thal = factor(thal, levels = c(3, 6, 7), \n                       labels = c(\"normal\", \"fixeddefect\", \"reversabledefect\"))) |&gt; \n  glimpse()\n\nRows: 303\nColumns: 14\n$ age             &lt;dbl&gt; 63, 67, 67, 37, 41, 56, 62, 57, 63, 53, 57, 56, 56, 44…\n$ sex             &lt;fct&gt; male, male, male, male, female, male, female, female, …\n$ cp              &lt;fct&gt; typ_ang, non_anginal, non_anginal, non_anginal, atyp_a…\n$ rest_bp         &lt;dbl&gt; 145, 160, 120, 130, 130, 120, 140, 120, 130, 140, 140,…\n$ chol            &lt;dbl&gt; 233, 286, 229, 250, 204, 236, 268, 354, 254, 203, 192,…\n$ fbs             &lt;fct&gt; yes, no, no, no, no, no, no, no, no, yes, no, no, yes,…\n$ rest_ecg        &lt;fct&gt; ventric_hypertrophy, ventric_hypertrophy, ventric_hype…\n$ max_hr          &lt;dbl&gt; 150, 108, 129, 187, 172, 178, 160, 163, 147, 155, 148,…\n$ exer_ang        &lt;fct&gt; no, yes, yes, no, no, no, no, yes, no, yes, no, no, ye…\n$ exer_st_depress &lt;dbl&gt; 2.3, 1.5, 2.6, 3.5, 1.4, 0.8, 3.6, 0.6, 1.4, 3.1, 0.4,…\n$ exer_st_slope   &lt;fct&gt; downslope, flat, flat, downslope, upslope, upslope, do…\n$ ca              &lt;dbl&gt; 0, 3, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, …\n$ thal            &lt;fct&gt; fixeddefect, normal, reversabledefect, normal, normal,…\n$ disease         &lt;fct&gt; no, yes, yes, no, no, no, NA, no, yes, yes, no, no, ye…\n\n\n\nWe won’t do EDA in this unit but lets at least do a quick skim to inform ourselves\n\n303 cases\na dichotomous outcome, disease (yes or no for heart disease)\n7 other categorical predictors\n6 numeric predictors\n2 missing values for thal, which is categorical\n4 missing values for ca, which is numeric\n\n\ndata_all |&gt; skim_all()\n\n\nData summary\n\n\nName\ndata_all\n\n\nNumber of rows\n303\n\n\nNumber of columns\n14\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n8\n\n\nnumeric\n6\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nn_unique\ntop_counts\n\n\n\n\nsex\n0\n1.00\n2\nmal: 206, fem: 97\n\n\ncp\n0\n1.00\n3\nnon: 230, aty: 50, typ: 23\n\n\nfbs\n0\n1.00\n2\nno: 258, yes: 45\n\n\nrest_ecg\n0\n1.00\n3\nnor: 151, ven: 148, wav: 4\n\n\nexer_ang\n0\n1.00\n2\nno: 204, yes: 99\n\n\nexer_st_slope\n0\n1.00\n3\nups: 142, fla: 140, dow: 21\n\n\nthal\n2\n0.99\n3\nnor: 166, rev: 117, fix: 18\n\n\ndisease\n48\n0.84\n2\nno: 164, yes: 91\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\nage\n0\n1.00\n54.44\n9.04\n29\n48.0\n56.0\n61.0\n77.0\n-0.21\n-0.55\n\n\nrest_bp\n0\n1.00\n131.69\n17.60\n94\n120.0\n130.0\n140.0\n200.0\n0.70\n0.82\n\n\nchol\n0\n1.00\n246.69\n51.78\n126\n211.0\n241.0\n275.0\n564.0\n1.12\n4.35\n\n\nmax_hr\n0\n1.00\n149.61\n22.88\n71\n133.5\n153.0\n166.0\n202.0\n-0.53\n-0.09\n\n\nexer_st_depress\n0\n1.00\n1.04\n1.16\n0\n0.0\n0.8\n1.6\n6.2\n1.26\n1.50\n\n\nca\n4\n0.99\n0.67\n0.94\n0\n0.0\n0.0\n1.0\n3.0\n1.18\n0.21\n\n\n\n\n\n\nWe will be fitting a logistic regression with all of the predictors for the first half of this unit\nLets set up a recipe for feature engineering with this statistical algorithm\n\nImpute missing data for all numeric predictors using median imputation\nImpute missing data for all nominal nominal predictors using the modal value\ndummy code all nominal predictors\n\n\nrec &lt;- recipe(disease ~ ., data = data_all) |&gt; \n  step_impute_median(all_numeric_predictors()) |&gt; \n  step_impute_mode(all_nominal_predictors()) |&gt;   \n  step_dummy(all_nominal_predictors()) \n\n\nThe order of steps in a recipe matter\nWhile your project’s needs may vary, here is a suggested order of potential steps that should work for most problems according to tidy models folks:\n\n[Convert character to factor] (we do this outside our recipe as part of cleaning)\nImpute\nIndividual transformations for skewness and other issues\nDiscretize (if needed and if you have no other choice)\nCreate dummy variables\nCreate interactions\nNormalization steps (center, scale, range, etc)\nMultivariate transformation (e.g. PCA, spatial sign, etc)"
  },
  {
    "objectID": "005_resampling.html#some-technical-details",
    "href": "005_resampling.html#some-technical-details",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.3 Some Technical Details",
    "text": "5.3 Some Technical Details\n\n5.3.1 Parallel Processing\nWhen using resampling, we often end up fitting many, many models\n\nThis can be the same model configuration in many different training sets\nOr many different model configurations in many different training sets (even more computationally demanding)\n\nIt really speeds things up to set up parallel processing backend!\n\nLots of options and details depending on the code you intend to run in parallel to do it really well\nWe can discuss some of these issues/details and other solutions (i.e., High Throughput Computing at CHTC)\nSome options are OS specific\nThis version is sufficient for most uses in tidymodels\n\n\nlibrary(doParallel, exclude = c(\"accumulate\", \"when\"))\n\nLoading required package: foreach\n\n\n\nAttaching package: 'foreach'\n\n\nThe following objects are masked from 'package:purrr':\n\n    accumulate, when\n\n\nLoading required package: iterators\n\n\nLoading required package: parallel\n\n\nWarning in rm(list = exclude, envir = env): object 'accumulate' not found\n\n\nWarning in rm(list = exclude, envir = env): object 'when' not found\n\ncl &lt;- makePSOCKcluster(parallel::detectCores(logical = FALSE))\nregisterDoParallel(cl)\n\n\n\n5.3.2 Using Cache:::\n\n\n5.3.3 Question:\n\n\nShow Answer\nInsert answer text.  Hard return at about 80 char\n\n\n:::\nNEED TO ADD THIS SECTION TO WEBBOOK. Will recommend use of xfun::cache_rds()"
  },
  {
    "objectID": "005_resampling.html#the-single-validation-test-set-approach",
    "href": "005_resampling.html#the-single-validation-test-set-approach",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.4 The single validation (test) set approach",
    "text": "5.4 The single validation (test) set approach\nTo date, you have essentially learned how to do the single validation set approach (although we haven’t called it that)\nWith this approach, we would take our full n = 303 and:\n\nSplit into one training set and one held-out set\nFit a model in our training set\nUse this trained model to predict scores in held-out set\nCalculate a performance metric (e.g., accuracy, rmse) based on predicted and observed scores in the held-out set\n\nIf our goal was to evaluate the expected performance of a single model configuration in new data\n\nWe called this held-out set a test set\nWe would report this performance metric from the held-out test set as our estimate of the performance of our model in new data\n\nIf our goal was to select the best model configuration among many candidate configurations\n\nWe called this held-out set a validation set\nWe would use this performance metric from the held-out validation set to select the best model configuration\n\nWe call this the single validation set approach but that single held-out set can be either a validation or test set depending on our goals\n\nWe have been doing the single validation set approach all along but we will provide one more example now (with a 50/50 split) to transition the code we are using to a more general workflow that will accommodate our more complicated resampling approaches\nIn the first half of this unit, we will focus on assessing the performance of a single model configuration\n\nLogistic regression algorithm\nNo hyper-parameters\nAll available predictors\n\nWe will call the held-out set a test set and use it to evaluate the expected future performance of this single configuration\n\nPreviously:\n\nWe would fit the model configuration in training and then made predictions for observations in the held-out test set in separate steps\nWe did this in separate steps so you could better understand the process\n\nI will show you that first again as a baseline\n\n\nNow: - We will now do these tasks in one step using \\(validation\\_split()\\) - I will show you this combined approach second - This latter approach will be an example for how we code this for our more complicated resampling approaches.\n\n\nLet’s do a 50/50 split, stratified on our outcome, disease\n\n\nset.seed(19690127)\n\nsplits &lt;- data_all |&gt; \n  initial_split(prop = 0.5, strata = \"disease\")\n\ndata_trn &lt;- analysis(splits)\ndata_trn |&gt;  nrow()\n\n[1] 151\n\ndata_test &lt;- assessment(splits)\ndata_test |&gt; nrow()\n\n[1] 152\n\n\n\nMake features for train and test\n\n\nfeat_trn &lt;- rec |&gt; \n  make_features(data_trn, data_trn)\n\nRows: 151\nColumns: 18\n$ age                          &lt;dbl&gt; 63, 41, 57, 56, 44, 57, 66, 69, 44, 61, 7…\n$ rest_bp                      &lt;dbl&gt; 145, 130, 140, 140, 120, 150, 150, 140, 1…\n$ chol                         &lt;dbl&gt; 233, 204, 192, 294, 263, 168, 226, 239, 2…\n$ max_hr                       &lt;dbl&gt; 150, 172, 148, 153, 173, 174, 114, 151, 1…\n$ exer_st_depress              &lt;dbl&gt; 2.3, 1.4, 0.4, 1.3, 0.0, 1.6, 2.6, 1.8, 0…\n$ ca                           &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0,…\n$ disease                      &lt;fct&gt; no, no, no, no, no, no, no, no, no, no, n…\n$ sex_male                     &lt;dbl&gt; 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1,…\n$ cp_atyp_ang                  &lt;dbl&gt; 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0,…\n$ cp_non_anginal               &lt;dbl&gt; 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1,…\n$ fbs_yes                      &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,…\n$ rest_ecg_wave_abn            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ rest_ecg_ventric_hypertrophy &lt;dbl&gt; 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,…\n$ exer_ang_yes                 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,…\n$ exer_st_slope_flat           &lt;dbl&gt; 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,…\n$ exer_st_slope_downslope      &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,…\n$ thal_fixeddefect             &lt;dbl&gt; 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ thal_reversabledefect        &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,…\n\nfeat_test &lt;- rec |&gt; \n  make_features(data_trn, data_test)\n\nRows: 152\nColumns: 18\n$ age                          &lt;dbl&gt; 37, 56, 57, 63, 53, 56, 52, 48, 54, 48, 4…\n$ rest_bp                      &lt;dbl&gt; 130, 120, 120, 130, 140, 130, 172, 110, 1…\n$ chol                         &lt;dbl&gt; 250, 236, 354, 254, 203, 256, 199, 229, 2…\n$ max_hr                       &lt;dbl&gt; 187, 178, 163, 147, 155, 142, 162, 168, 1…\n$ exer_st_depress              &lt;dbl&gt; 3.5, 0.8, 0.6, 1.4, 3.1, 0.6, 0.5, 1.0, 1…\n$ ca                           &lt;dbl&gt; 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ disease                      &lt;fct&gt; no, no, no, yes, yes, yes, no, yes, no, n…\n$ sex_male                     &lt;dbl&gt; 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,…\n$ cp_atyp_ang                  &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1,…\n$ cp_non_anginal               &lt;dbl&gt; 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0,…\n$ fbs_yes                      &lt;dbl&gt; 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0,…\n$ rest_ecg_wave_abn            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ rest_ecg_ventric_hypertrophy &lt;dbl&gt; 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1,…\n$ exer_ang_yes                 &lt;dbl&gt; 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0,…\n$ exer_st_slope_flat           &lt;dbl&gt; 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,…\n$ exer_st_slope_downslope      &lt;dbl&gt; 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,…\n$ thal_fixeddefect             &lt;dbl&gt; 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ thal_reversabledefect        &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0,…\n\n\n\nFit model in train\n\n\nfit_lr &lt;-\n  logistic_reg() |&gt; \n  set_engine(\"glm\") |&gt; \n  fit(disease ~ ., data = feat_trn)\n\n\nEvaluate model in validate\n\n\naccuracy_vec(feat_test$disease, predict(fit_lr, feat_test, type = \"class\")$.pred_class)\n\nWarning in predict.lm(object, newdata, se.fit, scale = 1, type = if (type == :\nprediction from rank-deficient fit; attr(*, \"non-estim\") has doubtful cases\n\n\n[1] 0.8031496\n\n\n\nNow lets do this all in one set of steps with a slightly more efficient workflow\n\nNote use of splits_validate()\nNote use of fit_resamples()\n\nTakes algorithm, recipe, and splits as inputs\nSpecify the metric we want to use to evaluate the model\n\nNote use of collect_metrics() to see performance in validation set\nDon’t see the feature matrix. May still want to build it as a check?\n\n\nset.seed(19690127)\nsplits_validate &lt;- data_all |&gt; \n  validation_split(prop = 0.5, strata = \"disease\")\n\n\nfits_lr &lt;-xfun::cache_rds({\n\n  logistic_reg() |&gt; \n    set_engine(\"glm\") |&gt; \n    fit_resamples(preprocessor = rec, resamples = splits_validate, \n                  metrics = metric_set(accuracy))\n  \n}, \nrerun = FALSE,\nhash = list(rec, splits_validate),\ndir = \"cache/\",\nfile = \"u5-valdiation-set-6.rds\")\n\n\ncollect_metrics(fits_lr, summarize = TRUE)\n\n# A tibble: 1 × 6\n  .metric  .estimator  mean     n std_err .config             \n  &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 accuracy binary     0.803     1      NA Preprocessor1_Model1\n\n\n\nAnd regardless of how we handle the test set split, we need to end with fitting a final model using all available data\n\n# features for the full dataset\n# will be used as a final training set for final model\nfeat_all &lt;- rec |&gt; \n  make_features(data_all, data_all)\n\nRows: 303\nColumns: 18\n$ age                          &lt;dbl&gt; 63, 67, 67, 37, 41, 56, 62, 57, 63, 53, 5…\n$ rest_bp                      &lt;dbl&gt; 145, 160, 120, 130, 130, 120, 140, 120, 1…\n$ chol                         &lt;dbl&gt; 233, 286, 229, 250, 204, 236, 268, 354, 2…\n$ max_hr                       &lt;dbl&gt; 150, 108, 129, 187, 172, 178, 160, 163, 1…\n$ exer_st_depress              &lt;dbl&gt; 2.3, 1.5, 2.6, 3.5, 1.4, 0.8, 3.6, 0.6, 1…\n$ ca                           &lt;dbl&gt; 0, 3, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0,…\n$ disease                      &lt;fct&gt; no, yes, yes, no, no, no, NA, no, yes, ye…\n$ sex_male                     &lt;dbl&gt; 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1,…\n$ cp_atyp_ang                  &lt;dbl&gt; 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1,…\n$ cp_non_anginal               &lt;dbl&gt; 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0,…\n$ fbs_yes                      &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,…\n$ rest_ecg_wave_abn            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ rest_ecg_ventric_hypertrophy &lt;dbl&gt; 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0,…\n$ exer_ang_yes                 &lt;dbl&gt; 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0,…\n$ exer_st_slope_flat           &lt;dbl&gt; 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0,…\n$ exer_st_slope_downslope      &lt;dbl&gt; 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,…\n$ thal_fixeddefect             &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,…\n$ thal_reversabledefect        &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1,…\n\nfit_lr &lt;-\n  logistic_reg() |&gt; \n  set_engine(\"glm\") |&gt; \n  fit(disease ~ ., data = feat_all)\n\nfit_lr |&gt; tidy()\n\n# A tibble: 18 × 5\n   term                         estimate std.error statistic   p.value\n   &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1 (Intercept)                  -5.25      2.87       -1.83  0.0670   \n 2 age                          -0.0113    0.0243     -0.463 0.643    \n 3 rest_bp                       0.0236    0.0111      2.12  0.0339   \n 4 chol                          0.00450   0.00383     1.17  0.241    \n 5 max_hr                       -0.0195    0.0109     -1.78  0.0751   \n 6 exer_st_depress               0.167     0.229       0.732 0.464    \n 7 ca                            1.09      0.270       4.05  0.0000509\n 8 sex_male                      1.51      0.511       2.95  0.00314  \n 9 cp_atyp_ang                   0.719     0.778       0.925 0.355    \n10 cp_non_anginal                1.10      0.626       1.76  0.0786   \n11 fbs_yes                      -0.848     0.535      -1.59  0.113    \n12 rest_ecg_wave_abn             0.236     2.05        0.115 0.909    \n13 rest_ecg_ventric_hypertrophy  0.329     0.375       0.878 0.380    \n14 exer_ang_yes                  1.22      0.411       2.97  0.00296  \n15 exer_st_slope_flat            0.982     0.454       2.16  0.0308   \n16 exer_st_slope_downslope       0.333     0.892       0.374 0.708    \n17 thal_fixeddefect              0.366     0.757       0.483 0.629    \n18 thal_reversabledefect         1.17      0.410       2.85  0.00440  \n\n\nIf we need to predict disease in the future, this is the model we would use (with these parameter estimate)\nOur estimate of its future accuracy is based on our previous assessment (one of the two methods above)\n\nLets consider some conceptual issues that are key to understand with respect to resampling for model selection OR model evaluation\n\n\n\n\n\n\nQuestion: What do you know about the performance of the final/best model fit with n = 303 vs. a model fit with 50% (N = 152) that we designated as our training set?\n\n\n\n\n\n\n\nShow Answer\nThe model fit in the subset of training data will perform less well than the model\nfit to the full n = 303.  Because it is fit with a smaller sample size it will have\nbe more overfit (and show more variance across different potential training sets)\n\n\n\n\n\n\n\n\n\n\n\n::: {.callout-important collapse=“false”} ### Question: If our final/best model was fit with n = 303, what can you say about our estimate of its performance using this single train/test split that only fit with a subset of the available data?\n\n\n::: {.cell}\n\n\n{.html .cell-code  code-fold=\"true\" code-summary=\"Show Answer\"} Our performance estimate of our final model (fit with n = 303) based on a model fit with n = 152 will be biased.  Our performance estimate will likely underestimate the true performance of our final model trained with n = 303 because we are evaluating a fitted model that will be more overfit than this model because it was fit with a smaller n. :::\n\n\n:::\n\n\n\n\n\n\n\n\n\nQuestion: Contrast the costs/benefits of a 50/50 vs. 80/20 split for train and test\n\n\n\n\n\n\n\nShow Answer\nUsing a training set with 80% of the sample will yield a less biased (under)\nestimate of the final (using all data) model performance than a training set with\n50% of the sample.  However, using a test set of 20% of the data will produce a \nmore variable (less precise) estimate of performance than the 50% test set.  This \nis another bias-variance trade off but now instead of talking about model\nperformance, we are seeing that we have to trade off bias and variance in our\nestimate of the model performance too!\n\n\n\n\n\nThis recognition of a bias-variance trade-off in our performance estimates is what motivates the more complicated resampling approaches we will now consider."
  },
  {
    "objectID": "005_resampling.html#leave-one-out-cross-validation",
    "href": "005_resampling.html#leave-one-out-cross-validation",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.5 Leave One Out Cross Validation",
    "text": "5.5 Leave One Out Cross Validation\nLet’s turn to a new resampling technique and start with some questions to motivate it\n\n\n\n\n\n\nQuestion: How could you use this single validation set approach to get the least biased estimate of model performance with your n = 303 dataset that would still allow you to estimate its performance in a held out test set?\n\n\n\n\n\n\n\nshow answer\nPut all but one case into the training set (i.e., leave only one case out in the\ntest set).  In our example, you would fit a model with n = 302  this model will \nhave essentially equivalent overfitting as n = 303 so it will not yield much bias \nwhen we use it to estimate the performance of the n = 303 model.\n\n\n\n\n\n\n\n\n\n\n\nQuestion: What will be the biggest problem with this approach?\n\n\n\n\n\n\n\nShow Answer\nYou will estimate performance with only n = 1 in the test set.  This means there \nwill be high variance in your performance estimate.\n\n\n\n\n\n\n\n\n\n\n\nQuestion: How might you reduce this problem?\n\n\n\n\n\n\n\nShow Answer\nRepeat this split between training and validation n times so that there are n different\nsets of n = 1 test sets.  Then average the performance across all n of these test \nsets to get a more stable estimate of performance.  this is leave one out\ncross-validation.\n\n\n\n\n\ncomparisons across loocv and single validation set approaches\n\nthe performance estimate from loocv has less bias than the single validation set method (because the models that are evaluated were fit with close to the full n of the final model)\nloocv uses all observations as “test” at some point. less variance than single 20% or 50% validation set?\n\nbut…\n\nloocv can be computationally expensive (need to fit and evaluate the same model configuration n times). this is a real problem when you are also working with a high number of model configurations (i.e., number fits = n * number of model configurations).\n\n\nloocv eventually uses all the data for test across the ‘n’ test sets. averaging also helps reduce variance in the performance metric.\nhowever, averaging reduces variance to a greater degree when the performance measures being averaged are less related/more independent.\nthe n fitted models are very similar in loocv b/c they are each fit on almost the same data (each with n-1 observations)\nk-fold cross validation (next method) improves the variance of the average performance metric by averaging across more independent (less overlapping) training sets\nfor this reason, it is superior and (always?) preferred over loocv\nwe are not demonstrating loocv b/c we strongly prefer other methods (k-fold)\n\nstill important to understand it conceptually and its strengths/weaknesses\nif you wanted to use this resampling approach, simply substitute loo_cv() for vfold_cv() in the next example"
  },
  {
    "objectID": "005_resampling.html#k-fold-cross-validation",
    "href": "005_resampling.html#k-fold-cross-validation",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.6 K-fold Cross Validation",
    "text": "5.6 K-fold Cross Validation\nK-fold cross validation\n\nDivide the observations into K equal size independent “folds” (each observation appears in only one fold)\nHold out 1 of these folds (1/Kth of the dataset) to use as a test set\nFit a model in the remaining K-1 folds\nRepeat until each of the folds has been held out once\nPerformance estimate is the average performance across the K held out folds\n\nCommon values of K are 5 and 10\nNote that K is sometimes referred to as V in some fields/literatures (Don’t blame me!)\n\nVisualization of K-fold\n\n\n\n\n\n\n\n\n\n\nAn example of K-fold Cross-validation\n\nSplit into 10 folds (default)\n\n\nrepeats = 1 (default; more on this in a bit)\nstratify on disease\n\n\nsplits_kfold &lt;- data_all |&gt; \n  vfold_cv(v = 10, repeats = 1, strata = \"disease\")\n\nsplits_kfold\n\n#  10-fold cross-validation using stratification \n# A tibble: 10 × 2\n   splits           id    \n   &lt;list&gt;           &lt;chr&gt; \n 1 &lt;split [272/31]&gt; Fold01\n 2 &lt;split [272/31]&gt; Fold02\n 3 &lt;split [272/31]&gt; Fold03\n 4 &lt;split [272/31]&gt; Fold04\n 5 &lt;split [272/31]&gt; Fold05\n 6 &lt;split [272/31]&gt; Fold06\n 7 &lt;split [273/30]&gt; Fold07\n 8 &lt;split [274/29]&gt; Fold08\n 9 &lt;split [274/29]&gt; Fold09\n10 &lt;split [274/29]&gt; Fold10\n\n\n\n\nFit model configuration in first 9 folds, evaluate in 10th fold. Repeat 9 more times for each additional held-out fold\n\n\nUse \\(fit\\_resamples()\\)https://tune.tidymodels.org/reference/fit_resamples.html\n\nNo need to continue to remake features for train and test. Just provide splits and rec\nSet performance metrics with metric_set()\n\nDefault for classification is accuracy and area under ROC curve (discussed in later unit)\n\n\nI will call these objects fits_ to make clear that this object includes multiple fit models (vs. the final fit)\n\n\nfits_lr_kfold &lt;- xfun::cache_rds({\n  \n  logistic_reg() |&gt; \n    set_engine(\"glm\") |&gt; \n    fit_resamples(preprocessor = rec, resamples = splits_kfold, \n                  metrics = metric_set(accuracy))\n\n}, \nrerun = FALSE,\ndir = \"cache/\",\nfile = \"u5-kfold-3.rds\")\n\n\n\nReview performance estimates in held out folds using collect_metrics()\n\n\nCan see performance in all folds using summarize = FALSE\n\n\nmetrics_kfold &lt;- collect_metrics(fits_lr_kfold, summarize = FALSE)\n\nmetrics_kfold |&gt; print_kbl()\n\n\n\n\n\nid\n.metric\n.estimator\n.estimate\n.config\n\n\n\n\nFold01\naccuracy\nbinary\n0.72\nPreprocessor1_Model1\n\n\nFold02\naccuracy\nbinary\n0.89\nPreprocessor1_Model1\n\n\nFold03\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nFold04\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nFold05\naccuracy\nbinary\n0.68\nPreprocessor1_Model1\n\n\nFold06\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nFold07\naccuracy\nbinary\n0.85\nPreprocessor1_Model1\n\n\nFold08\naccuracy\nbinary\n0.92\nPreprocessor1_Model1\n\n\nFold09\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nFold10\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\n\n\n\n\n\n\nCould plot this as a histogram to visualize sampling distribution of performance estimates\nWould be better if we had more folds (see repeats in a bit)\n\n\nmetrics_kfold |&gt; plot_hist(\".estimate\")\n\n\n\n\n\nCan see the average performance over folds along with its standard error using \\(summarize = TRUE\\)\n\n\ncollect_metrics(fits_lr_kfold, summarize = TRUE)\n\n# A tibble: 1 × 6\n  .metric  .estimator  mean     n std_err .config             \n  &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 accuracy binary     0.796    10  0.0230 Preprocessor1_Model1\n\n\n\nYou still fit the final model as before\n\n\nfit_lr &lt;-\n  logistic_reg() |&gt; \n  set_engine(\"glm\") |&gt; \n  fit(disease ~ ., data = feat_all)\n\nfit_lr |&gt; tidy()\n\n# A tibble: 18 × 5\n   term                         estimate std.error statistic   p.value\n   &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1 (Intercept)                  -5.25      2.87       -1.83  0.0670   \n 2 age                          -0.0113    0.0243     -0.463 0.643    \n 3 rest_bp                       0.0236    0.0111      2.12  0.0339   \n 4 chol                          0.00450   0.00383     1.17  0.241    \n 5 max_hr                       -0.0195    0.0109     -1.78  0.0751   \n 6 exer_st_depress               0.167     0.229       0.732 0.464    \n 7 ca                            1.09      0.270       4.05  0.0000509\n 8 sex_male                      1.51      0.511       2.95  0.00314  \n 9 cp_atyp_ang                   0.719     0.778       0.925 0.355    \n10 cp_non_anginal                1.10      0.626       1.76  0.0786   \n11 fbs_yes                      -0.848     0.535      -1.59  0.113    \n12 rest_ecg_wave_abn             0.236     2.05        0.115 0.909    \n13 rest_ecg_ventric_hypertrophy  0.329     0.375       0.878 0.380    \n14 exer_ang_yes                  1.22      0.411       2.97  0.00296  \n15 exer_st_slope_flat            0.982     0.454       2.16  0.0308   \n16 exer_st_slope_downslope       0.333     0.892       0.374 0.708    \n17 thal_fixeddefect              0.366     0.757       0.483 0.629    \n18 thal_reversabledefect         1.17      0.410       2.85  0.00440  \n\n\nIf we need to predict disease in the future, this is the fitted model we would use (with these parameter estimates)\nOur estimate of its future accuracy is 0.7963149 with a standard error of 0.023027\n\nComparisons between K-fold vs. LOOCV and Single Validation set\nFor Bias:\n\nK-fold typically has less bias than the single validation set method\n\nE.g. 10-fold fits models with 9/10th of the data vs. 50% or 80%, etc\n\nK Fold has somewhat more bias than LOOCV because LOOCV uses n - 1 observations for fitting models\n\nFor Variance:\n\nK-fold has less variance than LOOCV\n\nLike LOOCV, it uses all observations in test at some point\nThe averaged models are more independent b/c models are fitted on less overlapping training sets\n\nK-fold has less variance than single validation set b/c it uses all data as test at some point (vs. a subset of held-out test data)\nK-fold is less computationally expensive than LOOCV (though more expensive than single validation set)\nK-fold is generally preferred over both of these other approaches"
  },
  {
    "objectID": "005_resampling.html#repeated-k-fold-cross-validation",
    "href": "005_resampling.html#repeated-k-fold-cross-validation",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.7 Repeated K-fold Cross Validation",
    "text": "5.7 Repeated K-fold Cross Validation\nYou can repeat the K-fold procedure multiple times with new splits for a different mix of K folds each time\nTwo benefits:\n\nMore stable performance estimate (because averaged over more folds: repeats * K)\nMany more estimates of performance to characterize (SE; plot) of your performance estimate\n\nBut it is computationally expensive (depending on number of repeats)\n\nAn example of Repeated K-fold Cross-validation\n\nSplits with repeats = 10 (will do 10 different splits of 10-fold)\n\n\nset.seed(19690127)\nsplits_kfold10x &lt;- data_all |&gt; \n  vfold_cv(v = 10, repeats = 10, strata = \"disease\")\n\nsplits_kfold10x\n\n#  10-fold cross-validation repeated 10 times using stratification \n# A tibble: 100 × 3\n   splits           id       id2   \n   &lt;list&gt;           &lt;chr&gt;    &lt;chr&gt; \n 1 &lt;split [272/31]&gt; Repeat01 Fold01\n 2 &lt;split [272/31]&gt; Repeat01 Fold02\n 3 &lt;split [272/31]&gt; Repeat01 Fold03\n 4 &lt;split [272/31]&gt; Repeat01 Fold04\n 5 &lt;split [272/31]&gt; Repeat01 Fold05\n 6 &lt;split [273/30]&gt; Repeat01 Fold06\n 7 &lt;split [273/30]&gt; Repeat01 Fold07\n 8 &lt;split [273/30]&gt; Repeat01 Fold08\n 9 &lt;split [274/29]&gt; Repeat01 Fold09\n10 &lt;split [274/29]&gt; Repeat01 Fold10\n# ℹ 90 more rows\n\n\n\n\nEverything else is the same!\n\n\nfits_lr_kfold10x &lt;- xfun::cache_rds({\n  \n  logistic_reg() |&gt; \n    set_engine(\"glm\") |&gt; \n    fit_resamples(preprocessor = rec, resamples = splits_kfold10x, \n                  metrics = metric_set(accuracy))\n\n}, \nrerun = FALSE,\ndir = \"cache/\",\nfile = \"u5-kfold-9.rds\")\n\n\nmetrics_kfold10x &lt;- collect_metrics(fits_lr_kfold10x, summarize = FALSE)\n\nmetrics_kfold10x |&gt; print_kbl()\n\n\n\n\n\nid\nid2\n.metric\n.estimator\n.estimate\n.config\n\n\n\n\nRepeat01\nFold01\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat01\nFold02\naccuracy\nbinary\n0.82\nPreprocessor1_Model1\n\n\nRepeat01\nFold03\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nRepeat01\nFold04\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nRepeat01\nFold05\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat01\nFold06\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nRepeat01\nFold07\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat01\nFold08\naccuracy\nbinary\n0.86\nPreprocessor1_Model1\n\n\nRepeat01\nFold09\naccuracy\nbinary\n0.67\nPreprocessor1_Model1\n\n\nRepeat01\nFold10\naccuracy\nbinary\n0.70\nPreprocessor1_Model1\n\n\nRepeat02\nFold01\naccuracy\nbinary\n0.82\nPreprocessor1_Model1\n\n\nRepeat02\nFold02\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nRepeat02\nFold03\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nRepeat02\nFold04\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nRepeat02\nFold05\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat02\nFold06\naccuracy\nbinary\n0.69\nPreprocessor1_Model1\n\n\nRepeat02\nFold07\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nRepeat02\nFold08\naccuracy\nbinary\n0.88\nPreprocessor1_Model1\n\n\nRepeat02\nFold09\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nRepeat02\nFold10\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat03\nFold01\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nRepeat03\nFold02\naccuracy\nbinary\n0.88\nPreprocessor1_Model1\n\n\nRepeat03\nFold03\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nRepeat03\nFold04\naccuracy\nbinary\n0.85\nPreprocessor1_Model1\n\n\nRepeat03\nFold05\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat03\nFold06\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat03\nFold07\naccuracy\nbinary\n0.68\nPreprocessor1_Model1\n\n\nRepeat03\nFold08\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nRepeat03\nFold09\naccuracy\nbinary\n0.71\nPreprocessor1_Model1\n\n\nRepeat03\nFold10\naccuracy\nbinary\n0.72\nPreprocessor1_Model1\n\n\nRepeat04\nFold01\naccuracy\nbinary\n0.68\nPreprocessor1_Model1\n\n\nRepeat04\nFold02\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat04\nFold03\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat04\nFold04\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nRepeat04\nFold05\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat04\nFold06\naccuracy\nbinary\n0.69\nPreprocessor1_Model1\n\n\nRepeat04\nFold07\naccuracy\nbinary\n0.69\nPreprocessor1_Model1\n\n\nRepeat04\nFold08\naccuracy\nbinary\n0.86\nPreprocessor1_Model1\n\n\nRepeat04\nFold09\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nRepeat04\nFold10\naccuracy\nbinary\n0.88\nPreprocessor1_Model1\n\n\nRepeat05\nFold01\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nRepeat05\nFold02\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nRepeat05\nFold03\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nRepeat05\nFold04\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nRepeat05\nFold05\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nRepeat05\nFold06\naccuracy\nbinary\n0.91\nPreprocessor1_Model1\n\n\nRepeat05\nFold07\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nRepeat05\nFold08\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nRepeat05\nFold09\naccuracy\nbinary\n0.72\nPreprocessor1_Model1\n\n\nRepeat05\nFold10\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nRepeat06\nFold01\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nRepeat06\nFold02\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nRepeat06\nFold03\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nRepeat06\nFold04\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nRepeat06\nFold05\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nRepeat06\nFold06\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nRepeat06\nFold07\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nRepeat06\nFold08\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat06\nFold09\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nRepeat06\nFold10\naccuracy\nbinary\n0.91\nPreprocessor1_Model1\n\n\nRepeat07\nFold01\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nRepeat07\nFold02\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nRepeat07\nFold03\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nRepeat07\nFold04\naccuracy\nbinary\n0.69\nPreprocessor1_Model1\n\n\nRepeat07\nFold05\naccuracy\nbinary\n0.88\nPreprocessor1_Model1\n\n\nRepeat07\nFold06\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nRepeat07\nFold07\naccuracy\nbinary\n0.88\nPreprocessor1_Model1\n\n\nRepeat07\nFold08\naccuracy\nbinary\n0.72\nPreprocessor1_Model1\n\n\nRepeat07\nFold09\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nRepeat07\nFold10\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nRepeat08\nFold01\naccuracy\nbinary\n0.64\nPreprocessor1_Model1\n\n\nRepeat08\nFold02\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nRepeat08\nFold03\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat08\nFold04\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nRepeat08\nFold05\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nRepeat08\nFold06\naccuracy\nbinary\n0.69\nPreprocessor1_Model1\n\n\nRepeat08\nFold07\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat08\nFold08\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat08\nFold09\naccuracy\nbinary\n0.85\nPreprocessor1_Model1\n\n\nRepeat08\nFold10\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nRepeat09\nFold01\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat09\nFold02\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nRepeat09\nFold03\naccuracy\nbinary\n0.65\nPreprocessor1_Model1\n\n\nRepeat09\nFold04\naccuracy\nbinary\n0.91\nPreprocessor1_Model1\n\n\nRepeat09\nFold05\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nRepeat09\nFold06\naccuracy\nbinary\n0.69\nPreprocessor1_Model1\n\n\nRepeat09\nFold07\naccuracy\nbinary\n0.68\nPreprocessor1_Model1\n\n\nRepeat09\nFold08\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat09\nFold09\naccuracy\nbinary\n0.85\nPreprocessor1_Model1\n\n\nRepeat09\nFold10\naccuracy\nbinary\n0.86\nPreprocessor1_Model1\n\n\nRepeat10\nFold01\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nRepeat10\nFold02\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nRepeat10\nFold03\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nRepeat10\nFold04\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat10\nFold05\naccuracy\nbinary\n0.68\nPreprocessor1_Model1\n\n\nRepeat10\nFold06\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nRepeat10\nFold07\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nRepeat10\nFold08\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nRepeat10\nFold09\naccuracy\nbinary\n0.96\nPreprocessor1_Model1\n\n\nRepeat10\nFold10\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\n\n\n\n\nmetrics_kfold10x |&gt; plot_hist(\".estimate\", bins = 10)\n\n\n\ncollect_metrics(fits_lr_kfold10x, summarize = TRUE)\n\n# A tibble: 1 × 6\n  .metric  .estimator  mean     n std_err .config             \n  &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 accuracy binary     0.786   100 0.00648 Preprocessor1_Model1\n\n\n\nYou should also refit a final model in the full data at the end as before\n\n\nComparisons between repeated K-fold and K-fold\nRepeated K-fold:\n\nHas same bias as K-fold (still fitting models with K-1 folds)\nHas all the benefits of single K-fold\nHas even more stable estimate of performance (mean over more folds/repeats)\nProvides more info about distribution for the performance estimate\nBut is more computationally expensive\n\nRepeated K-fold is preferred over K-fold to the degree possible based on computational limitations (parallel, N, p, statistical algorithm, # of model configurations)"
  },
  {
    "objectID": "005_resampling.html#grouped-k-fold",
    "href": "005_resampling.html#grouped-k-fold",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.8 Grouped K-fold",
    "text": "5.8 Grouped K-fold\nWe have to be particularly careful with resampling methods when we have repeated observations for the same participant (or unit of analysis more generally)\n\nWe can often predict an individuals own data better using some of their own data.\n\nIf our model will not ever encounter that individual again, this will bias our estimate of our models performance with new/future observations.\n\nWe can remove that bias by making sure that all observations from an individual are grouped together so that they always end up in either train or test but never both.\n\nEasy to do a grouped K-fold by making splits using group_vfold_cv() and then proceeding as before with all other analyses/code\n\nset the group argument to the name of the variable that codes for subid or unit of analysis that is repeated."
  },
  {
    "objectID": "005_resampling.html#bootstrap-resampling",
    "href": "005_resampling.html#bootstrap-resampling",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.9 Bootstrap Resampling",
    "text": "5.9 Bootstrap Resampling\nA bootstrap sample is a random sample taken with replacement (i.e., same observations can be sampled multiple times within one bootstrap sample)\nIf you bootstrap a new sample of size n from a dataset with sample size n, approximately 63.2% of the original observations end up in the bootstrap sample\nThe remaining 36.8% of the observations are often called the “out of bag” (OOB) samples\nBootstrap Resampling\n\nCreates B bootstrap samples of size n = n from the original dataset\nFor any specific bootstrap (b)\n\nModel(s) are fit to the bootstrap sample\nModel performance is evaluated in the associated out of bag (held-out) samples\n\nThis is repeated B times such that you have B assessments of model performance\n\n\nAn example of Bootstrap resampling\n\nAgain, all that changes is how you form the splits/resamples\nYou will use \\(bootstraps()\\) to form the splits\nHere are 100 bootstraps stratified on disease\n\n\nset.seed(19690127)\nsplits_boot &lt;- data_all |&gt; \n  bootstraps(times = 100, strata = \"disease\") \n\nsplits_boot\n\n# Bootstrap sampling using stratification \n# A tibble: 100 × 2\n   splits            id          \n   &lt;list&gt;            &lt;chr&gt;       \n 1 &lt;split [303/120]&gt; Bootstrap001\n 2 &lt;split [303/115]&gt; Bootstrap002\n 3 &lt;split [303/110]&gt; Bootstrap003\n 4 &lt;split [303/110]&gt; Bootstrap004\n 5 &lt;split [303/113]&gt; Bootstrap005\n 6 &lt;split [303/118]&gt; Bootstrap006\n 7 &lt;split [303/114]&gt; Bootstrap007\n 8 &lt;split [303/95]&gt;  Bootstrap008\n 9 &lt;split [303/112]&gt; Bootstrap009\n10 &lt;split [303/113]&gt; Bootstrap010\n# ℹ 90 more rows\n\n\n\n\nEverything else is the same!\n\n\nfits_lr_boot &lt;- xfun::cache_rds({\n  \n  logistic_reg() |&gt; \n    set_engine(\"glm\") |&gt; \n    fit_resamples(preprocessor = rec, resamples = splits_boot, \n                  metrics = metric_set(accuracy))\n\n}, \nrerun = FALSE,\ndir = \"cache/\",\nfile = \"u5-boot-2.rds\")\n\n\nmetrics_boot &lt;- collect_metrics(fits_lr_boot, summarize = FALSE)\n\nmetrics_boot |&gt; print_kbl()\n\n\n\n\n\nid\n.metric\n.estimator\n.estimate\n.config\n\n\n\n\nBootstrap001\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap002\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap003\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap004\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap005\naccuracy\nbinary\n0.70\nPreprocessor1_Model1\n\n\nBootstrap006\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nBootstrap007\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap008\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap009\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap010\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap011\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap012\naccuracy\nbinary\n0.72\nPreprocessor1_Model1\n\n\nBootstrap013\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap014\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nBootstrap015\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap016\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap017\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap018\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap019\naccuracy\nbinary\n0.85\nPreprocessor1_Model1\n\n\nBootstrap020\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap021\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nBootstrap022\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap023\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap024\naccuracy\nbinary\n0.72\nPreprocessor1_Model1\n\n\nBootstrap025\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap026\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap027\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nBootstrap028\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap029\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap030\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap031\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nBootstrap032\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap033\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap034\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap035\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap036\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap037\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap038\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nBootstrap039\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap040\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap041\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nBootstrap042\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap043\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap044\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nBootstrap045\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap046\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap047\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nBootstrap048\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap049\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap050\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap051\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nBootstrap052\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap053\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap054\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nBootstrap055\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap056\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap057\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap058\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nBootstrap059\naccuracy\nbinary\n0.82\nPreprocessor1_Model1\n\n\nBootstrap060\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap061\naccuracy\nbinary\n0.82\nPreprocessor1_Model1\n\n\nBootstrap062\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap063\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap064\naccuracy\nbinary\n0.83\nPreprocessor1_Model1\n\n\nBootstrap065\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap066\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap067\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap068\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap069\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap070\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap071\naccuracy\nbinary\n0.85\nPreprocessor1_Model1\n\n\nBootstrap072\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap073\naccuracy\nbinary\n0.85\nPreprocessor1_Model1\n\n\nBootstrap074\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap075\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap076\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap077\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap078\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap079\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap080\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap081\naccuracy\nbinary\n0.82\nPreprocessor1_Model1\n\n\nBootstrap082\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap083\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap084\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap085\naccuracy\nbinary\n0.76\nPreprocessor1_Model1\n\n\nBootstrap086\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap087\naccuracy\nbinary\n0.84\nPreprocessor1_Model1\n\n\nBootstrap088\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap089\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\nBootstrap090\naccuracy\nbinary\n0.82\nPreprocessor1_Model1\n\n\nBootstrap091\naccuracy\nbinary\n0.77\nPreprocessor1_Model1\n\n\nBootstrap092\naccuracy\nbinary\n0.80\nPreprocessor1_Model1\n\n\nBootstrap093\naccuracy\nbinary\n0.75\nPreprocessor1_Model1\n\n\nBootstrap094\naccuracy\nbinary\n0.81\nPreprocessor1_Model1\n\n\nBootstrap095\naccuracy\nbinary\n0.74\nPreprocessor1_Model1\n\n\nBootstrap096\naccuracy\nbinary\n0.73\nPreprocessor1_Model1\n\n\nBootstrap097\naccuracy\nbinary\n0.79\nPreprocessor1_Model1\n\n\nBootstrap098\naccuracy\nbinary\n0.82\nPreprocessor1_Model1\n\n\nBootstrap099\naccuracy\nbinary\n0.71\nPreprocessor1_Model1\n\n\nBootstrap100\naccuracy\nbinary\n0.78\nPreprocessor1_Model1\n\n\n\n\n\n\nmetrics_boot |&gt; plot_hist(\".estimate\", bins = 10)\n\n\n\ncollect_metrics(fits_lr_boot, summarize = TRUE)\n\n# A tibble: 1 × 6\n  .metric  .estimator  mean     n std_err .config             \n  &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 accuracy binary     0.779   100 0.00328 Preprocessor1_Model1\n\n\n\nYou should also refit a final model in the full data at the end as before to get final single fitted model for later use\n\n\nRelevant comparisons, strengths/weaknesses for bootstrap for resampling\n\nOur performance estimate will have higher bias than K-fold using typical K values (bias equivalent to about K = 2)\n\nAlthough training sets have full n, they only include about 63% unique observations. These models under perform training sets with 80 - 90% unique observations\nWith smaller training set sizes, this bias is considered too high by some (Kuhn)\n\nOur performance estimate will have less variance than K-fold\n\nCompare SE of accuracy for 100 resamples using k-fold with repeats: 0.0064837 vs. bootstrap: 0.0032754\nWith 1000 bootstraps (and test sets with ~ 37% of n) can get a very precise estimate of test error\n\nCan also represent the variance of our test error (like repeated K-fold)\nUsed primarily for selecting among model configurations when you don’t care about bias and just want a precise selection metric\n\nUseful in explanation scenarios where you just need the “best” model\n“Inner loop” of nested cross validation (more on this later)"
  },
  {
    "objectID": "005_resampling.html#using-resampling-to-select-best-model-configurations",
    "href": "005_resampling.html#using-resampling-to-select-best-model-configurations",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.10 Using Resampling to Select Best Model Configurations",
    "text": "5.10 Using Resampling to Select Best Model Configurations\nIn all of the previous examples, we have used various resampling methods only to evaluate the performance of a single model configuration in new data\nResampling is also used to select best models. Best means the model configuration that performs the best in new data and therefore is closest to the true DGP for the data\n\nFor example, we might want to select among model configurations in an explanatory scenario to have a principled approach to determine the model configuration that best matches the true DGP (and would be best to test your hypotheses). e.g.,\n\nSelecting covariates to include\nDeciding on X transformations\noutlier identification approach\nstatistical algorithm\n\nWe can simply evaluate each configuration using one of the previously described resampling methods\nWe would call the held-out data (the single set, the folds, the OOB samples) a validation set\nWe select the model configuration with the best mean across our resampled validation sets on the relevant performance metric.\n\n\nOne additional common scenario where you will do model selection across many model configurations is when “tuning” (picking) the best values for hyperparameters for a statistical algorithm (e.g., k in KNN).\n\\(tidymodels\\) makes this easy and it follows a very similar workflow as earlier with a few changes\n\nWe will need to indicate which hyperparameters we plan to tune in the statistic algorithm\nWe need (or can) select values to consider for that hyperparameter (or we can let the tune package functions decide in some cases)\nWe will now use tune_grid() rather fit_resamples() to fit and evaluate the models configurations that differ with respect to their hyperparameters\n\n\nLets use bootstrap resampling to select the best K for KNN applied to our heart disease dataset\n\nSplits are established as before\n\n\nset.seed(19690127)\nsplits_boot &lt;- data_all |&gt; \n  bootstraps(times = 100, strata = \"disease\") \n\n\nWe need a slightly different recipe for KNN vs. logistic regression\nWe have to range correct the numeric predictors\nNo need to do this to the dummy features. They are already range corrected\n\nrec &lt;- recipe(disease ~ ., data = data_all) |&gt; \n  step_string2factor(disease, levels = c(\"no\", \"yes\")) |&gt; \n  step_string2factor(all_nominal(), -all_outcomes()) |&gt;\n  step_impute_median(all_numeric()) |&gt; \n  step_impute_mode(all_nominal(), -all_outcomes()) |&gt;   \n  step_range(all_numeric()) |&gt; \n  step_dummy(all_nominal(), -all_outcomes())\n\n\n\nThe fitting process is what is different\n\n\nWe set up a tibble with values of the hyperparameters to consider\nWe indicate which hyperparameters need to be tuned\nModel configurations are fit using \\(tune\\_grid()\\) and\nUse fit_resamples()\n\nNo need to continue to remake features for train and test. Just provide splits and rec\nSet performance metrics with metric_set()\n\nDefault for classification is accuracy and area under ROC curve (discussed in later unit)\n\n\n\n\nhyper_grid &lt;- expand.grid(neighbors = seq(1, 202, by = 3))\nhyper_grid\n\n   neighbors\n1          1\n2          4\n3          7\n4         10\n5         13\n6         16\n7         19\n8         22\n9         25\n10        28\n11        31\n12        34\n13        37\n14        40\n15        43\n16        46\n17        49\n18        52\n19        55\n20        58\n21        61\n22        64\n23        67\n24        70\n25        73\n26        76\n27        79\n28        82\n29        85\n30        88\n31        91\n32        94\n33        97\n34       100\n35       103\n36       106\n37       109\n38       112\n39       115\n40       118\n41       121\n42       124\n43       127\n44       130\n45       133\n46       136\n47       139\n48       142\n49       145\n50       148\n51       151\n52       154\n53       157\n54       160\n55       163\n56       166\n57       169\n58       172\n59       175\n60       178\n61       181\n62       184\n63       187\n64       190\n65       193\n66       196\n67       199\n68       202\n\n\n\nfits_knn_boot &lt;- xfun::cache_rds({\n  \n  nearest_neighbor(neighbors = tune()) |&gt; \n    set_engine(\"kknn\") |&gt; \n    set_mode(\"classification\") |&gt;\n    tune_grid(preprocessor = rec, resamples = splits_boot, grid = hyper_grid,\n              metrics = metric_set(accuracy))\n\n},\nrerun = FALSE,\ndir = \"cache/\",\nfile = \"u5-tune-3.rds\")\n\n\n\nReviewing performance of model configurations is similar to before but now with multiple configurations\n\n\nWe can see the average performance over folds along with its standard error using summarize = TRUE\nWe could see the performance of each configuration in EACH fold too, but there are lots of them (use summarize = FALSE)\n\n\ncollect_metrics(fits_knn_boot, summarize = TRUE)\n\n# A tibble: 68 × 7\n   neighbors .metric  .estimator  mean     n std_err .config              \n       &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;                \n 1         1 accuracy binary     0.716   100 0.00411 Preprocessor1_Model01\n 2         4 accuracy binary     0.716   100 0.00411 Preprocessor1_Model02\n 3         7 accuracy binary     0.743   100 0.00371 Preprocessor1_Model03\n 4        10 accuracy binary     0.753   100 0.00358 Preprocessor1_Model04\n 5        13 accuracy binary     0.759   100 0.00362 Preprocessor1_Model05\n 6        16 accuracy binary     0.765   100 0.00349 Preprocessor1_Model06\n 7        19 accuracy binary     0.770   100 0.00343 Preprocessor1_Model07\n 8        22 accuracy binary     0.772   100 0.00318 Preprocessor1_Model08\n 9        25 accuracy binary     0.773   100 0.00327 Preprocessor1_Model09\n10        28 accuracy binary     0.775   100 0.00341 Preprocessor1_Model10\n# ℹ 58 more rows\n\n\n\nWe can plot average performance by the values of the hyperparameter\n\n\ncollect_metrics(fits_knn_boot, summarize = TRUE) |&gt; \n  ggplot(aes(x = neighbors, y = mean)) +\n    geom_line()\n\n\n\n\nK (neighbors) is affecting the bias-variance trade-off. As K increases, model bias increases but model variance decreases. In most instances, model variance decreases faster than model bias increases. Therefore performance should increase and then peak at a good point along the bias-variance trade-off. Beyond this optimal value, performance should decrease again. You want to select a hyperparameter value that is associated with peak (or near peak) performance.\n\nThe simplest way to select among model configurations (e.g., hyperparameters) is to choose the model configuration with the best performance\n\nshow_best(fits_knn_boot, n = 10)\n\n# A tibble: 10 × 7\n   neighbors .metric  .estimator  mean     n std_err .config              \n       &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;                \n 1       103 accuracy binary     0.786   100 0.00292 Preprocessor1_Model35\n 2       106 accuracy binary     0.786   100 0.00281 Preprocessor1_Model36\n 3       100 accuracy binary     0.786   100 0.00291 Preprocessor1_Model34\n 4       109 accuracy binary     0.785   100 0.00282 Preprocessor1_Model37\n 5        91 accuracy binary     0.785   100 0.00291 Preprocessor1_Model31\n 6        94 accuracy binary     0.785   100 0.00285 Preprocessor1_Model32\n 7        97 accuracy binary     0.785   100 0.00287 Preprocessor1_Model33\n 8        64 accuracy binary     0.785   100 0.00353 Preprocessor1_Model22\n 9        88 accuracy binary     0.785   100 0.00303 Preprocessor1_Model30\n10        67 accuracy binary     0.785   100 0.00342 Preprocessor1_Model23\n\nselect_best(fits_knn_boot)\n\n# A tibble: 1 × 2\n  neighbors .config              \n      &lt;dbl&gt; &lt;chr&gt;                \n1       103 Preprocessor1_Model35\n\n\nThe next most common is to choose the simplest (least flexible) model that has performance within one SE of the best performing configuration.\n\nUse select_by_one_std_err()\nSort performance results from least to most flexible (e.g., desc(neighbors))\n\n\nselect_by_one_std_err(fits_knn_boot, desc(neighbors))\n\n# A tibble: 1 × 9\n  neighbors .metric  .estimator  mean     n std_err .config               .best\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;                 &lt;dbl&gt;\n1       112 accuracy binary     0.784   100 0.00270 Preprocessor1_Model38 0.786\n  .bound\n   &lt;dbl&gt;\n1  0.784\n\n\n\n\nWe should also refit a final model with the “best” hyperparameter using the full data as before\nWe can use the select_*() from above to use this best hyperparameter in our specification of the algorithm\nNote that we now fit using all the data and switch to fit() rather than tune_grid()\nHowever, we can’t use the previous bootstrap resampling to evaluate this final/best model because we already used it to select this the best configuration\nWe need new, held-out data to evaluate it (a new test set!)\n\n\nfeat_all &lt;- rec |&gt; \n  make_features(data_all, data_all)\n\nRows: 303\nColumns: 18\n$ age                          &lt;dbl&gt; 0.7083333, 0.7916667, 0.7916667, 0.166666…\n$ rest_bp                      &lt;dbl&gt; 0.4811321, 0.6226415, 0.2452830, 0.339622…\n$ chol                         &lt;dbl&gt; 0.24429224, 0.36529680, 0.23515982, 0.283…\n$ max_hr                       &lt;dbl&gt; 0.6030534, 0.2824427, 0.4427481, 0.885496…\n$ exer_st_depress              &lt;dbl&gt; 0.37096774, 0.24193548, 0.41935484, 0.564…\n$ ca                           &lt;dbl&gt; 0.0000000, 1.0000000, 0.6666667, 0.000000…\n$ disease                      &lt;fct&gt; no, yes, yes, no, no, no, NA, no, yes, ye…\n$ sex_male                     &lt;dbl&gt; 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1,…\n$ cp_atyp_ang                  &lt;dbl&gt; 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1,…\n$ cp_non_anginal               &lt;dbl&gt; 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0,…\n$ fbs_yes                      &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,…\n$ rest_ecg_wave_abn            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ rest_ecg_ventric_hypertrophy &lt;dbl&gt; 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0,…\n$ exer_ang_yes                 &lt;dbl&gt; 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0,…\n$ exer_st_slope_flat           &lt;dbl&gt; 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0,…\n$ exer_st_slope_downslope      &lt;dbl&gt; 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,…\n$ thal_fixeddefect             &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,…\n$ thal_reversabledefect        &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1,…\n\nfit_knn_best &lt;-\n  nearest_neighbor(neighbors = select_best(fits_knn_boot)$neighbors) |&gt; \n  set_engine(\"kknn\") |&gt; \n  set_mode(\"classification\") |&gt;\n  fit(disease ~ ., data = feat_all)"
  },
  {
    "objectID": "005_resampling.html#resampling-for-both-model-selection-and-evaluation",
    "href": "005_resampling.html#resampling-for-both-model-selection-and-evaluation",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.11 Resampling for Both Model Selection and Evaluation",
    "text": "5.11 Resampling for Both Model Selection and Evaluation\nResampling methods can be used to select the best model configuration and/or evaluate model performance\n\nSo far we have done EITHER selection OR evaluation but not both together\nThe concepts to both select the best configuration and evaluation it are similar but it requires different (slightly more complicated) resampling than what we have done so far\nIf you use your held-out resamples to select the best model among a number of model configurations then the same held out resamples cannot also be used to evaluate the performance of that same best model\nIf it is, the performance metric will have ‘optimization bias’. To the degree that there is any noise (i.e., variance) in the measurement of performance, selecting the best model configuration will capitalize on this noise.\nYou need to use one set of held out resamples (validation sets) to select the best model. Then you need a DIFFERENT set of held out resamples (test sets) to evaluate that best model.\nThere are two strategies for this:\n\nStrategy 1: First, hold out a test set for final/best model evaluation. Then use one of the above resampling methods (single validation set approach, k-fold or bootstrap) to select the best model configuration. Bootstrap is likely best option b/c it is typically more precise (though biased)\nStrategy 2: Nested resampling. More on this in a moment\n\n\n\nOther Observations about Common Practices:\n\nSimple resampling methods with the full sample (and no held out test set) to both select AND evaluate are still common\nFailure by some (even Kuhn) to appreciate the degree of optimization bias\nParticular problem in Psychology because of small n (high variance in our performance metric)?\n\n\n5.11.1 Bootstrap with Test Set\n\nFirst we divide our data into training and test using inital_split()\nThen we use bootstrap resampling with the training set to select the best model (based on performance in the OOB validation sets)\nAfter we select the best model configuration using bootstrap in the training set\n\nWe refit that model configuration in the FULL training set\nAnd we evaluate it in the test set\n\nOf course, in the end, you will refit this final model configuration to the FULL dataset but the performance estimate will come from test only\n\n\n\nUse initial_split() for first train/test split\n\n\nset.seed(123456)\nsplits_test &lt;- data_all |&gt; \n  initial_split(prop = 2/3, strata = \"disease\")\n\ndata_trn &lt;- splits_test |&gt; \n  analysis()\n\ndata_test &lt;- splits_test |&gt; \n  assessment()\n\n\n\nUse training set for model selection via resampling (in this case bootstrap)\n\nNo need for another seed\n\nFit model configurations that vary by K in all 100 bootstrap samples\nMake predictions and calculate accuracy for these fitted models in 100 OOB (validation) sets\n\n\nsplits_boot &lt;- data_trn |&gt; \n  bootstraps(times = 100, strata = \"disease\") \n\nhyper_grid &lt;- expand.grid(neighbors = seq(1, 150, by = 3))\n\nfits_knn_boot &lt;-\n  nearest_neighbor(neighbors = tune()) |&gt; \n  set_engine(\"kknn\") |&gt; \n  set_mode(\"classification\") |&gt;\n  tune_grid(preprocessor = rec, resamples = splits_boot, grid = hyper_grid, metrics = metric_set(accuracy))\n\n\n\nSelect the best model configuration (best k)\n\nK = 37 is the best model configuration determined by bootstrap resampling\nBUT this is NOT the correct estimate of its performance in new data\nWe compared 50 model configurations (values of k). This performance estimate may have some optimization bias (though 50 model configurations is really not THAT many)\n\n\n\nshow_best(fits_knn_boot, n = 10)\n\n# A tibble: 10 × 7\n   neighbors .metric  .estimator  mean     n std_err .config              \n       &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;                \n 1        82 accuracy binary     0.785   100 0.00435 Preprocessor1_Model28\n 2        79 accuracy binary     0.784   100 0.00444 Preprocessor1_Model27\n 3        76 accuracy binary     0.784   100 0.00441 Preprocessor1_Model26\n 4        85 accuracy binary     0.784   100 0.00436 Preprocessor1_Model29\n 5        97 accuracy binary     0.783   100 0.00444 Preprocessor1_Model33\n 6        88 accuracy binary     0.783   100 0.00430 Preprocessor1_Model30\n 7       100 accuracy binary     0.783   100 0.00444 Preprocessor1_Model34\n 8        94 accuracy binary     0.783   100 0.00431 Preprocessor1_Model32\n 9        91 accuracy binary     0.783   100 0.00430 Preprocessor1_Model31\n10        73 accuracy binary     0.783   100 0.00439 Preprocessor1_Model25\n\n# show exact means\nshow_best(fits_knn_boot, n = 10)$mean\n\n [1] 0.7845982 0.7839465 0.7838609 0.7836905 0.7830307 0.7830151 0.7829868\n [8] 0.7828715 0.7828376 0.7825650\n\nselect_best(fits_knn_boot)\n\n# A tibble: 1 × 2\n  neighbors .config              \n      &lt;dbl&gt; &lt;chr&gt;                \n1        82 Preprocessor1_Model28\n\n\n\n\nFit the k = 37 model configuration in the full training set\n\n\nfeat_trn &lt;- rec |&gt; \n  make_features(data_trn, data_trn)\n\nRows: 201\nColumns: 18\n$ age                          &lt;dbl&gt; 0.7083333, 0.2500000, 0.5625000, 0.583333…\n$ rest_bp                      &lt;dbl&gt; 0.5204082, 0.3673469, 0.2653061, 0.265306…\n$ chol                         &lt;dbl&gt; 0.24429224, 0.17808219, 0.25114155, 0.520…\n$ max_hr                       &lt;dbl&gt; 0.5140187, 0.7196262, 0.7757009, 0.635514…\n$ exer_st_depress              &lt;dbl&gt; 0.52272727, 0.31818182, 0.18181818, 0.136…\n$ ca                           &lt;dbl&gt; 0.0000000, 0.0000000, 0.0000000, 0.000000…\n$ disease                      &lt;fct&gt; no, no, no, no, no, no, no, no, no, no, n…\n$ sex_male                     &lt;dbl&gt; 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0,…\n$ cp_atyp_ang                  &lt;dbl&gt; 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,…\n$ cp_non_anginal               &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1,…\n$ fbs_yes                      &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,…\n$ rest_ecg_wave_abn            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ rest_ecg_ventric_hypertrophy &lt;dbl&gt; 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,…\n$ exer_ang_yes                 &lt;dbl&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,…\n$ exer_st_slope_flat           &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0,…\n$ exer_st_slope_downslope      &lt;dbl&gt; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ thal_fixeddefect             &lt;dbl&gt; 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ thal_reversabledefect        &lt;dbl&gt; 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…\n\nfeat_test &lt;- rec |&gt; \n  make_features(data_trn, data_test)\n\nRows: 102\nColumns: 18\n$ age                          &lt;dbl&gt; 0.1666667, 0.5625000, 0.5625000, 0.479166…\n$ rest_bp                      &lt;dbl&gt; 0.3673469, 0.4693878, 0.3673469, 0.795918…\n$ chol                         &lt;dbl&gt; 0.28310502, 0.38356164, 0.29680365, 0.166…\n$ max_hr                       &lt;dbl&gt; 0.8598131, 0.5420561, 0.4392523, 0.626168…\n$ exer_st_depress              &lt;dbl&gt; 0.7954545, 0.2954545, 0.1363636, 0.113636…\n$ ca                           &lt;dbl&gt; 0.0000000, 0.0000000, 0.3333333, 0.000000…\n$ disease                      &lt;fct&gt; no, no, yes, no, yes, NA, no, NA, no, yes…\n$ sex_male                     &lt;dbl&gt; 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,…\n$ cp_atyp_ang                  &lt;dbl&gt; 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ cp_non_anginal               &lt;dbl&gt; 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,…\n$ fbs_yes                      &lt;dbl&gt; 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,…\n$ rest_ecg_wave_abn            &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ rest_ecg_ventric_hypertrophy &lt;dbl&gt; 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1,…\n$ exer_ang_yes                 &lt;dbl&gt; 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0,…\n$ exer_st_slope_flat           &lt;dbl&gt; 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1,…\n$ exer_st_slope_downslope      &lt;dbl&gt; 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ thal_fixeddefect             &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,…\n$ thal_reversabledefect        &lt;dbl&gt; 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1,…\n\nfit_knn_best &lt;-\n  nearest_neighbor(neighbors = select_best(fits_knn_boot)$neighbors) |&gt; \n  set_engine(\"kknn\") |&gt; \n  set_mode(\"classification\") |&gt;\n  fit(disease ~ ., data = feat_trn)\n\n\nUse that fitted model to predict into test set\n\n\naccuracy_vec(feat_test$disease, predict(fit_knn_best, feat_test)$.pred_class)\n\n[1] 0.7752809\n\n\n\nOur best estimate of how accurate a model with k = 82 would be in new data is 0.7752809. However, it was only fit with n = 203 (the training set). If we truly want the best model, we should now train once again with all of our data. This model would likely perform even better b/c it has &gt; n. However, we have no more new data to evaluate it!"
  },
  {
    "objectID": "005_resampling.html#nested-resampling",
    "href": "005_resampling.html#nested-resampling",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.12 Nested Resampling",
    "text": "5.12 Nested Resampling\nAnd now the final, mind-blowing extension!!!!!\nThe bootstrap resampling + test set approach to simultaneously select and evaluate models is commonly used\nHowever, it suffers from the same problems as the single validation set approach\n\nIt only uses a single small held out test set. In this case, 1/3 of the total sample size.\n\nThis will yield a high variance/imprecise estimate of model performance\n\nIt also yields a biased estimate of model performance\n\nThe model we evaluated in test was fit to only the training data which was only 2/3 of total sample size\nYet our true final model is trained with the full dataset\nWe are likely underestimating its true performance\n\n\nNested resampling offers an improvement with respect to these two issues\nNested resampling involves two loops\n\nThe inner loop is used for model selection\nThe outer loop is used for model evaluation\n\nNested resampling is VERY CONFUSING at first (like the first year you use it!)\nNested resampling isn’t fully supported by tidy models. You have to do some coding to iterate over the outer loop\nApplication of nested resampling is outside the scope of this course but you should understand it conceptually. For further reading on the implementation of this method, see an example provided by the tidymodels folks.\n\nA ‘simple’ example using bootstrap for inner loop and 10-fold CV for outer loop\n\nDivide the full sample into 10 folds\nIterate through those 10 folds as follows (this is the outer loop)\n\nHold out fold 1\nUse folds 2-10 to do the inner loop bootstrap\n\nBootstrap these folds B times\nFit models in B bootstrap samples\nCalculate selection performance metrics in B out-of-bag samples\nAverage the B bootstrapped selection performance metrics for each model configuration\nSelect the best model configuration using this average bootstrapped selection performance metric\n\nUse best model configuration from folds 2-10 to make predictions for the held-out fold 1 to get the first (of ten) evaluation performance metrics\nRepeat for held out fold 2 - 10\n\nAverage the 10 evaluation performance metrics. This is the expected performance of a best model configuration (selected by B bootstraps) in new data. [You still don’t know what configuration you should use because you have 10 ‘best’ model configurations]\nDo B bootstraps with the full sample to select the best model configuration\nFit this best model configuration to the full data\n\n\nNested resampling evaluates a fitting and selection process not a specific model configuration!\n\nYou therefore need to select a final model configuration using same resampling with full data\nYou then need to fit that new model configuration to the full data\nThat was the last two steps on the previous page\n\n\n\n\n\n\n\n\nQuestion: Why bootstrap on inner loop and k-fold on outer loop?\n\n\n\n\n\n\n\nShow Answer\nThe inner loop is used for selecting models.  Bootstrap yields low variance performance\nestimates (but they are biased).  We want low variance to select best model\nconfiguration.  K-fold is a good method for less biased performance estimates.  \nWe want less bias in our final evaluation of our best model.  You can do repeated\nK-fold in the outer loop to both reduce its variance and give you a sense of the\nperformance sampling distribution. BUT VERY COMPUTATIONALLY INTENSIVE"
  },
  {
    "objectID": "005_resampling.html#data-exploration-in-a-nested-world.",
    "href": "005_resampling.html#data-exploration-in-a-nested-world.",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.13 Data Exploration in a Nested World….",
    "text": "5.13 Data Exploration in a Nested World….\nFinal words on resampling:\n\nIterative methods (K-fold, bootstrap) are superior to single validation set approach wrt bias-variance trade-off in performance measurement\nK-Fold resampling should be used if you looking for a performance estimate of a single model configuration\nBootstrap resampling should be used if you are looking only to choose among model configurations but don’t need an independent assessment of that final model\nBootstrap resampling + Test set or Nested Resampling should be used when you plan to both select among model configurations AND evaluate the best model\nNested resampling must be handled very carefully wrt modeling EDA b/c it uses all the data\n\nCan use eyeball sample (10-20% of data) without much affect on performance measurement\nIf you plan to do a lot of exploration (e.g., lots of feature engineering and feature selection), you should probably use Bootstrap resampling + Test set"
  },
  {
    "objectID": "005_resampling.html#discussion",
    "href": "005_resampling.html#discussion",
    "title": "5  Resampling Methods for Model Selection and Evaluation",
    "section": "5.14 Discussion",
    "text": "5.14 Discussion\n\n5.14.1 and the winner is…..\nstudent      n correct_predictions accuracy\n   &lt;chr&gt;    &lt;int&gt;               &lt;dbl&gt;    &lt;dbl&gt;\n 1 vachuska   327                 262    0.801 (Karl)\n 2 hou        327                 257    0.786 (Lihao)\n 3 dubree     327                 256    0.783 (Will)\n 4 cheung     327                 253    0.774 (Alex)\n 5 stein      327                 253    0.774 (Andrea)\n 6 ma         327                 251    0.768 (Yuanxue)\n\n0.758\n0.755\n0.755\n0.734\n0.731\n0.716\n0.688\n0.676\n0.676\n\n\n5.14.2 Other announcements\n\nMid-term Exam\nI understand if this isn’t possible, but I’ve noticed that for the most part, only TAs and John respond to errors in Slack, which is fine but creates more work for them. Maybe if there was more motivation (like extra credit) or something to answer people’s questions in the Slack, more people might do it?\nMidnight deadlines? 8 pm?\nIt would be great if there was any easy way to download each section of the web book in a format that could be annotated\nCan you upload previous videos (unit 1 - 3) to uw-madison site? As second language student, subtitles are really helpful.\n\n\n\n5.14.3 Questions\n\nResampling methods to EITHER select best model OR evaluate best model\n\nSingle validation set\nLOOCV\nK-fold\nRepeated k-fold\nBootstrap\nALSO: grouped k-fold\n\nWhat about when we need to do both selection and evaluation?\n\nWhat is optimization bias?\nCombine above method with held out test set\nNested CV (see tutorial)\n\nModel selection by resampling to “tune” hyperparameters\nModel selection by resampling for explanatory purposes\nData leakage\nHow does parallel processing work?\n\n\n\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2023. An Introduction to Statistical Learning: With Applications in R. 2nd ed. Springer Texts in Statistics. New York: Springer-Verlag.\n\n\nKuhn, Max, and Kjell Johnson. 2018. Applied Predictive Modeling. 1st ed. 2013, Corr. 2nd printing 2018 edition. New York: Springer."
  }
]