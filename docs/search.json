[
  {
    "objectID": "index.html#course-syllabus",
    "href": "index.html#course-syllabus",
    "title": "Introduction to Applied Machine Learning",
    "section": "Course Syllabus",
    "text": "Course Syllabus\n\nInstructor\nJohn Curtin\n\nOffice hours: Thursdays, 1-2 pm or by appointment in Brogden 326\nEmail: jjcurtin@wisc.edu (but please use Slack DM or channel posts for all course communications during this semester)\n\n\n\nTeaching Assistants\nMichelle Marji\n\nOffice hours: Wednesdays, 10-11 am in Brogden 391 or by appointment\nEmail: michelle.marji@wisc.edu\n\nKendra Wyant\n\nOffice hours: Mondays, 2:30-3:30 pm in Brodgen 325 or by appointment\nEmail: kpaquette2@wisc.edu\n\n\n\nCourse Website\nhttps://jjcurtin.github.io/book_iaml/\n\n\nCommunications\nAll course communications will occur in the course’s Slack workspace (https://iaml-2024.slack.com/). You should have received an invitation to join the workspace. If you have difficulty joining, please contact me by my email above. The TAs and I will respond to all Slack messages within 1 business day (and often much quicker). Please plan accordingly (e.g., weekend messages may not receive a response until Monday). For general questions about class, coding assignments, etc., please post the question to the appropriate public channel. If you have the question, you are probably not alone. For issues relevant only to you (e.g., class absences, accommodations, etc.), you can send a direct message in Slack to me. However, I may share the DM with the TAs unless you request otherwise. In general, we prefer that all course communication occur within Slack rather than by email so that it is centralized in one location.\n\n\nMeeting Times\nThe scheduled course meeting times are Tuesdays and Thursdays from 11:00 - 12:15 pm. Tuesdays are generally used by the TAs to discuss application issues from the homework or in the course more generally. Thursdays are generally led by John and used to discuss topics from the video lectures and readings.\nAll required videos, readings, and application assignments are described on the course website at the beginning of each unit.\n\n\nCourse Description\nThis course is designed to introduce students to a variety of computational approaches in machine learning. The course is designed with two key foci. First, students will focus on the application of common, “out-of-the-box” statistical learning algorithms that have good performance and are implemented in tidymodels in R. Second, students will focus on the application of these approaches in the context of common questions in behavioral science in academia and industry.\n\n\nRequisites\nStudents are required to have completed Psychology 610 with a grade of B or better or a comparable course with my consent.\n\n\nLearning Outcomes\n\nStudents will develop and refine best practices for data wrangling, general programming, and analysis in R.\nStudents will distinguish among a variety of machine learning settings: supervised learning vs. unsupervised learning, regression vs. classification\nStudents will be able to implement a broad toolbox of well-supported machine-learning methods: decision trees, nearest neighbor, general and generalized linear models, penalized models including ridge, lasso, and elastic-nets, neural nets, random forests.\nStudents will develop expertise with common feature extraction techniques for quantitative and categorical predictors.\nStudents will be able to use natural language processing approaches to extract meaningful features from text data.\nStudents will know how to characterize how well their regression and classification models perform and they will employ appropriate methodology for evaluating their: cross validation, ROC and PR curves, hypothesis testing.\nStudents will learn to apply their skills to common learning problems in psychology and behavioral sciences more generally.\n\n\n\nCourse Topics\n\nOverview of Machine Learning Concepts and Uses\nData wrangling in R using tidyverse and tidymodels\nIterations, functions, simulations in R\nRegression models\nClassification models\nModel performance metrics\nROCs\nCross validation and other resampling methods\nModel selection and regularization\nApproaches to parallel processing\nFeature engineering techniques\nNatural language processing\nTree based methods\nBagging and boosting\nNeural networks\nDimensionality reduction and feature selection\nExplanatory methods including variable importance, partial dependence plots, etc\nEthics and privacy issues\n\n\n\nSchedule\nThe course is organized around 14 weeks of academic instruction covering the following topics:\n\nIntroduction to course and machine learning\nExploratory data analysis\nRegression models\nClassification models\nResampling methods for model selection and evaluation\nRegularization and penalized models\nMidterm exam/project\nModel comparisons\nAdvanced performance metrics\nAdvanced models: Random forests and ensemble methods (bagging, boosting, stacking)\nAdvanced models: Neural networks\nNatural Language Processing I: Text processing and feature engineering\nApplications\nEthics\n\n\nThe final exam is during exam week on Tuesday May 7th from 11 - 12:15 in our normal classroom.\nThe final project is due during exam week on Wednesday May 8th at 8 pm.\n\n\n\nRequired Textbooks and Software\nAll required textbooks are freely available online (though hard copies can also be purchased if desired). There are eight required textbooks for the course. The primary text for which we will read many chapters is:\n\nJames, G., Witten, D., Hastie, T., & Tibshirani, R. An Introduction to Statistical Learning: With Applications in R (2023; 2nd Edition). (website)\n\nWe will also read sections to chapters in each of the following texts:\n\nWickham, H. & Grolemund, G. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (1st ed.). Sebastopol, CA: O’Reilly Media, Inc. (website)\nHvitfeldt, E. & Silge, J. Supervised Machine Learning for Text Analysis in R (website)\nKuhn, M. & Johnson, K. Applied Predictive Modeling. New York, NYL Springer Science. (website)\nKuhn, M., & Johnson, K. Feature Engineering and Selection: A Practical Approach for Predictive Models (1st ed.). Boca Raton, FL: Chapman and Hall/CRC. (website)\nKuhn, M. & Silge, J. Tidy Modeling with R. (website)\nMolnar, C. Intepretable Machine Learning: A Guide for Makiong Black Box Models Explainable (2nd ed.). (website\nSilge, J., & Robinson, D. Text Mining with R: A Tidy Approach (1st ed.). Beijing; Boston: O’Reilly Media. (website)\nWickham, H. The Tidy Style Guide. (website)\nBoehmke, Brad and Greenwell, Brandon M. (2019). Hands-On Machine Learning with R. Chapman and Hall/CRC. (website)\nNg, Andrew (2018). Machine Learning Yearning: Technical Strategy for AI Engineers in the Age of Deep Learning. DeepLearning.AI. (website)\nWickham, H. (2019). Advanced R. Chapman and Hall/CRC. (website)\n\nAdditional articles will be assigned and provided by pdf through the course website.\nAll data processing and analysis will be accomplished using R (and we recommend the RStudio IDE). R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS.\n\n\nGrading\n\nQuizzes (13 anticipated): 15%\nApplication assignments (11 anticipated): 25%\nMidterm application exam: 15%\nMidterm conceptual exam: 15%\nFinal application exam: 15%\nFinal conceptual exam: 15%\n\nFinal letter grades may be curved upward, but a minimum guarantee is made of an A for 93 or above, AB for 88 - 92, B for 83 - 87, BC for 78 - 82, C for 70 - 77, D for 60-69, and F for &lt; 60.\n\n\nExams, Application Assignments and Quizzes\n\nThe midterm application exam will be due during the 7th week of the course on Wednesday, March 6th at 8 pm.\nThe midterm conceptual exam will be administered during class on Thursday, March 7th.\nThe final exam is during exam week on Tuesday May 7th from 11 - 12:15 in our normal classroom.\nThe final project is due during exam week on Wednesday May 8th at 8 pm.\nApproximately weekly quizzes will be administered through Canvas and due each Wednesday at 8 pm\nApproximately weekly application assignments will be submitted via Canvas and due each Wednesday at 8 pm.\n\n\n\nApplication Assignments\nThe approximately weekly application assignments are due on Wednesdays at 8 pm through Canvas. These assignments are to be done individually. Please do not share answers or code. You are also encouraged to make use of online resources (e.g., stack overflow) for assistance. All assignments will be completed using R markdown to provide both the code and documentation as might be provided to your mentor or employer to fully describe your solution. Late assignments are not accepted because problem solutions are provided immediately after the due date. Application assignments are graded on a three-point scale (0 = not completed, 1 = partially completed and/or with many errors, 2 = fully completed and at least mostly correct). Grades for each assignment will be posted by the following Monday at the latest.\n\n\nChatGPT\nI suspect you have all seen discussions of all that ChatGPT can do by now and its impact on teaching and assessment. I believe that AI like ChatGPT will eventually become an incredible tool for data scientists and programmers. As such, I view these advances with excitement. Of course, I don’t plan to assign a grade to ChatGPT so I want to make sure that we are clear on when you can and when you cannot use it. Given that I expect AI like ChatGPT to become a useful tool in our workflow as professionals, now is the time to start to learn how it can help. Therefore, you are free to use it during any of our application assignments AND the application questions on the mid-term and final exams. Code from ChatGPT is unlikely to be sufficient in either context (and my testing suggests it can be flat out wrong in some instances!) but I suspect that it will still be useful. In contrast, you CAN NOT use ChatGPT to answer the conceptual questions on the two exams or the weekly quizzes. Those questions are designed to assess your working knowledge about concepts and best practices. That information must be in YOUR head. I am not yet certain how I will administer that part of those exams (in class vs. HonorLock), but I wanted to be 100% clear that use of ChatGPT to answer those questions will be considered cheating and handled as such if detected. There will be a zero tolerance policy for such cheating. It will be reported to the Dean of Students on first offense.\n\n\nStudent Ethics\nThe members of the faculty of the Department of Psychology at UW-Madison uphold the highest ethical standards of teaching and research. They expect their students to uphold the same standards of ethical conduct. By registering for this course, you are implicitly agreeing to conduct yourself with the utmost integrity throughout the semester.\nIn the Department of Psychology, acts of academic misconduct are taken very seriously. Such acts diminish the educational experience for all involved – students who commit the acts, classmates who would never consider engaging in such behaviors, and instructors. Academic misconduct includes, but is not limited to, cheating on assignments and exams, stealing exams, sabotaging the work of classmates, submitting fraudulent data, plagiarizing the work of classmates or published and/or online sources, acquiring previously written papers and submitting them (altered or unaltered) for course assignments, collaborating with classmates when such collaboration is not authorized, and assisting fellow students in acts of misconduct. Students who have knowledge that classmates have engaged in academic misconduct should report this to the instructor.\n\n\nDiversity and Inclusion\nInstitutional statement on diversity: “Diversity is a source of strength, creativity, and innovation for UW-Madison. We value the contributions of each person and respect the profound ways their identity, culture, background, experience, status, abilities, and opinion enrich the university community. We commit ourselves to the pursuit of excellence in teaching, research, outreach, and diversity as inextricably linked goals.\nThe University of Wisconsin-Madison fulfills its public mission by creating a welcoming and inclusive community for people from every background – people who as students, faculty, and staff serve Wisconsin and the world.” https://diversity.wisc.edu/\n\n\nAcademic Integrity\nBy enrolling in this course, each student assumes the responsibilities of an active participant in UW-Madison’s community of scholars in which everyone’s academic work and behavior are held to the highest academic integrity standards. Academic misconduct compromises the integrity of the university. Cheating, fabrication, plagiarism, unauthorized collaboration, and helping others commit these acts are examples of academic misconduct, which can result in disciplinary action. This includes but is not limited to failure on the assignment/course, disciplinary probation, or suspension. Substantial or repeated cases of misconduct will be forwarded to the Office of Student Conduct & Community Standards for additional review. For more information, refer to http://studentconduct.wiscweb.wisc.edu/academic-integrity\n\n\nAccommodations Polices\nMcBurney Disability Resource Center syllabus statement: “The University of Wisconsin-Madison supports the right of all enrolled students to a full and equal educational opportunity. The Americans with Disabilities Act (ADA), Wisconsin State Statute (36.12), and UW-Madison policy (Faculty Document 1071) require that students with disabilities be reasonably accommodated in instruction and campus life. Reasonable accommodations for students with disabilities is a shared faculty and student responsibility. Students are expected to inform faculty [me] of their need for instructional accommodations by the end of the third week of the semester, or as soon as possible after a disability has been incurred or recognized. Faculty [I], will work either directly with the student [you] or in coordination with the McBurney Center to identify and provide reasonable instructional accommodations. Disability information, including instructional accommodations as part of a student’s educational record, is confidential and protected under FERPA.” http://mcburney.wisc.edu/facstaffother/faculty/syllabus.php\nUW-Madison students who have experienced sexual misconduct (which can include sexual harassment, sexual assault, dating violence and/or stalking) also have the right to request academic accommodations. This right is afforded them under Federal legislation (Title IX). Information about services and resources (including information about how to request accommodations) is available through Survivor Services, a part of University Health Services: https://www.uhs.wisc.edu/survivor-services/\n\n\nComplaints\nOccasionally, a student may have a complaint about a TA or course instructor. If that happens, you should feel free to discuss the matter directly with the TA or instructor. If the complaint is about the TA and you do not feel comfortable discussing it with the individual, you should discuss it with the course instructor. Complaints about mistakes in grading should be resolved with the TA and/or instructor in the great majority of cases. If the complaint is about the instructor (other than ordinary grading questions) and you do not feel comfortable discussing it with the individual, make an appointment to speak to the Associate Chair for Graduate Studies, Professor Shawn Green, cshawngreen@wisc.edu.\nIf you have concerns about climate or bias in this class, or if you wish to report an incident of bias or hate that has occurred in class, you may contact the Chair of the Department, Professor Allyson Bennett (allyson.j.bennett@wisc.edu) or the Chair of the Psychology Department Climate & Diversity Committee, Martha Alibali (martha.alibali@wisc.edu). You may also use the University’s bias incident reporting system\n\n\nPrivacy of Student Information & Digital Tools\nThe privacy and security of faculty, staff and students’ personal information is a top priority for UW-Madison. The university carefully reviews and vets all campus-supported digital tools used to support teaching and learning, to help support success through learning analytics, and to enable proctoring capabilities. UW-Madison takes necessary steps to ensure that the providers of such tools prioritize proper handling of sensitive data in alignment with FERPA, industry standards and best practices. Under the Family Educational Rights and Privacy Act (FERPA which protects the privacy of student education records), student consent is not required for the university to share with school officials those student education records necessary for carrying out those university functions in which they have legitimate educational interest. 34 CFR 99.31(a)(1)(i)(B). FERPA specifically allows universities to designate vendors such as digital tool providers as school officials, and accordingly to share with them personally identifiable information from student education records if they perform appropriate services for the university and are subject to all applicable requirements governing the use, disclosure and protection of student data.\n\n\nPrivacy of Student Records & the Use of Audio Recorded Lectures\nSee information about privacy of student records and the usage of audio-recorded lectures.\nLecture materials and recordings for this course are protected intellectual property at UW-Madison. Students in this course may use the materials and recordings for their personal use related to participation in this class. Students may also take notes solely for their personal use. If a lecture is not already recorded, you are not authorized to record my lectures without my permission unless you are considered by the university to be a qualified student with a disability requiring accommodation. [Regent Policy Document 4-1] Students may not copy or have lecture materials and recordings outside of class, including posting on internet sites or selling to commercial entities. Students are also prohibited from providing or selling their personal notes to anyone else or being paid for taking notes by any person or commercial firm without the instructor’s express written permission. Unauthorized use of these copyrighted lecture materials and recordings constitutes copyright infringement and may be addressed under the university’s policies, UWS Chapters 14 and 17, governing student academic and non-academic misconduct.\n\n\nAcademic Calendar & Religious Observances\nStudents who wish to inquire about religious observance accommodations for exams or assignments should contact the instructor within the first two weeks of class, following the university’s policy on religious observance conflicts"
  },
  {
    "objectID": "001_overview.html#overview-of-unit",
    "href": "001_overview.html#overview-of-unit",
    "title": "1  Overview of Machine Learning",
    "section": "1.1 Overview of Unit",
    "text": "1.1 Overview of Unit\nLearning Objectives\n\nUnderstand uses for machine learning models\nBecome familiar with key terminology (presented in bold throughout this unit)\nUnderstand differences between models\n\nSupervised vs. unsupervised\nRegression vs. classification\nOptions for statistical algorithms\nFeatures vs. predictors\n\nRelationships between:\n\nData generating processes\nStatistical algorithms\nModel flexibility\nModel interpretability\nPrediction vs. explanation\n\nUnderstand Bias-Variance Trade-off\n\nReducible and irreducible error\nWhat is bias and variance?\nWhat affects bias and variance?\nWhat is overfitting and how does it relate to bias, variance, and also p-hacking\nUse of training and test sets to assess bias and variance\n\n\nReadings\n\nPSY 752 course syllabus\nJames et al. (2023) Chapter 2, pp 15 - 42\nYarkoni and Westfall (2017) paper\n\nLecture & Discussion Videos\n\nLecture 1: Overview; ~ 40 mins\nLecture 2: Terminology; ~ 19 mins\nLecture 3: An Empirical Example; ~ 28 mins\nDiscussion\n\nPost questions/discuss readings or lectures in Slack\nThe unit quiz is due by 8 pm on Wednesday January 24th"
  },
  {
    "objectID": "001_overview.html#an-introductory-framework-for-machine-learning",
    "href": "001_overview.html#an-introductory-framework-for-machine-learning",
    "title": "1  Overview of Machine Learning",
    "section": "1.2 An Introductory Framework for Machine Learning",
    "text": "1.2 An Introductory Framework for Machine Learning\nMachine (Statistical) learning techniques have developed in parallel in statistics and computer science\nTechniques can be coarsely divided into supervised and unsupervised approaches\n\nSupervised approaches involve models that predict an outcome using features\nUnsupervised approaches involve finding structure (e.g., clusters, factors) among a set of variables without any specific outcome specified\nHowever supervised approaches often use unsupervised approaches in early stages as part of feature engineering\nThis course will focus primarily on supervised machine learning problems\n\nExamples of supervised approaches include:\n\nPredicting relapse day-by-day among recovering patients with substance use disorders based on cellular communications and GPS.\nScreening someone as positive or negative for substance use disorder based on their Facebook activity\nPredicting the sale price of a house based on characteristics of the house and its neighborhood\n\nExamples of unsupervised approaches include:\n\nDetermining the factor structure of a set of personality items\nIdentifying subgroups among patients with alcohol use disorder based on demographics, use history, addiction severity, and other patient characteristics\nIdentifying the common topics present in customer reviews of some new product or app\n\n\nSupervised machine learning approaches can be categorized as either regression or classification techniques\n\nRegression techniques involve numeric (quantitative) outcomes. Regression techniques are NOT limited to regression or the general linear model. There are many more types of statistical models that are appropriate for numeric outcomes.\nClassification techniques involve nominal (categorical) outcomes.\nMost regression and classification techniques can handle categorical predictors\n\nAmong the earlier supervised model examples, predicting sale price was a regression technique and screening individuals as positive or negative for substance use disorder was a classification technique"
  },
  {
    "objectID": "001_overview.html#more-details-on-supervised-techniques",
    "href": "001_overview.html#more-details-on-supervised-techniques",
    "title": "1  Overview of Machine Learning",
    "section": "1.3 More Details on Supervised Techniques",
    "text": "1.3 More Details on Supervised Techniques\nFor supervised machine learning problems, we assume \\(Y\\) (outcome) is a function of some data generating process (DGP, \\(f\\)) involving a set of Xs (features) plus the addition of random error (\\(\\epsilon\\)) that is independent of X and with mean of 0\n\\(Y = f(X) + \\epsilon\\)\n\nTerminology sidebar: Throughout the course we will distinguish between the raw predictors available in a dataset and the features that are derived from those raw predictors through various transformations.\n\nWe estimate \\(f\\) (the DGP) for two main reasons: prediction and/or inference (i.e., explanation per Yarkoni and Westfall, 2017)\n\\(\\hat{Y} = \\hat{f}(X)\\)\nFor prediction, we are most interested in the accuracy of \\(\\hat{Y}\\) and typically treat \\(\\hat{f}\\) as a black box\nFor inference, we are typically interested in the way that \\(Y\\) is affected by \\(X\\)\n\nWhich predictors are associated with \\(Y\\)?\nWhat is the relationship between the outcome and the features associated with each predictor. Is the overall relationship between a predictor and Y positive, negative, dependent on other predictors? What is the shape of relationship (e.g., linear or more complex)?\nDoes the model as a whole improve prediction beyond a null model (no features from predictors) or beyond a compact model?\nWe care about good (low error) predictions even when we care about inference (we want small \\(\\epsilon\\))\n\nParameter estimates from models that don’t predict well may be incorrect or at least imprecise\nThey will also be tested with low power\n\n\n\nModel error includes both reducible and irreducible error.\n\nIf we consider both \\(X\\) and \\(\\hat{f}\\) to be fixed, then:\n\n\\(E(Y - \\hat{Y})^2 = (f(X) + \\epsilon - \\hat{f}(X))^2\\)\n\\(E(Y - \\hat{Y})^2 = [f(X) - \\hat{f}(X)]^2 + Var(\\epsilon)\\)\n\n\\([f(X) - \\hat{f}(X)]^2\\) is reducible and \\(Var(\\epsilon)\\) is irreducible\nIrreducible error results from other important \\(X\\) that we fail to measure and from measurement error in \\(X\\) and \\(Y\\)\nIrreducible error serves as an (unknown) bounds for model accuracy (without collecting additional Xs)\nReducible error results from a mismatch between \\(\\hat{f}\\) and the true \\(f\\)\n\nThis course will focus on techniques to estimate \\(f\\) with the goal of minimizing reducible error\n\n\n1.3.1 How Do We Estimate \\(f\\)?\nTo estimate \\(f\\):\n\nWe need a sample of \\(n\\) observations of \\(Y\\) and \\(X\\) that we will call our training set\nThere are two types of statistical algorithms that we can use for \\(\\hat{f}\\):\n\nParametric algorithms\nNon-parametric algorithms\n\n\n\nParametric algorithms:\n\nFirst, make an assumption about the functional form or shape of \\(f\\).\n\nFor example, the general linear model assumes: \\(f(X) = \\beta_0 + \\beta_1*X_1 + \\beta_2*X2 + ... + \\beta_p*X_p\\)\nNext, a model using that algorithm is fit to the training set. In other words, the parameter estimates (e.g., \\(\\beta_0, \\beta_1\\)) are derived to minimize some cost function (e.g., mean squared error for the linear model)\nParametric algorithms reduce the problem of estimating \\(f\\) down to one of only estimating some set of parameters for a chosen model\nParametric algorithms often yield more interpretable models\nBut they are often not very flexible. If you chose the wrong algorithm (shape for \\(\\hat{f}\\) that does not match \\(f\\)) the model will not fit well in the training set (and more importantly not in the new test set either)\n\nTerminology sidebar: A training set is a subset of your full dataset that is used to fit a model. In contrast, a validation set is a subset that has not been included in the training set and is used to select a best model from among competing model configurations. A test set is a third subset of the full dataset that has not been included in either the training or validation sets and is used for evaluating the performance of your fitted final/best model.\n\nNon-parametric algorithms:\n\nDo not make any assumption about the form/shape of \\(f\\)\nCan fit well for a wide variety of forms/shapes for \\(f\\)\nThis flexibility comes with costs\n\nThey generally require larger n in the training set than parametric algorithms to achieve comparable performance\nThey may overfit the training set (low error in training set but much higher error in new validation or test sets)\nThey are often less interpretable\n\n\n\nGenerally:\n\nFlexibility and interpretability are inversely related\nModels need to be flexible enough to fit \\(f\\) well\nAdditional flexibility beyond this can produce overfitting\nParametric algorithms are generally less flexible than non-parametric algorithms\nParametric algorithms can become more flexible by increasing the number of features (\\(p\\) from 610/710; e.g., using more predictors, more complex, non-linear forms to when deriving features from predictors)\nParametric algorithms can be made less flexible through regularization. There are techniques to make some non-parametric algorithms less flexible as well\nYou want the sweet spot for prediction. You may want even less flexible for inference in increase interpretability.\n\n\n\n\n\n1.3.2 How Do We Assess Model Performance?\nThere is no universally best statistical algorithm\n\nDepends on the true \\(f\\) and your goal (prediction or inference)\nWe often compare multiple statistical algorithms (various parametric and non-parametric options) and model configurations more generally (combinations of different algorithms with different sets of features)\nWhen comparing models/configurations, we need to both fit these models and then select the best one\n\n\nBest needs to be defined with respect to some performance metric in new (validation or test set) data\n\nThere are many performance metrics you might use\nRoot Mean squared error (RMSE) is common for regression problems\nAccuracy is common for classification problems\n\nWe will learn many other performance metrics in a later unit\n\nTwo types of performance problems are typical\n\nModels are underfit if they don’t adequately represent the true \\(f\\), typically because they have oversimplied the relationship (e.g., linear function fit to quadratic DGP, missing key interaction terms)\n\nThis models will yield biased predictions. In other words, they will systematically either under-predict or over-predict \\(Y\\) in some regions of the function.\nBiased models will perform poorly in both training and test sets\n\nModels are overfit if they are too flexible and begin to fit the noise in the training set.\n\nThese models will perform well (too well actually) in the training set but poorly in test or validation sets\nThey will show high variance such that the model and its predictions change drastically depending on the training set where it is fit\n\n\n\nMore generally, these problems and their consequences for model performance are largely inversely related\n\nThis is known as the Bias-Variance trade-off\nWe previously discussed reducible and irreducible error\n\nReducible error can be parsed into components due to bias and variance\nGoal is to minimize the sum of bias and variance error (i.e., the reducible error overall)\nWe will often trade off a little bias if it provides a big reduction in variance"
  },
  {
    "objectID": "001_overview.html#key-terminology-in-context",
    "href": "001_overview.html#key-terminology-in-context",
    "title": "1  Overview of Machine Learning",
    "section": "1.4 Key Terminology in Context",
    "text": "1.4 Key Terminology in Context\nMachine learning has emerged in parallel from developments in statistics and computer science. As a result, there is a lot of terminology and often multiple terms used for the same concept. This is not my fault! However, to help us avoid confusion, I will try to use one set of terms. In the following paragraphs, I identify these key terms in context (along with other synonymous terms used by others) and highlight them in bold.\nThere are two broad approaches in machine learning - unsupervised and supervised approaches. This course focuses primarily on developing supervised models.\n\nDeveloping a supervised machine learning model to predict or explain an outcome (also called DV, label, output) typically entails:\n\nFitting models with multiple candidate model configurations\nAssessing each model and selecting a best configuration\nEvaluating how well a model with that best configuration will perform with new observations.\n\n\nCandidate model configurations can vary with respect to the statistical algorithm used. Statistical algorithms can be coarsely categorized as parametric or non-parametric. But we will mostly focus on a more granular description of the specific algorithm itself (e.g., linear model, generalized linear model, multi-level linear model, elastic net, LASSO, ridge regression, neural network, KNN, random forest).\nThe set of candidate model configurations often includes variations of the same statistical algorithm with different hyperparameter (also called tuning parameter) values that control aspects of the algorithm’s operation. For example, the hyperparameter lambda controls the degree of regularization in penalized regression algorithms such as LASSO, ridge and elastic net. We will learn more about hyperparameters and their effects later in this course.\nThe set of candidate model configurations can vary with respect to the features that are included. A recipe describes how to transform raw data for predictors (also called IVs) into features (also called regressors, inputs) that are included in the feature matrix (also called design matrix, model matrix). This process of transforming predictors into features in a feature matrix is called feature engineering.\nCrossing variation on statistical algorithms, hyperparameter values, and alternative sets of features can increase the number of candidate model configurations dramatically; developing a machine learning model can easily involve fitting thousands of model configurations. In most implementations of machine learning, the number of candidate model configurations nearly ensures that some fitted models will overfit the dataset in which they are developed such that they capitalize on noise that is unique to the dataset in which they were fit. For this reason, model configurations are assessed and selected on the basis of their relative performance for new data (observations that were not involved in the fitting process).\n\nWe have ONE full dataset but we use resampling techniques to form subsets of that dataset to enable us to assess models’ performance in new data. Cross-validation and bootstrapping are both examples of classes of resampling techniques that we will learn in this course. Broadly, resampling techniques create multiple subsets of data random samples that consist of subsets of the full dataset. These different subsets can be used for model fitting, model selection, and model evaluation.\nTraining sets are subsets that are used for model fitting (also called model training). During model fitting, models with each candidate model configuration are fit to the data in the training set. For example, during fitting, model parameters are estimated for regression algorithms, and weights are established for neural network algorithms. Some non-parametric algorithms, like k-nearest neighbors, do not estimate parameters but simply “memorize” the training sets for subsequent predictions.\nValidation sets are subsets that are used for model selection (or, more accurately, for model configuration selection). During model selection, each (fitted) model — one for every candidate model configuration — is used to make predictions for observations in a validation set that, importantly, does not overlap with the model’s training set. On the basis of each model’s performance in the validation set, the relatively best model configuration (i.e., the configuration of the model that performs best relative to all other model configurations) is identified and selected. If you have only one model configuration, validation set(s) are not needed because there is no need to select among model configurations.\nTest sets are subsets that are used for model evaluation. Generally, a model with the previously identified best configuration is re-fit to all available data other than the test set. This fitted model is used to predict observations in the test set to estimate how well this model is expected to perform for new observations."
  },
  {
    "objectID": "001_overview.html#an-example-of-underfitting-overfitting-and-the-bias-variance-trade-off",
    "href": "001_overview.html#an-example-of-underfitting-overfitting-and-the-bias-variance-trade-off",
    "title": "1  Overview of Machine Learning",
    "section": "1.5 An Example of Underfitting, Overfitting and the Bias-Variance Trade-off",
    "text": "1.5 An Example of Underfitting, Overfitting and the Bias-Variance Trade-off\n\n1.5.1 Overview of Example\nThe concepts of underfitting vs. overfitting and the bias-variance trade-off are critical to understand\n\nIt is also important to understand how model flexibility can affect both the bias and variance of that model’s performance\nIt can help to make these abstract concepts concrete by exploring real models that are fit in actual data\nWe will conduct a very simple simulation to demonstrate these concepts\n\nThe code in this example is secondary to understanding the concepts of underfittinng, overfitting, bias, variance, and the bias-variance trade-off\n\nWe will not display much of it so that you can maintain focus on the concepts\nYou will have plenty of time to learn the underlying\n\n\nWhen modeling, our goal is typically to approximate the data generating process (DGP) as close as possible, but in the real world we never know the true DGP.\nA key advantage of many simulations is that we do know the DGP because we define it ourselves.\n\nFor example, in this simulation, we know that y is a cubic function of x and noise (random error).\nIn fact, we know the exact equation for calculating y as a function of x.\n\n\\(y = 1100 - 4.0 * x - 0.4 * x^2 + 0.1 * (x - h)^3 + noise\\), where:\n\nb0 = 1100\nb1 = -4.0\nb2 = -0.4\nb3 = 0.1\nh = -20.0\nnoise has mean = 0 and sd = 150\n\n\n\nWe will attempt to model this cubic DGP with three different model configurations\n\nA simple linear model that uses only x as a feature\nA (20th order) polynomial linear model that uses 20 polynomials of x as features\nA (20th order) polynomial LASSO model that uses the same 20 polynomials of x as features but “regularizes” to remove unimportant features from the model\n\nIf the DGP for y is a cubic function of x, what do we know about the expected bias for our three candidate model configurations in this example? 1\n\n\n1.5.2 Stimulation Steps\nWith that introduction complete, lets start our simulation of the bias-variance trade-off\n\nWe get four random samples of training data to fit models\n\n\nIn other words, we are simulating four separate studies where the researcher in each study is trying to develop a prediction model for y using a sample of training data\nHere are plots of these four simulated training sets with a dotted line for the data generating process (DGP)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe get one more large random sample (N = 5000) with the same DGP to use as a test set to evaluate all the models that will be fit in the training sample across all of the simulations.\n\n\n\n\n\n\n\n\nWe fit the three model configurations in each of the four simulated training sets\nWe use the resulting models to make predictions for observations in the same training set in which they were fit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLook in any training set. Can you see evidence of bias for any model configuration? 2\nCan you see any evidence of overfitting for any model configuration? 3\n\n\nWe use these same models (3 model configurations fit to 4 different training sets) to make predictions for new observations in the test set\n\n\nRemember that the test set has NEW observations of x and y that weren’t used for fitting any of the models.\nLets look at each model configurations performance in test separately\n\n\n\nHere are predictions from the four simple linear models (fit in each of the four training sets) in the test set\n\n\n\n\n\n\nCan you see evidence of bias for the simple linear models? 4\nHow much variance across the simple linear models is present? 5\n\n\nHere are predictions from the four polynomial linear models in the test set\n\n\n\n\n\n\nAre they systematically biased? 6\nHow does the variance of these models compare to the variance of the simple linear models? 7\nHow does this demonstrate the connection between model overfitting and model variance? 8\n\n\nHere are predictions from the four polynomial LASSO models in the test set\n\n\n\n\n\n\nHow does their bias compare to the simple and polynomial linear models? 9\nHow does their variance compare to the simple and polynomial linear models? 10\n\n\nNow we will quantify the performance of these models in training and test sets with the root mean square error performance metric. This is the standard deviation of the error when comparing the predicted values for y to the actual values (ground truth) for y.\n\nWhat do we expect about RMSE for the three models in train and test? 11\n\nTo better understand this:\n\nCompare RMSE across the three model configurations within the training sets (turquoise line)\nCompare how RMSE changes for each model configuration across its training set and the test set\nCompare RMSE across the three model configurations within the test set (red line)?\nSpecifically compare the performance of simple linear model (least flexible) with the polynomial linear model (most flexible)\n\n\n\n\n\n\n\nWould these observations about bias and variance of these three model configurations always be the same regardless of the DGP? 12"
  },
  {
    "objectID": "001_overview.html#discussion---tuesdaythursday",
    "href": "001_overview.html#discussion---tuesdaythursday",
    "title": "1  Overview of Machine Learning",
    "section": "1.6 Discussion - Tuesday/Thursday",
    "text": "1.6 Discussion - Tuesday/Thursday\n\n1.6.1 Course Overview\n\nIntroductions (preferred name, pronouns, program/department and year)\nStructure of course\n\nSame flow each week\n\nWeek starts on Thursdays at 12:15 pm\nAssignments include:\n\nPre-recorded lectures\nWeb book material\nReadings (James et al. (2023) and other sources; All free)\nApplication assignment\n\nAsychronous discussion and questions on Slack\nLab section on Tuesdays at 11:00 am - address previous week’s code\nQuiz and application assignments due Wednesdays at 8 pm\nWrap-up discussion and conceptual questions on Thursdays at 11 am. Not a lecture\n\nSelf-paced (except for due dates and discussion)\nQuizzes used to encourage and assess reading. Also to guide discussion.\nWorkload similar to 610/710\nOffice hours\n\nJohn - Thursdays, 1 – 2 pm\nMichelle - Wednesdays, 10 - 11 am\nKendra - Mondays, 2:30 - 3:30 pm\nPersonal appointments & Slack\n\n\nThe web book\n\nPrimary source for all course materials\nOrganized by units (with syllabus at front)\nLinks to pre-recorded lectures, readings, and quiz\nProvides primary source for code examples (all you need for this course)\nLecture follows book\n\nCourse as guided learning\n\nConcepts in lectures and readings\nApplications in web book and application assignment\nDiscussion section is discussion/questions (not pre-planned lecture)\nSlack CAN be a good source for discussion and questions as well\nGrades are secondary (quizzes, application assignments, exams)\n\nWhy these tools?\n\nQuarto\n\nScientific publishing system (reproducible code, with output, presentations, papers)\nTool for collaboration\nInteractive with static product (render to html or pdf)\nApplication assignments & web book\n\ntidyverse?\n\nThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures\nUnmatched for data wrangling, EDA, and data visualization\n\ntidymodels?\n\nConsistent interface to hundreds of statistical algorithms\nUnder VERY active development\nWell-supported and documented (tidymodels.org)\nBe careful with other web documentation (often out of date)\n\n\nWhy me?\n\nPrimary tools in our research program\nModel for progression from 610/710\nCan do AND can collaborate with CS and expert data scientists\n\nEnvironment\n\nSafe and respectful\nVERY encouraging of questions, discussion, and tangents\nHave fun\nAccomodations and Complaints\n\nChatGPT\n\nYay! May develop into an amazing tool in your workflow\nUse as tool (like Stack Overflow) for applications (application assignments, application questions on exams)\nCheck carefully - it can be wrong even when it looks right\nDo NOT use for conceptual questions (quizzes, conceptual exam questions). This type of info needs to be in your head to be effective data scientist.\n\nAcademic Integrity\n\nDo not cheat! Only you lose.\nNo collaboration with classmates, peers, previous students on anything graded (including application assignments)\nAll cheating reported to Department and Dean of Students. If application assignment or quizzes, zero on all of them because I can’t trust them. If exam, zero on exam.\n\n\n\n\n1.6.2 Association vs. Prediction\n\nWhat is the difference between association vs. prediction? 13\nMuch research in psychology demonstrates association but calls it prediction!\nAssociation (sometimes substantially) overestimates the predictive strength of our models\n\nCoefficients are derived to mimimize SSE (or maximize R2)\nR2 from GLM (using one sample) indexes how well on average any GLM that is fit to a sample will account for variance in that sample when specific coefficients are estimated in the same sample they are evaluated\nR2 does NOT tell you how well a specific GLM (including its coefficients) will work with new data for prediction\nR2 itself is positively biased even as estimate of how well a sample specific GLM will predict in that sample (vs. adjusted R2 and other corrections)\n\n\n\n\n1.6.3 Prediction vs. Explanation\n\nExamples of valuable prediction without explanation?\nCan you have explanation without prediction?\nPrediction models can provide insight or tests of explanatory theories (e.g., do causes actually predict in new data; variable importance)\nGoal of scientific psychology is to understand human behavior. It involves both explaining behavior (i.e., identifying causes) and predicting (yet to be observed) behaviors.\n\nWe overemphasize explanatory goals in this department, IMO\n\n\n\n\n1.6.4 Data Generating Process\n\n\\(Y = f(X) + \\epsilon\\)\nboth function and Xs are generally unknown\n\n\n\n1.6.5 Bias, Overfitting, and Variance\n\nWhat are they and how are they related?\nDescribe problem of p-hacking with respect to overfitting? 14\n\n\n\n1.6.6 Cross Validation\n\nWhat is it?\nHow are replication and cross-validation different?\n\n\n\n1.6.7 Basic framework and terminology\n\nSupervised vs. unsupervised machine learning?\nSupervised regression vs classification?\n\n\n\nWhat is a data generating process?\n\n\\(Y = f(X) + \\epsilon\\)\nBoth function and Xs are generally unknown\n\\(\\hat{Y} = \\hat{f}(X)\\)\n\nWhy do we estimate the data generating process?\n\n\nReducible vs. Irreducible error?\n\nOur predictions will have error\nYou learned to estimate parameters in the GLM to minimize error in 610\nBut error remained non-zero (in your sample and more importantly with same model in new samples) unless you perfectly estimated the DGP\nThat error can be divided into two sources\nIrreducible error comes from measurement error in X, Y and missing X because predictors (causes) not measured.\n\nIrreducible without collecting new predictors and/or with new measures\nIt places a ceiling on the performance of the best model you can develop with your available data\n\nReducible error comes from mismatch between \\(\\hat{f}(X)\\) and the true \\(f(X)\\).\n\nWe can reduce this without new data.\n\nJust need better model (\\(\\hat{f}(X)\\)).\n\nYou didn’t consider this (much) in 610 because you were limited to one statistical algorithm (GLM) AND it didn’t have hyperparameters.\nYou did reduce error by coding predictors (feature engineering) differently (interactions \\(X1*X2\\), polynomial terms \\(X^2\\), power transformations of X) This course will teach you methods to decrease reducible error (and validly estimate total error of that best model)\n\n\n\n\nWhat are the three general steps by which we estimate and evaluate the data generating process with a sample of data? Lets use all this vocabulary!\n\nCandidate model configurations\n\nStatistical algorithms\nHyperparameters\nFeatures (vs. predictors?), feature matrix, feature engineering, recipe (tidymodels specific)\n\nModel fitting (training), selection, and evaluation\nResampling techniques\n\ncross validation techniques (k-fold)\nboostrapping\n\nTraining, validation, and test sets (terms vary in literature!)\n\n\n\n\n1.6.8 Bias-variance tradeoff\n\nWhat is underfitting, overfitting, bias, and variance?\nBias and variance are general concepts to understand during any estimation process\n\nEstimate mean, median, standard deviation\nParameter estimates in GLM\nEstimate DGP - \\(\\hat{Y} = \\hat{f}(X)\\)\n\n\n\nUseful conceptual examples of bias-variance\n\nExample 1: Darts from Yarkoni and Westfall (2017)\n\n\n\nExample 2: Models (e.g. many scales made by Acme Co.) to measure my weight\n\n\n1.6.8.1 Bias\nBiased models are generally less complex models (i.e., underfit) than the data-generating process for your outcome\n\nBiased models lead to errors in prediction because the model will systematically over- or under-predict outcomes (scores or probabilities) for specific values of predictor(s) (bad for prediction goals!)\nParameter estimates from biased models may over or under-estimate the true effect of a predictor (bad for explanatory goals!)\n\n\nAre GLMs biased models? 15\n\nBias seems like a bad thing.\n\nBoth bias (due to underfitting) and variance (due to overfitting) are sources of (reducible) prediction errors (and imprecise/inaccurate parameter estimates). They are also often inversely related (i.e., the trade-off).\nA model configuration needs to be flexible enough to represent the true DGP.\n\nAny more flexibility will lead to overfitting.\n\nAny less flexibility will lead to underfitting.\n\nIdeally, if your model configuration is perfectly matched to the DGP, it will have very low bias and very low variance (assuming sufficiently large N)\nThe world is complex. In many instances,\n\nWe can’t perfectly represent the DGP\nWe trade off a little bias for big reduction in variance to produce the most accurate predictions (and stable parameter estimates across samples for explanatory goals)\nOr we trade off a little variance (slightly more flexible model) to get a big reduction in bias\nEither way, we get models that predict well and may be useful for explanatory goals\n\n\n\n\n1.6.8.2 Overfitting - Variance\nConsider example of p = n - 1 in general linear model. What happens in this situation? How is this related to overfitting and model flexibility? 16\nFactors that increase overfitting\n\nSmall N\nComplex models (e.g, many predictors, p relative to n, non-parametric models)\nWeak effects of predictors (lots of noise available to overfit)\nCorrelated predictors (for some algorithms like the GLM)\nChoosing between many model configurations (e.g. different predictors or predictor sets, transformations, types of statistical models) - lets return to this when we consider p-hacking\n\n\nYou might have noticed that many of the above factors contribute to the standard error of a parameter estimate/model coefficient from the GLM\n\nSmall N\nBig p\nSmall \\(R^2\\) (weak effects)\nCorrelated predictors\n\nThe standard error increases as model overfitting increases due to these factors\nExplain the link between model variance/overfitting, standard errors, and sampling distributions? 17\n\nDescribe problem of p-hacking with respect to overfitting? 18\n\nParameter estimates from an overfit model are specific to the sample within which they were trained and are not true for other samples or the population as a whole\n\nParameter estimates from overfit models have big (TRUE) SE and so they may be VERY different in other samples\n\nThough if the overfitting is due to fitting many models, it won’t be reflected in the SE from any one model because each model doesn’t know the other models exist! p-hacking!!\n\nWith traditional (one-sample) statistics, this can lead us to incorrect conclusions about the effect of predictors associated with these parameter estimates (bad for explanatory goals!).\nIf the parameter estimates are very different sample to sample (and different from the true population parameters), this means the model will predict poorly in new samples (bad for prediction goals!). We fix this by using resampling to evaluate model performance.\n\n\n\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2023. An Introduction to Statistical Learning: With Applications in R. 2nd ed. Springer Texts in Statistics. New York: Springer-Verlag.\n\n\nYarkoni, Tal, and Jacob Westfall. 2017. “Choosing Prediction Over Explanation in Psychology: Lessons From Machine Learning.” Perspectives on Psychological Science 12 (6): 1100–1122."
  },
  {
    "objectID": "001_overview.html#footnotes",
    "href": "001_overview.html#footnotes",
    "title": "1  Overview of Machine Learning",
    "section": "",
    "text": "The simple linear model will underfit the true DGP and therefore it will be biased b/c it can only represent y as a linear function of x. The two polynomial models will be generally unbiased b/c they have x represented with 20th order polynomials. LASSO will be slightly biased due to regularization but more on that in a later unit↩︎\nThe simple linear model is clearly biased. It systemically underestimates Y in some portions of the X distribution and overestimates Y in other portions of the X distribution. This is true across training sets.↩︎\nThe polynomial linear model appears to overfit the data in the training set. In other words, it seems to follow both the signal/DGP and the noise. However, you can’t be certain of this with only one training set and without knowing the DGP.\nIt is possible that the wiggles in the prediction line represent the real DGP.\nYou will need a test set to be certain about the degree of overfitting.↩︎\nYes, consistent with what we saw in the training sets, the simple linear model systematically overestimates Y in some places and underestimates it in others. The DGP is clearly NOT linear but this simple model can only make linear predictions. It is a fairly biased model that underfits the true DGP. This bias will make a large contribution to the reducible error of the model↩︎\nThere is not much variance in the prediction lines across the models that were fit to different training sets. The slopes are very close across models and the intercepts only vary by a small amount. The simple linear model configuration does not appear to have high variance and model variance will not contribute much to its reducible error.↩︎\nThere is not much systematic bias. The overall function is generally cubic as is the DGP. Bias will not contribute much to the model’s reducible error.↩︎\nThere is much higher model variance for this polynomial linear model relative to the simple linear model. Although all four models generally predict Y as a cubic function of X, there is also a non-systematic wiggle that is different for each of the models.↩︎\nModel variance is a result of overfitting to the training set. If a model fits noise in its training set, that noise will be different in every dataset. Therefore, you end up with different models depending on the training set in which they are fit. And none of those models will do well with new data as you can see in this test set because noise is random and different in each dataset.↩︎\nIt has low bias much like the polynomial linear model. It is able to capture the true cubic DGP fairly well. The regularization process slightly reduced the magnitude of the cubic (the prediction line is a little straighter than it should be) but not by much.↩︎\nIt has low variance, much like the simple linear model. All four models, fit in different training sets resulted in very similar prediction lines.↩︎\nThe simple linear model is underfit to the TRUE DGP. Therfore it is systematically biased everywhere it is use and won’t even fit train for this reason. However, it’s not very flexible so it won’t be overfit to the noise in train and therefore should fit comparably in test. The polynomial linear model won’t be biased at all given that the DGP is polynomial. However, it is overly flexible (20th order) and so will substantially overfit the training data such that it will show high variance and its performance will be poor in test. The polynomial LASSO will be the sweet spot in bias-variance trade-off. It has a little bias but not much. However, it is not as flexible due to regularization by lambda so it won’t be overfit to its training set. Therefore, it should do well in the test set.↩︎\nNo. A model configuration needs to be flexible enough and/or well designed to represent the DGP for the data that you are modeling. The two polynomial models in this example were each able to represent a cubic DGP. The simple linear model was not. The polynomial linear model was too flexible for a cubic given that it had 20 polynomials of X. Therefore, it was overfit to its training set and had high variance. However, if the DGP was a different shape, the story would be different. If the DGP was linear the simple linear model would not have been biased and would have performed best. If this DGP was some other form (step function), it may be that none of the models would work well.↩︎\nAssociation quantifies the relationship between variables within a sample (predictors-outcome). Prediction requires using an established model to predict (future?) outcomes for new (“out-of-sample,”held-out”) participants. ↩︎\nWhen you p-hack, you are overfitting the training set (your sample). You try out many, many different model configurations and choose the one you like best rather than what works well in new data. This model likely capitalizes on noise in your sample. It won’t fit well in another sample. In other words, your conclusions are not linked to the true DGP and would be different if you used a different sample. In a different vein, your significance test is wrong. The SE does not reflect the model variance that resulted from testing many different configurations b/c your final model didn’t “know” about the other models. Statistically invalid conclusion!↩︎\n“GLM parameter estimates are BLUE - best linear unbiased estimators. Parameter estimates from any sample are unbiased estimates of the linear model coefficients for population model but if DGP is not linear, this linear model will produce biased predictions and have biased parameter estimates.↩︎\nThe model will perfectly fit the sample data even when there is no relationship between the predictors and the outcome. e.g., Any two points can be fit perfectly with one predictor (line), any three points can be fit perfectly with two predictors (plane). This model will NOT predict well in new data. This model is overfit because n-1 predictors is too flexible for the linear model. You will fit the noise in the training data.↩︎\nAll parameter estimates have a sampling distribution. This is the distribution of estimates that you would get if you repeatedly fit the same model to new samples. When a model is overfit, that means that aspects of the model (its parameter estimates, its predictions) will vary greatly from sample to sample. This is represented by a large standard error (the SD of the sampling distribution) for the model’s parameter estimates. It also means that the predictions you will make in new data will be very different depending on the sample that was used to estimate the parameters.↩︎\nWhen you p-hack, you are overfitting the training set (your sample). You try out many, many different model configurations and choose the one you like best rather than what works well in new data. This model likely capitalizes on noise in your sample. It won’t fit well in another sample. In other words, your conclusions are not linked to the true DGP and would be different if you used a different sample. In a different vein, your significance test is wrong. The SE does not reflect the model variance that resulted from testing many different configurations b/c your final model didn’t “know” about the other models. Statistically invalid conclusion!↩︎"
  },
  {
    "objectID": "002_exploratory_data_analysis.html#overview-of-unit",
    "href": "002_exploratory_data_analysis.html#overview-of-unit",
    "title": "2  Exploratory Data Analysis",
    "section": "2.1 Overview of Unit",
    "text": "2.1 Overview of Unit\nLearning Objectives\n\nStages of Analysis\nBest practices for data storage, variable classing, data dictionaries\nProblems and solutions regarding data leakage\nKey goals and techniques cleaning EDA\n\nTidying names and response labels\nAppropriate visualizations based on variable class\nSummary statistics based on variable class\n\nProper splitting for training/validation and test sets\nKey goals and techniques modeling EDA\n\nAppropriate visualizations based on variable class\nSummary statistics based on variable class\n\nIntroductory use of recipes for feature engineering\n\nReadings [NOTE: These are short chapters. You are reading to understand the framework of visualizing data in R. Don’t feel like you have to memorize the details. These are reference materials that you can turn back to when you need to write code!]\n\nWickham, Çetinkaya-Rundel, and Grolemund (2023) Chapter 1, Data Visualization\nWickham, Çetinkaya-Rundel, and Grolemund (2023) Chapter 9, Layers\nWickham, Çetinkaya-Rundel, and Grolemund (2023) Chapter 10, Exploratory Data Analysis\n\nLecture Videos\n\nLecture 1: Overview of EDA; ~ 24 mins\nLecture 2: EDA for Cleaning; ~ 33 mins\nLecture 3: Introduction to Recipes; ~ 17 mins\nLecture 4: EDA for Modeling Part I; ~ 17 mins\nLecture 5: EDA for Modeling Part II; ~ 22 mins\nDiscussion\n\nPost questions or discuss readings or lectures in Slack\nApplication Assignment\n\ndata\ndata dictionary\ncleaning EDA: rmd html\nmodeling EDA: rmd html\nfun_modeling.R\nsolutions: knit cleaning EDA; knit modeling EDA\n\nSubmit the application assignment and unit quiz by 8 pm on Wednesday, January 31st"
  },
  {
    "objectID": "002_exploratory_data_analysis.html#overview-of-exploratory-data-analysis",
    "href": "002_exploratory_data_analysis.html#overview-of-exploratory-data-analysis",
    "title": "2  Exploratory Data Analysis",
    "section": "2.2 Overview of Exploratory Data Analysis",
    "text": "2.2 Overview of Exploratory Data Analysis\n\n2.2.1 Stages of Data Analysis and Model Development\nThese are the main stages of data analysis for machine learning and the data that are used\n\nEDA: Cleaning (full dataset)\nEDA: Split data into training, validation and test set(s)\nEDA: Modeling (training sets)\nModel Building: Feature engineering (training sets)\nModel Building: Fit many models configurations (training set)\nModel Building: Evaluate many models configurations (validation sets)\nFinal Model Evaluation: Select final/best model configuration (validation sets)\nFinal Model Evaluation: Fit best model configuration (use both training and validation sets)\nFinal Model Evaluation: Evaluate final model configuration (test sets)\nFinal Model Evaluation: Fit best model configuration to ALL data (training, validation, and test sets) if you plan to use it for applications.\n\nThe earlier stages are highly iterative:\n\nYou may iterate some through EDA stages 1-3 if you find further errors to clean in stage 3 [But make sure you resplit into the same sets]\nYou will iterate many times though stages 3-6 as you learn more about your data both through EDA for modeling and evaluating actual models in validation\n\nYou will NOT iterate back to earlier stages after you select a final model configuration\n\nStages 7 - 10 are performed ONLY ONCE\nOnly one model configuration is selected and re-fit and only that model is brought into test for evaluation\nAny more than this is essentially equivalent to p-hacking in traditional analyses\nStep 10 only happens if you plan to use the model in some application\n\n\n\n2.2.2 Data file formats\nWe generally store data as CSV [comma-separated value] files\n\nEasy to view directly in a text editor\nEasy to share because others can use/import into any data analysis platform\nWorks with version control (e.g. git, svn)\nuse read_csv() and write_csv()\n\nExceptions include:\n\nWe may consider binary (.rds) format for very big files because read/write can be slow for csv files.\n\nBinary file format provides a modest additional protection for sensitive data (which we also don’t share)\nuse read_rds() and write_rds()\n\nSee chapter 7 - Data Import in Wickham, Çetinkaya-Rundel, and Grolemund (2023) for more details and advanced techniques for importing data using read_csv()\n\n\n2.2.3 Classing Variables\nWe store and class variables in R based on their data type.\nFor nominal variables:\n\nWe store (in csv files) these variables as character class with descriptive text labels for the levels\n\nEasier to share/document\nReduces errors\n\nWe class these variables in R as factors when we load them (using read_csv())\nIn some cases, we should pay attention to the order of the levels of the variable. e.g.,\n\nFor a dichotomous outcome variable, the positive/event level of dichotomous factor outcome should be first level of the factor\nThe order of levels may also matter for factor predictors (e.g., step_dummy() uses first level as reference).\n\n\nFor ordinal variables:\n\nWe store (in csv files) these variables as character class with descriptive text labels for the levels\n\nEasier to share/document\nReduces errors\n\nWe class these variables in R as factors (just like nominal variables)\n\nIt is easier to do EDA with these variables classes as factors\nWe use standard factors (not ordered)\n\nConfirm that the order of the levels is set up correctly. This is very important for ordinal variables.\nDuring feature engineering stage, we can then either\n\nTreat as a nominal variable and create features using step_dummy()\nTreat as an interval variable using step_ordinalscore()\n\n\nFor interval and ratio variables:\n\nWe store these variables as numeric\nWe class these variables as numeric (either integer or double - let R decide) during the read and clean stage (They are typically already in this class when read in)\n\n\nWe will refer to both nominal and ordinal variables as categorical variables\n\nThey are stored as character\nThey are classed as factors\nThey include a limited number of unique responses\nWe can indicate the order of the levels\nSimilar EDA approaches are used with both\nOrdinal variables may show non-linear relations b/c they may not be evenly spaced. In these instances, we can use feature engineering approaches that are also used for nominal variables\n\nWe will often refer to interval and ratio variables as numeric variables\n\nThe are stored as numeric\nThey are classed with one of two numeric data types\nThey have many (infinite?) unique responses\nSimilar EDA approaches are used with both\nSimilar feature engineering approaches are used with both\n\n\n\n2.2.4 Data Dictionaries\nYou should always make a data dictionary for use with your data files.\n\nIdeally, these are created during the planning phase of your study, prior to the start of data collection\nStill useful if created at the start of data analysis\n\nData dictionaries:\n\nhelp you keep track of your variables and their characteristics (e.g., valid ranges, valid responses)\ncan be used by you to check your data during EDA\ncan be provided to others when you share your data (data are not generally useful to others without a data dictionary)\n\nWe will see a variety of data dictionaries throughout the course. Many are not great as you will learn.\n\n\n2.2.5 The Ames Housing Prices Dataset\nWe will use the Ames Housing Prices dataset as a running example this unit (and some future units and application assignments as well)\n\nYou can read more about the original dataset created by Dean DeCock\nThe data set contains data from home sales of individual residential property in Ames, Iowa from 2006 to 2010\nThe original data set includes 2930 observations of sales price and a large number of explanatory variables (23 nominal, 23 ordinal, 14 discrete, and 20 continuous)\nThis is the original data dictionary\nThe challenge with this dataset is to build the best possible prediction model for the sale price of the homes.\n\n\nFirst, lets set up our environment with functions from important packages. I strongly recommend reviewing our recommendations for best practices regarding managing function conflicts now. It will save you a lot of headaches in the future.\n\nFirst we set a conflicts policy that will produce errors if we have unanticipated conflicts.\nWe next source a library of functions that we use for common tasks in machine learning. This includes a function (tidymodels_conflictRules()) that sets conflict rules to allow us to attach tidymodels functions without conflicts with tidyverse functions. You can review that function to see what it does (search for that function name at the link)\nThen we use that function\n\n\noptions(conflicts.policy = \"depends.ok\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\ntidymodels_conflictRules()\n\nNow we load packages for functions that we will use regularly. There are five things to note RE best practices\n\nIf we will use a lot of functions from a package (e.g., tidyverse, tidymodels), we attach the full package\nIf we will use only several functions from a package (but plan to use them repeatedly), we use the include.only parameter to just attach those functions.\nAt times, if we plan to use a single function from a package only 1-2x times, we may not even attach that function at all. Instead, we just call it using its namespace (i.e. packagename::functionname)\nIf a package has a function that conflicts with our primary packages and we don’t plan to use that function, we load the package but exclude the function. If we really needed it, we can call it with its namespace as per option 3 above.\nPay attention to conflicts that were allowed to make sure you understand and accept them. (I left the package messages and warnings in the book this time to see them. I will hide them to avoid cluttering book in later units but you should always review them.)\n\n\nlibrary(janitor, include.only = \"clean_names\")\nlibrary(cowplot, include.only = \"plot_grid\") # for plot_grid()\nlibrary(kableExtra, exclude = \"group_rows\") # exclude dplyr conflict\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\n\nThen we source (from github) two other libraries of functions that we use commonly for exploratory data analyses. You should review these function scripts to see how I’ve written this code.\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\n\nFinally, we tune our environment a bit more by setting plot themes and print options\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\n\nAnd we set a relative path to our data. This assumes you are using an RStudio project with the path to the data relative to that project file. I’ve provided more detail elsewhere on best practices for managing files and paths.\n\npath_data &lt;- \"data\"\n\nHere is a quick glimpse of the subset of observations we will work with in Units 2-3 and the first two application assignments. Note that we re-class all character variables as unordered factors for now\n\n1data_all &lt;- read_csv(here::here(path_data, \"ames_raw_class.csv\"),\n2                     col_types = cols()) |&gt;\n3  mutate(across(where(is.character), factor)) |&gt;\n4  glimpse()\n\n\n1\n\nFirst we read data using a relative path and the here::here() function. This is a replacement for file.path() that works better for both interactive use and rendering in Quarto when using projects.\n\n2\n\nWe use col_types = cols() to let R guess the correct class for each column. This suppresses messages that aren’t important at this point prior to EDA.\n\n3\n\nThen we use a mutate to re-class all character data to factors. This should handle most of our nominal and ordinal variables. We may need to still class some that were missed because they appeared to be numeric. I prefer factor() to forcats::fct() because factor orders the levels alphabetically. Be aware that this could change if your code is used in a region of the world where this sorting is different. I still prefer this to the alternative (in fct()) that orders by the order the levels are found in your data.\n\n4\n\nIt is good practice to always glimpse() data after you read it.\n\n\n\n\nRows: 1,955\nColumns: 81\n$ PID               &lt;fct&gt; 0526301100, 0526350040, 0526351010, 0527105010, 0527…\n$ `MS SubClass`     &lt;fct&gt; 020, 020, 020, 060, 120, 120, 120, 060, 060, 060, 02…\n$ `MS Zoning`       &lt;fct&gt; RL, RH, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, …\n$ `Lot Frontage`    &lt;dbl&gt; 141, 80, 81, 74, 41, 43, 39, 60, 75, 63, 85, NA, 47,…\n$ `Lot Area`        &lt;dbl&gt; 31770, 11622, 14267, 13830, 4920, 5005, 5389, 7500, …\n$ Street            &lt;fct&gt; Pave, Pave, Pave, Pave, Pave, Pave, Pave, Pave, Pave…\n$ Alley             &lt;fct&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ `Lot Shape`       &lt;fct&gt; IR1, Reg, IR1, IR1, Reg, IR1, IR1, Reg, IR1, IR1, Re…\n$ `Land Contour`    &lt;fct&gt; Lvl, Lvl, Lvl, Lvl, Lvl, HLS, Lvl, Lvl, Lvl, Lvl, Lv…\n$ Utilities         &lt;fct&gt; AllPub, AllPub, AllPub, AllPub, AllPub, AllPub, AllP…\n$ `Lot Config`      &lt;fct&gt; Corner, Inside, Corner, Inside, Inside, Inside, Insi…\n$ `Land Slope`      &lt;fct&gt; Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gt…\n$ Neighborhood      &lt;fct&gt; NAmes, NAmes, NAmes, Gilbert, StoneBr, StoneBr, Ston…\n$ `Condition 1`     &lt;fct&gt; Norm, Feedr, Norm, Norm, Norm, Norm, Norm, Norm, Nor…\n$ `Condition 2`     &lt;fct&gt; Norm, Norm, Norm, Norm, Norm, Norm, Norm, Norm, Norm…\n$ `Bldg Type`       &lt;fct&gt; 1Fam, 1Fam, 1Fam, 1Fam, TwnhsE, TwnhsE, TwnhsE, 1Fam…\n$ `House Style`     &lt;fct&gt; 1Story, 1Story, 1Story, 2Story, 1Story, 1Story, 1Sto…\n$ `Overall Qual`    &lt;dbl&gt; 6, 5, 6, 5, 8, 8, 8, 7, 6, 6, 7, 8, 8, 8, 9, 4, 6, 6…\n$ `Overall Cond`    &lt;dbl&gt; 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 2, 5, 6, 6…\n$ `Year Built`      &lt;dbl&gt; 1960, 1961, 1958, 1997, 2001, 1992, 1995, 1999, 1993…\n$ `Year Remod/Add`  &lt;dbl&gt; 1960, 1961, 1958, 1998, 2001, 1992, 1996, 1999, 1994…\n$ `Roof Style`      &lt;fct&gt; Hip, Gable, Hip, Gable, Gable, Gable, Gable, Gable, …\n$ `Roof Matl`       &lt;fct&gt; CompShg, CompShg, CompShg, CompShg, CompShg, CompShg…\n$ `Exterior 1st`    &lt;fct&gt; BrkFace, VinylSd, Wd Sdng, VinylSd, CemntBd, HdBoard…\n$ `Exterior 2nd`    &lt;fct&gt; Plywood, VinylSd, Wd Sdng, VinylSd, CmentBd, HdBoard…\n$ `Mas Vnr Type`    &lt;fct&gt; Stone, None, BrkFace, None, None, None, None, None, …\n$ `Mas Vnr Area`    &lt;dbl&gt; 112, 0, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 603, 0, 350,…\n$ `Exter Qual`      &lt;fct&gt; TA, TA, TA, TA, Gd, Gd, Gd, TA, TA, TA, TA, Gd, Ex, …\n$ `Exter Cond`      &lt;fct&gt; TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, …\n$ Foundation        &lt;fct&gt; CBlock, CBlock, CBlock, PConc, PConc, PConc, PConc, …\n$ `Bsmt Qual`       &lt;fct&gt; TA, TA, TA, Gd, Gd, Gd, Gd, TA, Gd, Gd, Gd, Gd, Gd, …\n$ `Bsmt Cond`       &lt;fct&gt; Gd, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, …\n$ `Bsmt Exposure`   &lt;fct&gt; Gd, No, No, No, Mn, No, No, No, No, No, Gd, Av, Gd, …\n$ `BsmtFin Type 1`  &lt;fct&gt; BLQ, Rec, ALQ, GLQ, GLQ, ALQ, GLQ, Unf, Unf, Unf, GL…\n$ `BsmtFin SF 1`    &lt;dbl&gt; 639, 468, 923, 791, 616, 263, 1180, 0, 0, 0, 637, 36…\n$ `BsmtFin Type 2`  &lt;fct&gt; Unf, LwQ, Unf, Unf, Unf, Unf, Unf, Unf, Unf, Unf, Un…\n$ `BsmtFin SF 2`    &lt;dbl&gt; 0, 144, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1120, 0, 0, 0, 0,…\n$ `Bsmt Unf SF`     &lt;dbl&gt; 441, 270, 406, 137, 722, 1017, 415, 994, 763, 789, 6…\n$ `Total Bsmt SF`   &lt;dbl&gt; 1080, 882, 1329, 928, 1338, 1280, 1595, 994, 763, 78…\n$ Heating           &lt;fct&gt; GasA, GasA, GasA, GasA, GasA, GasA, GasA, GasA, GasA…\n$ `Heating QC`      &lt;fct&gt; Fa, TA, TA, Gd, Ex, Ex, Ex, Gd, Gd, Gd, Gd, TA, Ex, …\n$ `Central Air`     &lt;fct&gt; Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y…\n$ Electrical        &lt;fct&gt; SBrkr, SBrkr, SBrkr, SBrkr, SBrkr, SBrkr, SBrkr, SBr…\n$ `1st Flr SF`      &lt;dbl&gt; 1656, 896, 1329, 928, 1338, 1280, 1616, 1028, 763, 7…\n$ `2nd Flr SF`      &lt;dbl&gt; 0, 0, 0, 701, 0, 0, 0, 776, 892, 676, 0, 0, 1589, 67…\n$ `Low Qual Fin SF` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ `Gr Liv Area`     &lt;dbl&gt; 1656, 896, 1329, 1629, 1338, 1280, 1616, 1804, 1655,…\n$ `Bsmt Full Bath`  &lt;dbl&gt; 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0…\n$ `Bsmt Half Bath`  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ `Full Bath`       &lt;dbl&gt; 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 2, 1, 1, 2, 2…\n$ `Half Bath`       &lt;dbl&gt; 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0…\n$ `Bedroom AbvGr`   &lt;dbl&gt; 3, 2, 3, 3, 2, 2, 2, 3, 3, 3, 2, 1, 4, 4, 1, 2, 3, 3…\n$ `Kitchen AbvGr`   &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ `Kitchen Qual`    &lt;fct&gt; TA, TA, Gd, TA, Gd, Gd, Gd, Gd, TA, TA, Gd, Gd, Ex, …\n$ `TotRms AbvGrd`   &lt;dbl&gt; 7, 5, 6, 6, 6, 5, 5, 7, 7, 7, 5, 4, 12, 8, 8, 4, 7, …\n$ Functional        &lt;fct&gt; Typ, Typ, Typ, Typ, Typ, Typ, Typ, Typ, Typ, Typ, Ty…\n$ Fireplaces        &lt;dbl&gt; 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 2, 1…\n$ `Fireplace Qu`    &lt;fct&gt; Gd, NA, NA, TA, NA, NA, TA, TA, TA, Gd, Po, NA, Gd, …\n$ `Garage Type`     &lt;fct&gt; Attchd, Attchd, Attchd, Attchd, Attchd, Attchd, Attc…\n$ `Garage Yr Blt`   &lt;dbl&gt; 1960, 1961, 1958, 1997, 2001, 1992, 1995, 1999, 1993…\n$ `Garage Finish`   &lt;fct&gt; Fin, Unf, Unf, Fin, Fin, RFn, RFn, Fin, Fin, Fin, Un…\n$ `Garage Cars`     &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2…\n$ `Garage Area`     &lt;dbl&gt; 528, 730, 312, 482, 582, 506, 608, 442, 440, 393, 50…\n$ `Garage Qual`     &lt;fct&gt; TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, …\n$ `Garage Cond`     &lt;fct&gt; TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, …\n$ `Paved Drive`     &lt;fct&gt; P, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y…\n$ `Wood Deck SF`    &lt;dbl&gt; 210, 140, 393, 212, 0, 0, 237, 140, 157, 0, 192, 0, …\n$ `Open Porch SF`   &lt;dbl&gt; 62, 0, 36, 34, 0, 82, 152, 60, 84, 75, 0, 54, 36, 12…\n$ `Enclosed Porch`  &lt;dbl&gt; 0, 0, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ `3Ssn Porch`      &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ `Screen Porch`    &lt;dbl&gt; 0, 120, 0, 0, 0, 144, 0, 0, 0, 0, 0, 140, 210, 0, 0,…\n$ `Pool Area`       &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ `Pool QC`         &lt;fct&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ Fence             &lt;fct&gt; NA, MnPrv, NA, MnPrv, NA, NA, NA, NA, NA, NA, NA, NA…\n$ `Misc Feature`    &lt;fct&gt; NA, NA, Gar2, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ `Misc Val`        &lt;dbl&gt; 0, 0, 12500, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ `Mo Sold`         &lt;dbl&gt; 5, 6, 6, 3, 4, 1, 3, 6, 4, 5, 2, 6, 6, 6, 6, 6, 2, 1…\n$ `Yr Sold`         &lt;dbl&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010…\n$ `Sale Type`       &lt;fct&gt; WD, WD, WD, WD, WD, WD, WD, WD, WD, WD, WD, WD, WD, …\n$ `Sale Condition`  &lt;fct&gt; Normal, Normal, Normal, Normal, Normal, Normal, Norm…\n$ SalePrice         &lt;dbl&gt; 215000, 105000, 172000, 189900, 213500, 191500, 2365…\n\n\n\nDataset Notes:\n\nDataset has N = 1955 rather than 2930.\n\nI have held out remaining observations to serve as a test set for a friendly competition in Unit 3\nI will judge your models’ performance with this test set at that time!\nMore on the importance of held out test sets as we progress through the course\n\nThis full dataset has 81 variables. For the lecture examples in units 2-3 we will only use a subset of the predictors\nYou will use different predictors in the next two application assignments\n\n\ndata_all &lt;- data_all |&gt; \n  select(SalePrice,\n         `Gr Liv Area`, \n         `Lot Area`, \n         `Year Built`, \n         `Overall Qual`, \n         `Garage Cars`,\n         `Garage Qual`,\n         `MS Zoning`,\n         `Lot Config` ,\n         `Bldg Type`) |&gt; \n  glimpse()\n\nRows: 1,955\nColumns: 10\n$ SalePrice      &lt;dbl&gt; 215000, 105000, 172000, 189900, 213500, 191500, 236500,…\n$ `Gr Liv Area`  &lt;dbl&gt; 1656, 896, 1329, 1629, 1338, 1280, 1616, 1804, 1655, 14…\n$ `Lot Area`     &lt;dbl&gt; 31770, 11622, 14267, 13830, 4920, 5005, 5389, 7500, 100…\n$ `Year Built`   &lt;dbl&gt; 1960, 1961, 1958, 1997, 2001, 1992, 1995, 1999, 1993, 1…\n$ `Overall Qual` &lt;dbl&gt; 6, 5, 6, 5, 8, 8, 8, 7, 6, 6, 7, 8, 8, 8, 9, 4, 6, 6, 7…\n$ `Garage Cars`  &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2…\n$ `Garage Qual`  &lt;fct&gt; TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA,…\n$ `MS Zoning`    &lt;fct&gt; RL, RH, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL,…\n$ `Lot Config`   &lt;fct&gt; Corner, Inside, Corner, Inside, Inside, Inside, Inside,…\n$ `Bldg Type`    &lt;fct&gt; 1Fam, 1Fam, 1Fam, 1Fam, TwnhsE, TwnhsE, TwnhsE, 1Fam, 1…\n\n\nCoding Sidebar:\n\nNotice the non-standard variable names that include spaces.\n\nWe use the back-ticks around the variable names to allow us reference those variables.\n\nWe will fix this during the cleaning process.\nNever use spaces in variable names when setting up your own data!!! (More on this in a moment…)"
  },
  {
    "objectID": "002_exploratory_data_analysis.html#exploratory-data-analysis-for-data-cleaning",
    "href": "002_exploratory_data_analysis.html#exploratory-data-analysis-for-data-cleaning",
    "title": "2  Exploratory Data Analysis",
    "section": "2.3 Exploratory Data Analysis for Data Cleaning",
    "text": "2.3 Exploratory Data Analysis for Data Cleaning\nEDA could be done using either tidyverse packages and functions or tidymodels (mostly using the recipes package.)\n\nWe prefer to use the richer set of functions available in the tidyverse (and dplyr and purrr packages in particular).\nWe will reserve the use of recipes for feature engineering only when we are building features for models that we will fit in our training sets and evaluation in our validation and test sets.\n\n\n2.3.1 Data Leakage Issues\nData leakage refers to a mistake made by the creator of a machine learning model in which they accidentally share information between their training set and held-out validation or test sets\n\nTraining sets are used to fit models with different configurations\nValidation sets are used to select the best model among those with different configurations (not needed if you only have one configuration)\nTest sets are used to evaluate a best model\nWhen splitting data-sets into training, validation and test sets, the goal is to ensure that no data (or information more broadly) are shared between the three\n\nNo data or information from test should influence either fitting or selecting models\nTest should only be used once to evaluate a best/final model\nTrain and validation set also must be segregated (although validation sets may be used to evaluate many models)\nInformation necessary for transformations and other feature engineering (e.g., means/sds for centering/scaling, procedures for missing data imputation) must all be based only on training data.\nData leakage is common if you are not careful.\n\n\nIn particular, if we begin to use test data or information about test during model fitting\n\nWe risk overfitting\nThis is essentially the equivalent of p-hacking in traditional analyses\nWill report too optimistic performance estimate, which could have harmful real-world consequences.\n\n\n\n2.3.2 Tidy variable names\nUse snake case for variable names\n\nclean_names() from janitor package is useful for this.\nMay need to do further correction of variable names using rename()\nSee more details about tidy names for objects (e.g., variables, dfs, functions) per Tidy Style Guide\n\n\ndata_all &lt;- data_all |&gt; \n  clean_names(\"snake\")\n\ndata_all |&gt; names()\n\n [1] \"sale_price\"   \"gr_liv_area\"  \"lot_area\"     \"year_built\"   \"overall_qual\"\n [6] \"garage_cars\"  \"garage_qual\"  \"ms_zoning\"    \"lot_config\"   \"bldg_type\"   \n\n\n\n\n2.3.3 Explore variable classes\nAt this point, variables should be classed as either numeric or factor\n\nInterval and ratio variables use numeric classes (dbl or int)\nNominal and ordinal variable use factor class\nUseful for variable selection later (e.g., where(is.numeric), where(is.factor))\n\nSubsequent cleaning steps are clearer if we have this established/confirmed now\n\nWe have one variable to change to factor class\n\ndata_all |&gt; glimpse()\n\nRows: 1,955\nColumns: 10\n$ sale_price   &lt;dbl&gt; 215000, 105000, 172000, 189900, 213500, 191500, 236500, 1…\n$ gr_liv_area  &lt;dbl&gt; 1656, 896, 1329, 1629, 1338, 1280, 1616, 1804, 1655, 1465…\n$ lot_area     &lt;dbl&gt; 31770, 11622, 14267, 13830, 4920, 5005, 5389, 7500, 10000…\n$ year_built   &lt;dbl&gt; 1960, 1961, 1958, 1997, 2001, 1992, 1995, 1999, 1993, 199…\n$ overall_qual &lt;dbl&gt; 6, 5, 6, 5, 8, 8, 8, 7, 6, 6, 7, 8, 8, 8, 9, 4, 6, 6, 7, …\n$ garage_cars  &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, …\n$ garage_qual  &lt;fct&gt; TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, T…\n$ ms_zoning    &lt;fct&gt; RL, RH, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, R…\n$ lot_config   &lt;fct&gt; Corner, Inside, Corner, Inside, Inside, Inside, Inside, I…\n$ bldg_type    &lt;fct&gt; 1Fam, 1Fam, 1Fam, 1Fam, TwnhsE, TwnhsE, TwnhsE, 1Fam, 1Fa…\n\n\noverall_qual is ordinal.\n* We should convert it to a factor and confirm the levels are ordered properly.\n* The data dictionary indicates that valid values range from 1 - 10.\n\n1oq_levels &lt;- 1:10\n\nt &lt;-  data_all |&gt; \n  mutate(overall_qual = factor(overall_qual, \n2                               levels = oq_levels)) |&gt;\n  glimpse()\n\n\n1\n\nIt is always best to explicitly set the levels of an ordinal factor in the order you prefer. It is not necessary here because overall_qual was numeric and therefore sorts in the expected order. However, if it had been numbers stores as characters, it could sort incorrectly (e.g., 1, 10, 2, 3, …). And obviously if the orders levels were names, the order would have to be specified.\n\n2\n\nWe indicate the levels here.\n\n\n\n\nRows: 1,955\nColumns: 10\n$ sale_price   &lt;dbl&gt; 215000, 105000, 172000, 189900, 213500, 191500, 236500, 1…\n$ gr_liv_area  &lt;dbl&gt; 1656, 896, 1329, 1629, 1338, 1280, 1616, 1804, 1655, 1465…\n$ lot_area     &lt;dbl&gt; 31770, 11622, 14267, 13830, 4920, 5005, 5389, 7500, 10000…\n$ year_built   &lt;dbl&gt; 1960, 1961, 1958, 1997, 2001, 1992, 1995, 1999, 1993, 199…\n$ overall_qual &lt;fct&gt; 6, 5, 6, 5, 8, 8, 8, 7, 6, 6, 7, 8, 8, 8, 9, 4, 6, 6, 7, …\n$ garage_cars  &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, …\n$ garage_qual  &lt;fct&gt; TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, TA, T…\n$ ms_zoning    &lt;fct&gt; RL, RH, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, RL, R…\n$ lot_config   &lt;fct&gt; Corner, Inside, Corner, Inside, Inside, Inside, Inside, I…\n$ bldg_type    &lt;fct&gt; 1Fam, 1Fam, 1Fam, 1Fam, TwnhsE, TwnhsE, TwnhsE, 1Fam, 1Fa…\n\n\n\n\n2.3.4 Skimming the data\nskim() from the skimr package is a wonderful and customizable function for summary statistics\n\nIt is highly customizable so we can write our own versions for our own needs\nWe use different versions for cleaning and modeling EDA\nFor cleaning EDA, we just remove some stats that we don’t want to see at this time\nWe can get many of the summary stats for cleaning in one call\nWe have a custom skim defined in the fun_eda.R library that we use regularly. Here is the code but you can use the function directly if you sourced fun_eda.R (as we did above)\n\n\nskim_some &lt;- skim_with(numeric = sfl(mean = NULL, sd = NULL, p25 = NULL, p50 = NULL, p75 = NULL, hist = NULL))\n\n\nHere is what we get with our new skim_some() function\n\nWe will refer to this again for each characteristic we want to review for instructional purposes\nWe can already see that we can use skim_some() to confirm that we only have numeric and character classes\n\n\ndata_all |&gt; \n  skim_some()\n\n\n\n\nData summary\n\n\n\n\nName\n\n\ndata_all\n\n\n\n\nNumber of rows\n\n\n1955\n\n\n\n\nNumber of columns\n\n\n10\n\n\n\n\n_______________________\n\n\n\n\n\n\nColumn type frequency:\n\n\n\n\n\n\nfactor\n\n\n4\n\n\n\n\nnumeric\n\n\n6\n\n\n\n\n________________________\n\n\n\n\n\n\nGroup variables\n\n\nNone\n\n\n\n\n\nVariable type: factor\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nordered\n\n\nn_unique\n\n\ntop_counts\n\n\n\n\n\n\ngarage_qual\n\n\n109\n\n\n0.94\n\n\nFALSE\n\n\n5\n\n\nTA: 1745, Fa: 79, Gd: 16, Po: 4\n\n\n\n\nms_zoning\n\n\n0\n\n\n1.00\n\n\nFALSE\n\n\n7\n\n\nRL: 1530, RM: 297, FV: 91, C (: 19\n\n\n\n\nlot_config\n\n\n0\n\n\n1.00\n\n\nFALSE\n\n\n5\n\n\nIns: 1454, Cor: 328, Cul: 114, FR2: 55\n\n\n\n\nbldg_type\n\n\n0\n\n\n1.00\n\n\nFALSE\n\n\n5\n\n\n1Fa: 1631, Twn: 145, Dup: 77, Twn: 64\n\n\n\n\n\nVariable type: numeric\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\np0\n\n\np100\n\n\n\n\n\n\nsale_price\n\n\n0\n\n\n1\n\n\n12789\n\n\n745000\n\n\n\n\ngr_liv_area\n\n\n0\n\n\n1\n\n\n438\n\n\n5642\n\n\n\n\nlot_area\n\n\n0\n\n\n1\n\n\n1476\n\n\n215245\n\n\n\n\nyear_built\n\n\n0\n\n\n1\n\n\n1875\n\n\n2010\n\n\n\n\noverall_qual\n\n\n0\n\n\n1\n\n\n1\n\n\n10\n\n\n\n\ngarage_cars\n\n\n1\n\n\n1\n\n\n0\n\n\n4\n\n\n\n\n\n\n\nCoding sidebar 1:\n\nWrite functions whenever you will repeat code often. You can now reuse skim_some()\nskim_with() is an example of a function factory - a function that is used to create a new function\n\npartial() and compose() are two other function factories we will use at times\nMore details on function factories is available in Advanced R\n\n\n\nCoding sidebar 2:\n\nGather useful functions together in a script that you can reuse.\nAll of the reusable functions in this and later units are available to you in one of my public github repositories.\nYou can load these functions into your workspace directly from github using devtools::source_url(). For example: devtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_modeling.R?raw=true\")\nYou should start to gather your favorite custom functions together in your own script(s).\n\nYou can save your own scripts in a local file and load them into your workspace using source() or you can make your own github repo so you can begin to share your code with others!\n\n\n\n2.3.5 Missing Data - All variables\nskim_some() provides us with missing data counts and complete data proportions for each variable\n\ndata_all |&gt; \n  skim_some()\n\n\n\n\nData summary\n\n\n\n\nName\n\n\ndata_all\n\n\n\n\nNumber of rows\n\n\n1955\n\n\n\n\nNumber of columns\n\n\n10\n\n\n\n\n_______________________\n\n\n\n\n\n\nColumn type frequency:\n\n\n\n\n\n\nfactor\n\n\n4\n\n\n\n\nnumeric\n\n\n6\n\n\n\n\n________________________\n\n\n\n\n\n\nGroup variables\n\n\nNone\n\n\n\n\n\nVariable type: factor\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nordered\n\n\nn_unique\n\n\ntop_counts\n\n\n\n\n\n\ngarage_qual\n\n\n109\n\n\n0.94\n\n\nFALSE\n\n\n5\n\n\nTA: 1745, Fa: 79, Gd: 16, Po: 4\n\n\n\n\nms_zoning\n\n\n0\n\n\n1.00\n\n\nFALSE\n\n\n7\n\n\nRL: 1530, RM: 297, FV: 91, C (: 19\n\n\n\n\nlot_config\n\n\n0\n\n\n1.00\n\n\nFALSE\n\n\n5\n\n\nIns: 1454, Cor: 328, Cul: 114, FR2: 55\n\n\n\n\nbldg_type\n\n\n0\n\n\n1.00\n\n\nFALSE\n\n\n5\n\n\n1Fa: 1631, Twn: 145, Dup: 77, Twn: 64\n\n\n\n\n\nVariable type: numeric\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\np0\n\n\np100\n\n\n\n\n\n\nsale_price\n\n\n0\n\n\n1\n\n\n12789\n\n\n745000\n\n\n\n\ngr_liv_area\n\n\n0\n\n\n1\n\n\n438\n\n\n5642\n\n\n\n\nlot_area\n\n\n0\n\n\n1\n\n\n1476\n\n\n215245\n\n\n\n\nyear_built\n\n\n0\n\n\n1\n\n\n1875\n\n\n2010\n\n\n\n\noverall_qual\n\n\n0\n\n\n1\n\n\n1\n\n\n10\n\n\n\n\ngarage_cars\n\n\n1\n\n\n1\n\n\n0\n\n\n4\n\n\n\n\n\n\n\n\nView full observation for missing value\n\nprint() will print only 20 rows and number of columns that will display for width of page\n\nSet options() if you will do a lot of printing and want full dataframe printed\n\nUse kbl() from kableExtra package for formatted tables\nUse View() interactively in R Studio\n\nOption 1 (Simple): Use print() with options()\n\noptions(tibble.width = Inf, tibble.print_max = Inf)\n\ndata_all |&gt; filter(is.na(garage_cars)) |&gt; \n  print()\n\n# A tibble: 1 × 10\n  sale_price gr_liv_area lot_area year_built overall_qual garage_cars\n       &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n1     150909        1828     9060       1923            5          NA\n  garage_qual ms_zoning lot_config bldg_type\n  &lt;fct&gt;       &lt;fct&gt;     &lt;fct&gt;      &lt;fct&gt;    \n1 &lt;NA&gt;        RM        Inside     1Fam     \n\ndata_all |&gt; filter(is.na(garage_qual)) |&gt; \n  print()\n\n# A tibble: 109 × 10\n    sale_price gr_liv_area lot_area year_built overall_qual garage_cars\n         &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n  1     115000         864    10500       1971            4           0\n  2     128950        1225     9320       1959            4           0\n  3      84900        1728    13260       1962            5           0\n  4     116500         858     7207       1958            5           0\n  5      76500        1306     5350       1940            3           0\n  6      76500        2256     9045       1910            5           0\n  7     159900        1560    12900       1912            6           0\n  8      55000        1092     5600       1930            4           0\n  9      93369        1884     6449       1907            4           0\n 10      94000        1020     6342       1875            5           0\n 11     136000        1832    10773       1967            4           0\n 12     100000        1664     9825       1965            5           0\n 13      90000         960     6410       1958            4           0\n 14     100000        1666     9839       1931            5           0\n 15     139000        1824     9400       1971            6           0\n 16      76000        1092     1476       1970            4           0\n 17      75500         630     1491       1972            4           0\n 18      88250        1092     1900       1970            4           0\n 19     136000        1792     9000       1974            5           0\n 20     142000        1114    13072       2004            5           0\n 21      82500         708     5330       1940            4           0\n 22     129000        1464     9900       1910            5           0\n 23      94550        1701     7627       1920            4           0\n 24     103000        1447    10134       1910            5           0\n 25      37900         968     5925       1910            3           0\n 26     113000        1452     4456       1920            4           0\n 27      58500         816     3300       1910            4           0\n 28      34900         720     7879       1920            4           0\n 29      60000         800     6120       1936            2           0\n 30      62500        2128     3000       1922            5           0\n 31      97500        1864     5852       1902            7           0\n 32      70000         892     5160       1923            4           0\n 33     179000        1200    10800       1987            5           0\n 34     179000        1200    10800       1987            5           0\n 35      61000         904    10020       1922            1           0\n 36     118000         698     9405       1947            5           0\n 37      99900         864     4060       1922            5           0\n 38     119900        1678    10926       1959            5           0\n 39     112000         833     8780       1985            5           0\n 40     141000        1080     7500       2004            7           0\n 41     106250        1294    10800       1900            4           0\n 42     130000        1800     8513       1961            5           0\n 43     120000        1027     5400       1920            7           0\n 44      95000        1080     5914       1890            5           0\n 45      65000        1588    12205       1949            3           0\n 46     129400        1540     6000       1905            5           0\n 47     160000        1984     8094       1910            6           1\n 48      89500        1406     7920       1920            6           0\n 49      79900        1198     5586       1920            6           0\n 50      82375        1344    10320       1915            3           0\n 51     127500        1355    10106       1940            5           0\n 52      80000        1006     9000       1959            5           0\n 53     260000        1518    19550       1940            5           0\n 54      99600         864     9350       1975            5           0\n 55     107500        1347     7000       1910            5           0\n 56      79000        1096     9600       1924            6           0\n 57      85000         796     8777       1910            5           0\n 58     145900        2200     8777       1900            5           0\n 59      82000        1152     6040       1955            4           0\n 60      82000        1152     6012       1955            4           0\n 61     118000        1440    12108       1955            4           0\n 62      82500        1152     6845       1955            4           0\n 63      91900         784     6931       1955            4           0\n 64     120000        1053    12180       1938            5           0\n 65      96000        1137     8050       1947            5           0\n 66      98000         864     5604       1925            5           0\n 67      67000         864     8248       1914            3           0\n 68     135900        1716     5687       1912            5           0\n 69     119000        1200     8155       1930            5           0\n 70      81000         630     1890       1972            4           0\n 71     146000        1100     7500       2006            6           0\n 72      64000         670     3500       1945            3           0\n 73     103200         882     5500       1956            4           0\n 74     148000        1534    10800       1895            5           0\n 75     110500         866     3880       1945            5           0\n 76     127000        1355     6882       1914            6           0\n 77     200500        3086    18030       1946            5           0\n 78     150000        1440     7711       1977            4           0\n 79      86000         605     9098       1920            4           0\n 80     123600         990     8070       1994            4           0\n 81      98500        1195     8741       1946            5           0\n 82      79000         774     4270       1931            3           0\n 83     200000        3395    10896       1914            6           0\n 84     150000        2592    10890       1923            5           0\n 85     115000        1517     8500       1919            5           0\n 86     150909        1828     9060       1923            5          NA\n 87     119600        1991     8250       1895            5           0\n 88     147000        1120     8402       2007            5           0\n 89      93900        1092     1495       1970            4           0\n 90      84500         630     1936       1970            4           0\n 91     139500        1142     7733       2005            6           0\n 92     132000        1131    13072       2005            6           0\n 93      85500         869     5900       1923            4           0\n 94     135000        1192    10800       1949            4           0\n 95     119000        1556     8512       1960            5           0\n 96     124000        1025     7000       1962            5           0\n 97      64500        1020     4761       1918            3           0\n 98     100000         788     7446       1941            4           0\n 99      80500         912     6240       1947            4           0\n100      72000         819     9000       1919            5           0\n101     117250         914     8050       2002            6           0\n102      81000        1184     8410       1910            5           0\n103      83000        1414     8248       1922            4           0\n104     102000        1522     6000       1926            5           0\n105      72000         672     8534       1925            4           0\n106     115000        1396     9000       1951            5           0\n107      78000         936     8520       1916            3           0\n108      92000         630     1533       1970            5           0\n109      90500        1092     1936       1970            4           0\n    garage_qual ms_zoning lot_config bldg_type\n    &lt;fct&gt;       &lt;fct&gt;     &lt;fct&gt;      &lt;fct&gt;    \n  1 &lt;NA&gt;        RL        FR2        1Fam     \n  2 &lt;NA&gt;        RL        Inside     1Fam     \n  3 &lt;NA&gt;        RL        Inside     Duplex   \n  4 &lt;NA&gt;        RL        Inside     1Fam     \n  5 &lt;NA&gt;        RL        Inside     1Fam     \n  6 &lt;NA&gt;        RM        Inside     2fmCon   \n  7 &lt;NA&gt;        RM        Inside     1Fam     \n  8 &lt;NA&gt;        RM        Inside     2fmCon   \n  9 &lt;NA&gt;        C (all)   Inside     1Fam     \n 10 &lt;NA&gt;        RL        Inside     1Fam     \n 11 &lt;NA&gt;        RL        Inside     Duplex   \n 12 &lt;NA&gt;        RL        Inside     Duplex   \n 13 &lt;NA&gt;        RL        Inside     1Fam     \n 14 &lt;NA&gt;        RL        Inside     1Fam     \n 15 &lt;NA&gt;        RL        Corner     Duplex   \n 16 &lt;NA&gt;        RM        Inside     Twnhs    \n 17 &lt;NA&gt;        RM        Inside     TwnhsE   \n 18 &lt;NA&gt;        RM        Inside     TwnhsE   \n 19 &lt;NA&gt;        RL        FR2        Duplex   \n 20 &lt;NA&gt;        RL        Inside     1Fam     \n 21 &lt;NA&gt;        RL        Inside     1Fam     \n 22 &lt;NA&gt;        RM        Corner     1Fam     \n 23 &lt;NA&gt;        RM        Corner     2fmCon   \n 24 &lt;NA&gt;        RM        Inside     1Fam     \n 25 &lt;NA&gt;        RM        Inside     1Fam     \n 26 &lt;NA&gt;        RM        Inside     2fmCon   \n 27 &lt;NA&gt;        C (all)   Inside     1Fam     \n 28 &lt;NA&gt;        C (all)   Inside     1Fam     \n 29 &lt;NA&gt;        RM        Inside     1Fam     \n 30 &lt;NA&gt;        RM        Inside     Duplex   \n 31 &lt;NA&gt;        RM        Corner     2fmCon   \n 32 &lt;NA&gt;        RM        Inside     1Fam     \n 33 &lt;NA&gt;        RL        Inside     Duplex   \n 34 &lt;NA&gt;        RL        Inside     Duplex   \n 35 &lt;NA&gt;        RL        Inside     1Fam     \n 36 &lt;NA&gt;        RL        Inside     1Fam     \n 37 &lt;NA&gt;        RL        Corner     1Fam     \n 38 &lt;NA&gt;        RL        Inside     Duplex   \n 39 &lt;NA&gt;        RL        Corner     1Fam     \n 40 &lt;NA&gt;        RL        Inside     1Fam     \n 41 &lt;NA&gt;        RL        Inside     2fmCon   \n 42 &lt;NA&gt;        RL        Corner     Duplex   \n 43 &lt;NA&gt;        RM        Inside     1Fam     \n 44 &lt;NA&gt;        RM        Inside     1Fam     \n 45 &lt;NA&gt;        RM        Inside     1Fam     \n 46 &lt;NA&gt;        RM        Corner     1Fam     \n 47 &lt;NA&gt;        RM        Inside     2fmCon   \n 48 &lt;NA&gt;        RM        Inside     1Fam     \n 49 &lt;NA&gt;        RM        Inside     1Fam     \n 50 &lt;NA&gt;        RM        Inside     2fmCon   \n 51 &lt;NA&gt;        RL        Inside     2fmCon   \n 52 &lt;NA&gt;        RL        Inside     1Fam     \n 53 &lt;NA&gt;        RL        Inside     1Fam     \n 54 &lt;NA&gt;        RL        Inside     Duplex   \n 55 &lt;NA&gt;        RL        Inside     2fmCon   \n 56 &lt;NA&gt;        RL        Corner     1Fam     \n 57 &lt;NA&gt;        RL        Inside     1Fam     \n 58 &lt;NA&gt;        RL        Inside     Duplex   \n 59 &lt;NA&gt;        RL        Inside     Duplex   \n 60 &lt;NA&gt;        RL        Corner     Duplex   \n 61 &lt;NA&gt;        RL        Inside     Duplex   \n 62 &lt;NA&gt;        RL        Inside     Duplex   \n 63 &lt;NA&gt;        RL        Inside     2fmCon   \n 64 &lt;NA&gt;        RL        Inside     1Fam     \n 65 &lt;NA&gt;        RL        Inside     1Fam     \n 66 &lt;NA&gt;        RL        Inside     1Fam     \n 67 &lt;NA&gt;        RL        Inside     1Fam     \n 68 &lt;NA&gt;        RL        Inside     2fmCon   \n 69 &lt;NA&gt;        RM        Inside     1Fam     \n 70 &lt;NA&gt;        RM        Inside     Twnhs    \n 71 &lt;NA&gt;        RL        Inside     1Fam     \n 72 &lt;NA&gt;        RL        Inside     1Fam     \n 73 &lt;NA&gt;        RL        Inside     1Fam     \n 74 &lt;NA&gt;        RL        Inside     1Fam     \n 75 &lt;NA&gt;        RM        Inside     1Fam     \n 76 &lt;NA&gt;        RM        Inside     1Fam     \n 77 &lt;NA&gt;        RL        Inside     1Fam     \n 78 &lt;NA&gt;        RL        Inside     Duplex   \n 79 &lt;NA&gt;        RL        Inside     1Fam     \n 80 &lt;NA&gt;        RL        Inside     1Fam     \n 81 &lt;NA&gt;        RL        Inside     Duplex   \n 82 &lt;NA&gt;        RH        Inside     1Fam     \n 83 &lt;NA&gt;        RH        Inside     2fmCon   \n 84 &lt;NA&gt;        RL        Inside     Duplex   \n 85 &lt;NA&gt;        RM        Corner     1Fam     \n 86 &lt;NA&gt;        RM        Inside     1Fam     \n 87 &lt;NA&gt;        C (all)   Inside     2fmCon   \n 88 &lt;NA&gt;        RL        Inside     1Fam     \n 89 &lt;NA&gt;        RM        Inside     TwnhsE   \n 90 &lt;NA&gt;        RM        Inside     Twnhs    \n 91 &lt;NA&gt;        RL        Inside     1Fam     \n 92 &lt;NA&gt;        RL        Inside     1Fam     \n 93 &lt;NA&gt;        RL        Inside     1Fam     \n 94 &lt;NA&gt;        RL        Inside     1Fam     \n 95 &lt;NA&gt;        RL        Corner     Duplex   \n 96 &lt;NA&gt;        RL        Inside     2fmCon   \n 97 &lt;NA&gt;        C (all)   Corner     1Fam     \n 98 &lt;NA&gt;        RL        Corner     1Fam     \n 99 &lt;NA&gt;        RM        Inside     1Fam     \n100 &lt;NA&gt;        RM        Inside     1Fam     \n101 &lt;NA&gt;        RL        Inside     1Fam     \n102 &lt;NA&gt;        RL        FR2        1Fam     \n103 &lt;NA&gt;        RL        Inside     1Fam     \n104 &lt;NA&gt;        RL        Inside     1Fam     \n105 &lt;NA&gt;        RM        Inside     1Fam     \n106 &lt;NA&gt;        C (all)   Inside     2fmCon   \n107 &lt;NA&gt;        C (all)   Inside     1Fam     \n108 &lt;NA&gt;        RM        Inside     Twnhs    \n109 &lt;NA&gt;        RM        Inside     Twnhs    \n\n\n\nHere are some more advanced options using kbl() for the df with many rows\n\nkable() tables from knitr package and kableExtra extensions (including kbl()) are very useful during EDA and also final publication quality tables\nuse library(kableExtra)\nsee vignettes for kableExtra\n\nOption 2 (more advanced): Use a function for kables that we created. Code is displayed here but the function is available to you if you source fun_eda.R from Github\n\n# Might want to use height = \"100%\" if only printing a few rows\n1print_kbl &lt;- function(data, height = \"500px\") {\n  data |&gt; \n    kbl(align = \"r\") |&gt; \n    kable_styling(bootstrap_options = c(\"striped\", \"condensed\")) |&gt; \n2    scroll_box(height = height, width = \"100%\")\n}\n\n\n1\n\nDefaults to a output box of height = “500px”. Can set to other values if preferred.\n\n2\n\nMight want to use height = \"100%\" if only printing a few rows.\n\n\n\n\n\n\ndata_all |&gt; filter(is.na(garage_qual)) |&gt; \n  print_kbl()\n\n\n\n\n\nsale_price\ngr_liv_area\nlot_area\nyear_built\noverall_qual\ngarage_cars\ngarage_qual\nms_zoning\nlot_config\nbldg_type\n\n\n\n\n115000\n864\n10500\n1971\n4\n0\nNA\nRL\nFR2\n1Fam\n\n\n128950\n1225\n9320\n1959\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n84900\n1728\n13260\n1962\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n116500\n858\n7207\n1958\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n76500\n1306\n5350\n1940\n3\n0\nNA\nRL\nInside\n1Fam\n\n\n76500\n2256\n9045\n1910\n5\n0\nNA\nRM\nInside\n2fmCon\n\n\n159900\n1560\n12900\n1912\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n55000\n1092\n5600\n1930\n4\n0\nNA\nRM\nInside\n2fmCon\n\n\n93369\n1884\n6449\n1907\n4\n0\nNA\nC (all)\nInside\n1Fam\n\n\n94000\n1020\n6342\n1875\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n136000\n1832\n10773\n1967\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n100000\n1664\n9825\n1965\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n90000\n960\n6410\n1958\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n100000\n1666\n9839\n1931\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n139000\n1824\n9400\n1971\n6\n0\nNA\nRL\nCorner\nDuplex\n\n\n76000\n1092\n1476\n1970\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n75500\n630\n1491\n1972\n4\n0\nNA\nRM\nInside\nTwnhsE\n\n\n88250\n1092\n1900\n1970\n4\n0\nNA\nRM\nInside\nTwnhsE\n\n\n136000\n1792\n9000\n1974\n5\n0\nNA\nRL\nFR2\nDuplex\n\n\n142000\n1114\n13072\n2004\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n82500\n708\n5330\n1940\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n129000\n1464\n9900\n1910\n5\n0\nNA\nRM\nCorner\n1Fam\n\n\n94550\n1701\n7627\n1920\n4\n0\nNA\nRM\nCorner\n2fmCon\n\n\n103000\n1447\n10134\n1910\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n37900\n968\n5925\n1910\n3\n0\nNA\nRM\nInside\n1Fam\n\n\n113000\n1452\n4456\n1920\n4\n0\nNA\nRM\nInside\n2fmCon\n\n\n58500\n816\n3300\n1910\n4\n0\nNA\nC (all)\nInside\n1Fam\n\n\n34900\n720\n7879\n1920\n4\n0\nNA\nC (all)\nInside\n1Fam\n\n\n60000\n800\n6120\n1936\n2\n0\nNA\nRM\nInside\n1Fam\n\n\n62500\n2128\n3000\n1922\n5\n0\nNA\nRM\nInside\nDuplex\n\n\n97500\n1864\n5852\n1902\n7\n0\nNA\nRM\nCorner\n2fmCon\n\n\n70000\n892\n5160\n1923\n4\n0\nNA\nRM\nInside\n1Fam\n\n\n179000\n1200\n10800\n1987\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n179000\n1200\n10800\n1987\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n61000\n904\n10020\n1922\n1\n0\nNA\nRL\nInside\n1Fam\n\n\n118000\n698\n9405\n1947\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n99900\n864\n4060\n1922\n5\n0\nNA\nRL\nCorner\n1Fam\n\n\n119900\n1678\n10926\n1959\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n112000\n833\n8780\n1985\n5\n0\nNA\nRL\nCorner\n1Fam\n\n\n141000\n1080\n7500\n2004\n7\n0\nNA\nRL\nInside\n1Fam\n\n\n106250\n1294\n10800\n1900\n4\n0\nNA\nRL\nInside\n2fmCon\n\n\n130000\n1800\n8513\n1961\n5\n0\nNA\nRL\nCorner\nDuplex\n\n\n120000\n1027\n5400\n1920\n7\n0\nNA\nRM\nInside\n1Fam\n\n\n95000\n1080\n5914\n1890\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n65000\n1588\n12205\n1949\n3\n0\nNA\nRM\nInside\n1Fam\n\n\n129400\n1540\n6000\n1905\n5\n0\nNA\nRM\nCorner\n1Fam\n\n\n160000\n1984\n8094\n1910\n6\n1\nNA\nRM\nInside\n2fmCon\n\n\n89500\n1406\n7920\n1920\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n79900\n1198\n5586\n1920\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n82375\n1344\n10320\n1915\n3\n0\nNA\nRM\nInside\n2fmCon\n\n\n127500\n1355\n10106\n1940\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n80000\n1006\n9000\n1959\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n260000\n1518\n19550\n1940\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n99600\n864\n9350\n1975\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n107500\n1347\n7000\n1910\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n79000\n1096\n9600\n1924\n6\n0\nNA\nRL\nCorner\n1Fam\n\n\n85000\n796\n8777\n1910\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n145900\n2200\n8777\n1900\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n82000\n1152\n6040\n1955\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n82000\n1152\n6012\n1955\n4\n0\nNA\nRL\nCorner\nDuplex\n\n\n118000\n1440\n12108\n1955\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n82500\n1152\n6845\n1955\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n91900\n784\n6931\n1955\n4\n0\nNA\nRL\nInside\n2fmCon\n\n\n120000\n1053\n12180\n1938\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n96000\n1137\n8050\n1947\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n98000\n864\n5604\n1925\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n67000\n864\n8248\n1914\n3\n0\nNA\nRL\nInside\n1Fam\n\n\n135900\n1716\n5687\n1912\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n119000\n1200\n8155\n1930\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n81000\n630\n1890\n1972\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n146000\n1100\n7500\n2006\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n64000\n670\n3500\n1945\n3\n0\nNA\nRL\nInside\n1Fam\n\n\n103200\n882\n5500\n1956\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n148000\n1534\n10800\n1895\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n110500\n866\n3880\n1945\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n127000\n1355\n6882\n1914\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n200500\n3086\n18030\n1946\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n150000\n1440\n7711\n1977\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n86000\n605\n9098\n1920\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n123600\n990\n8070\n1994\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n98500\n1195\n8741\n1946\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n79000\n774\n4270\n1931\n3\n0\nNA\nRH\nInside\n1Fam\n\n\n200000\n3395\n10896\n1914\n6\n0\nNA\nRH\nInside\n2fmCon\n\n\n150000\n2592\n10890\n1923\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n115000\n1517\n8500\n1919\n5\n0\nNA\nRM\nCorner\n1Fam\n\n\n150909\n1828\n9060\n1923\n5\nNA\nNA\nRM\nInside\n1Fam\n\n\n119600\n1991\n8250\n1895\n5\n0\nNA\nC (all)\nInside\n2fmCon\n\n\n147000\n1120\n8402\n2007\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n93900\n1092\n1495\n1970\n4\n0\nNA\nRM\nInside\nTwnhsE\n\n\n84500\n630\n1936\n1970\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n139500\n1142\n7733\n2005\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n132000\n1131\n13072\n2005\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n85500\n869\n5900\n1923\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n135000\n1192\n10800\n1949\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n119000\n1556\n8512\n1960\n5\n0\nNA\nRL\nCorner\nDuplex\n\n\n124000\n1025\n7000\n1962\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n64500\n1020\n4761\n1918\n3\n0\nNA\nC (all)\nCorner\n1Fam\n\n\n100000\n788\n7446\n1941\n4\n0\nNA\nRL\nCorner\n1Fam\n\n\n80500\n912\n6240\n1947\n4\n0\nNA\nRM\nInside\n1Fam\n\n\n72000\n819\n9000\n1919\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n117250\n914\n8050\n2002\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n81000\n1184\n8410\n1910\n5\n0\nNA\nRL\nFR2\n1Fam\n\n\n83000\n1414\n8248\n1922\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n102000\n1522\n6000\n1926\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n72000\n672\n8534\n1925\n4\n0\nNA\nRM\nInside\n1Fam\n\n\n115000\n1396\n9000\n1951\n5\n0\nNA\nC (all)\nInside\n2fmCon\n\n\n78000\n936\n8520\n1916\n3\n0\nNA\nC (all)\nInside\n1Fam\n\n\n92000\n630\n1533\n1970\n5\n0\nNA\nRM\nInside\nTwnhs\n\n\n90500\n1092\n1936\n1970\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n\n\n\n\n\nOption 3 (Most advanced): Line by line kable table. You can make this as complicated and customized as you like. This is a simple example of options\n\ndata_all |&gt; filter(is.na(garage_qual)) |&gt; \n  kbl(align = \"r\") |&gt; \n  kable_styling(bootstrap_options = c(\"striped\", \"condensed\")) |&gt; \n  scroll_box(height = \"500px\", width = \"100%\")\n\n\n\n\n\nsale_price\ngr_liv_area\nlot_area\nyear_built\noverall_qual\ngarage_cars\ngarage_qual\nms_zoning\nlot_config\nbldg_type\n\n\n\n\n115000\n864\n10500\n1971\n4\n0\nNA\nRL\nFR2\n1Fam\n\n\n128950\n1225\n9320\n1959\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n84900\n1728\n13260\n1962\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n116500\n858\n7207\n1958\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n76500\n1306\n5350\n1940\n3\n0\nNA\nRL\nInside\n1Fam\n\n\n76500\n2256\n9045\n1910\n5\n0\nNA\nRM\nInside\n2fmCon\n\n\n159900\n1560\n12900\n1912\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n55000\n1092\n5600\n1930\n4\n0\nNA\nRM\nInside\n2fmCon\n\n\n93369\n1884\n6449\n1907\n4\n0\nNA\nC (all)\nInside\n1Fam\n\n\n94000\n1020\n6342\n1875\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n136000\n1832\n10773\n1967\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n100000\n1664\n9825\n1965\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n90000\n960\n6410\n1958\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n100000\n1666\n9839\n1931\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n139000\n1824\n9400\n1971\n6\n0\nNA\nRL\nCorner\nDuplex\n\n\n76000\n1092\n1476\n1970\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n75500\n630\n1491\n1972\n4\n0\nNA\nRM\nInside\nTwnhsE\n\n\n88250\n1092\n1900\n1970\n4\n0\nNA\nRM\nInside\nTwnhsE\n\n\n136000\n1792\n9000\n1974\n5\n0\nNA\nRL\nFR2\nDuplex\n\n\n142000\n1114\n13072\n2004\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n82500\n708\n5330\n1940\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n129000\n1464\n9900\n1910\n5\n0\nNA\nRM\nCorner\n1Fam\n\n\n94550\n1701\n7627\n1920\n4\n0\nNA\nRM\nCorner\n2fmCon\n\n\n103000\n1447\n10134\n1910\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n37900\n968\n5925\n1910\n3\n0\nNA\nRM\nInside\n1Fam\n\n\n113000\n1452\n4456\n1920\n4\n0\nNA\nRM\nInside\n2fmCon\n\n\n58500\n816\n3300\n1910\n4\n0\nNA\nC (all)\nInside\n1Fam\n\n\n34900\n720\n7879\n1920\n4\n0\nNA\nC (all)\nInside\n1Fam\n\n\n60000\n800\n6120\n1936\n2\n0\nNA\nRM\nInside\n1Fam\n\n\n62500\n2128\n3000\n1922\n5\n0\nNA\nRM\nInside\nDuplex\n\n\n97500\n1864\n5852\n1902\n7\n0\nNA\nRM\nCorner\n2fmCon\n\n\n70000\n892\n5160\n1923\n4\n0\nNA\nRM\nInside\n1Fam\n\n\n179000\n1200\n10800\n1987\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n179000\n1200\n10800\n1987\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n61000\n904\n10020\n1922\n1\n0\nNA\nRL\nInside\n1Fam\n\n\n118000\n698\n9405\n1947\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n99900\n864\n4060\n1922\n5\n0\nNA\nRL\nCorner\n1Fam\n\n\n119900\n1678\n10926\n1959\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n112000\n833\n8780\n1985\n5\n0\nNA\nRL\nCorner\n1Fam\n\n\n141000\n1080\n7500\n2004\n7\n0\nNA\nRL\nInside\n1Fam\n\n\n106250\n1294\n10800\n1900\n4\n0\nNA\nRL\nInside\n2fmCon\n\n\n130000\n1800\n8513\n1961\n5\n0\nNA\nRL\nCorner\nDuplex\n\n\n120000\n1027\n5400\n1920\n7\n0\nNA\nRM\nInside\n1Fam\n\n\n95000\n1080\n5914\n1890\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n65000\n1588\n12205\n1949\n3\n0\nNA\nRM\nInside\n1Fam\n\n\n129400\n1540\n6000\n1905\n5\n0\nNA\nRM\nCorner\n1Fam\n\n\n160000\n1984\n8094\n1910\n6\n1\nNA\nRM\nInside\n2fmCon\n\n\n89500\n1406\n7920\n1920\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n79900\n1198\n5586\n1920\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n82375\n1344\n10320\n1915\n3\n0\nNA\nRM\nInside\n2fmCon\n\n\n127500\n1355\n10106\n1940\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n80000\n1006\n9000\n1959\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n260000\n1518\n19550\n1940\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n99600\n864\n9350\n1975\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n107500\n1347\n7000\n1910\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n79000\n1096\n9600\n1924\n6\n0\nNA\nRL\nCorner\n1Fam\n\n\n85000\n796\n8777\n1910\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n145900\n2200\n8777\n1900\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n82000\n1152\n6040\n1955\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n82000\n1152\n6012\n1955\n4\n0\nNA\nRL\nCorner\nDuplex\n\n\n118000\n1440\n12108\n1955\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n82500\n1152\n6845\n1955\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n91900\n784\n6931\n1955\n4\n0\nNA\nRL\nInside\n2fmCon\n\n\n120000\n1053\n12180\n1938\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n96000\n1137\n8050\n1947\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n98000\n864\n5604\n1925\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n67000\n864\n8248\n1914\n3\n0\nNA\nRL\nInside\n1Fam\n\n\n135900\n1716\n5687\n1912\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n119000\n1200\n8155\n1930\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n81000\n630\n1890\n1972\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n146000\n1100\n7500\n2006\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n64000\n670\n3500\n1945\n3\n0\nNA\nRL\nInside\n1Fam\n\n\n103200\n882\n5500\n1956\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n148000\n1534\n10800\n1895\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n110500\n866\n3880\n1945\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n127000\n1355\n6882\n1914\n6\n0\nNA\nRM\nInside\n1Fam\n\n\n200500\n3086\n18030\n1946\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n150000\n1440\n7711\n1977\n4\n0\nNA\nRL\nInside\nDuplex\n\n\n86000\n605\n9098\n1920\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n123600\n990\n8070\n1994\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n98500\n1195\n8741\n1946\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n79000\n774\n4270\n1931\n3\n0\nNA\nRH\nInside\n1Fam\n\n\n200000\n3395\n10896\n1914\n6\n0\nNA\nRH\nInside\n2fmCon\n\n\n150000\n2592\n10890\n1923\n5\n0\nNA\nRL\nInside\nDuplex\n\n\n115000\n1517\n8500\n1919\n5\n0\nNA\nRM\nCorner\n1Fam\n\n\n150909\n1828\n9060\n1923\n5\nNA\nNA\nRM\nInside\n1Fam\n\n\n119600\n1991\n8250\n1895\n5\n0\nNA\nC (all)\nInside\n2fmCon\n\n\n147000\n1120\n8402\n2007\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n93900\n1092\n1495\n1970\n4\n0\nNA\nRM\nInside\nTwnhsE\n\n\n84500\n630\n1936\n1970\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n139500\n1142\n7733\n2005\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n132000\n1131\n13072\n2005\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n85500\n869\n5900\n1923\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n135000\n1192\n10800\n1949\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n119000\n1556\n8512\n1960\n5\n0\nNA\nRL\nCorner\nDuplex\n\n\n124000\n1025\n7000\n1962\n5\n0\nNA\nRL\nInside\n2fmCon\n\n\n64500\n1020\n4761\n1918\n3\n0\nNA\nC (all)\nCorner\n1Fam\n\n\n100000\n788\n7446\n1941\n4\n0\nNA\nRL\nCorner\n1Fam\n\n\n80500\n912\n6240\n1947\n4\n0\nNA\nRM\nInside\n1Fam\n\n\n72000\n819\n9000\n1919\n5\n0\nNA\nRM\nInside\n1Fam\n\n\n117250\n914\n8050\n2002\n6\n0\nNA\nRL\nInside\n1Fam\n\n\n81000\n1184\n8410\n1910\n5\n0\nNA\nRL\nFR2\n1Fam\n\n\n83000\n1414\n8248\n1922\n4\n0\nNA\nRL\nInside\n1Fam\n\n\n102000\n1522\n6000\n1926\n5\n0\nNA\nRL\nInside\n1Fam\n\n\n72000\n672\n8534\n1925\n4\n0\nNA\nRM\nInside\n1Fam\n\n\n115000\n1396\n9000\n1951\n5\n0\nNA\nC (all)\nInside\n2fmCon\n\n\n78000\n936\n8520\n1916\n3\n0\nNA\nC (all)\nInside\n1Fam\n\n\n92000\n630\n1533\n1970\n5\n0\nNA\nRM\nInside\nTwnhs\n\n\n90500\n1092\n1936\n1970\n4\n0\nNA\nRM\nInside\nTwnhs\n\n\n\n\n\n\n\n\nCoding sidebar:\n\nIn the above example, we created a function (print_kbl()) from scratch (rather than using a function factory)\nSee functions chapter in Wickham, Çetinkaya-Rundel, and Grolemund (2023) for help.\nSee functionals chapter in Wickham (2019).\n\n\nIn this instance, if we consult our data dictionary, we see that NA for garage_qual should be coded as “no garage”. We will correct this in our data set.\nThis is a pretty poor choice on the part of the researchers who created the dataset because it becomes impossible to distinguish between NA that means no garage vs. true NA for the variable. In fact, if you later do really careful EDA on the full data set with all variables, you will see this problem likely exists in this dataset\nAnyway, let’s correct all the NA for garage_qual to “no_garage” using mutate()\n\ndata_all &lt;- data_all |&gt; \n1  mutate(garage_qual = fct_expand(garage_qual, \"no_garage\"),\n2         garage_qual = replace_na(garage_qual, \"no_garage\"))\n\n\n1\n\nFirst add a new level to the factor\n\n2\n\nThen recode NA to that new level\n\n\n\n\nWe will leave the NA for garage_cars as NA because its not clear if that is truly missing or not, based on further EDA not shown here.\n\nWe have one other issue with garage_qual. It is an ordinal variable but we never reviewed the order of its levels. The data dictionary indicates the levels are ordered (best to worst) as:\n\nEx (excellent)\nGd (good)\nTA (typical/average)\nFa (fair)\nPo (poor)\n\nAnd we might assume that no garage is even worse than a poor garage. Lets see what they are.\n\ndata_all$garage_qual |&gt; levels()\n\n[1] \"Ex\"        \"Fa\"        \"Gd\"        \"Po\"        \"TA\"        \"no_garage\"\n\n\nTo fix this, we can use forcats::fct_relevel().\n\n1gq_levels &lt;- c(\"no_garage\", \"Po\", \"Fa\", \"TA\", \"Gd\", \"Ex\")\ndata_all &lt;- data_all |&gt; \n2  mutate(garage_qual = fct_relevel(garage_qual, gq_levels))\n\n3data_all$garage_qual |&gt; levels()\n\n\n1\n\nMake a vector that indicates the valid levels in order\n\n2\n\nPass that into fct_relevel(). See ?fct_relevel for other ways to adjust the levels of a factor.\n\n3\n\nConfirm that the levels are now correct\n\n\n\n\n[1] \"no_garage\" \"Po\"        \"Fa\"        \"TA\"        \"Gd\"        \"Ex\"       \n\n\n\n\n2.3.6 Explore Min/Max Response for Numeric Variables\nWe should explore mins and maxes for all numeric variables to detect out of valid range numeric responses\nCould also do this for ordinal variables that are coded with numbers\n\ne.g., overall_qual (1-10) vs. garage_qual (no_garage, Po, Fa, TA, Gd, Ex)\nThis is only a temporary mutation of overall_qual for this check\n\nWe can use skim_some() again\n\np0 = min\np100 = max\n\n\ndata_all |&gt;\n  mutate(overall_qual = as.numeric(overall_qual)) |&gt; \n  skim_some()\n\n\n\n\nData summary\n\n\n\n\nName\n\n\nmutate(data_all, overall_…\n\n\n\n\nNumber of rows\n\n\n1955\n\n\n\n\nNumber of columns\n\n\n10\n\n\n\n\n_______________________\n\n\n\n\n\n\nColumn type frequency:\n\n\n\n\n\n\nfactor\n\n\n4\n\n\n\n\nnumeric\n\n\n6\n\n\n\n\n________________________\n\n\n\n\n\n\nGroup variables\n\n\nNone\n\n\n\n\n\nVariable type: factor\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nordered\n\n\nn_unique\n\n\ntop_counts\n\n\n\n\n\n\ngarage_qual\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n6\n\n\nTA: 1745, no_: 109, Fa: 79, Gd: 16\n\n\n\n\nms_zoning\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n7\n\n\nRL: 1530, RM: 297, FV: 91, C (: 19\n\n\n\n\nlot_config\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\nIns: 1454, Cor: 328, Cul: 114, FR2: 55\n\n\n\n\nbldg_type\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\n1Fa: 1631, Twn: 145, Dup: 77, Twn: 64\n\n\n\n\n\nVariable type: numeric\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\np0\n\n\np100\n\n\n\n\n\n\nsale_price\n\n\n0\n\n\n1\n\n\n12789\n\n\n745000\n\n\n\n\ngr_liv_area\n\n\n0\n\n\n1\n\n\n438\n\n\n5642\n\n\n\n\nlot_area\n\n\n0\n\n\n1\n\n\n1476\n\n\n215245\n\n\n\n\nyear_built\n\n\n0\n\n\n1\n\n\n1875\n\n\n2010\n\n\n\n\noverall_qual\n\n\n0\n\n\n1\n\n\n1\n\n\n10\n\n\n\n\ngarage_cars\n\n\n1\n\n\n1\n\n\n0\n\n\n4\n\n\n\n\n\n\n\n\n\n2.3.7 Explore All Responses for Categorical Variables\nWe should explore all unique responses for nominal variables\nMight also do this for ordinal variables that are coded with labels vs. numbers.\n\ndata_all |&gt; \n  select(where(is.factor)) |&gt;\n  walk(\\(column) print(levels(column)))\n\n[1] \"no_garage\" \"Po\"        \"Fa\"        \"TA\"        \"Gd\"        \"Ex\"       \n[1] \"A (agr)\" \"C (all)\" \"FV\"      \"I (all)\" \"RH\"      \"RL\"      \"RM\"     \n[1] \"Corner\"  \"CulDSac\" \"FR2\"     \"FR3\"     \"Inside\" \n[1] \"1Fam\"   \"2fmCon\" \"Duplex\" \"Twnhs\"  \"TwnhsE\"\n\n\nCoding sidebar:\n\nAbove, we demonstrate the use of an anonymous function (\\(column) print(levels(column))), which is a function we use once that we don’t bother to assign a name (since we won’t reuse it). We often use anonymous functions when using the functions from the purrr package (e.g., map(), walk())\nWe use walk() from the purrr package to apply our anonymous function to all columns of the data frame at once\nJust copy this code for now\nWe will see simpler uses later that will help you understand iteration with purrr functions\nSee the chapter on iteration in R for Data Science (2e) for more info on map() and walk()\n\n\n\n2.3.8 Tidy Responses for Categorical Variables\nFeature engineering with nominal and ordinal variables typically involves\n\nConverting to factors\nOften creating dummy features from these factors\n\nThis feature engineering will use response labels for naming new features\n\nTherefore, it is a good idea to have the responses snake-cased and cleaned up a bit so that these new feature names are clean/clear.\n\nHere is an easy way to convert responses for character variables to snake case using a function (tidy_responses()) we share in fun_eda.R (reproduced here).\n\nThis uses regular expressions (regex), which will will learn about in a later unit on text processing.\nYou could expand this cleaning function if you encounter other issues that need to be cleaned in the factor levels.\n\n\ntidy_responses &lt;- function(column){\n  # replace all non-alphanumeric with _\n  column &lt;- fct_relabel(column, \\(column) str_replace_all(column, \"\\\\W\", \"_\"))\n  # replace whitespace with _\n  column &lt;- fct_relabel(column, \\(column) str_replace_all(column, \"\\\\s+\", \"_\"))\n  # replace multiple _ with single _\n  column &lt;- fct_relabel(column, \\(column) str_replace_all(column, \"\\\\_+\", \"_\"))\n  #remove _ at end of string\n  column &lt;- fct_relabel(column, \\(column) str_replace_all(column, \"\\\\_$\", \"\"))\n  # remove _ at start of string\n  column &lt;- fct_relabel(column, \\(column) str_replace_all(column, \"\\\\^_\", \"\"))\n  # convert to lowercase\n  column &lt;- fct_relabel(column, tolower)\n  factor(column)\n}\n\nLet’s use the function\n\ndata_all &lt;- data_all |&gt; \n  mutate(across(where(is.factor), tidy_responses)) |&gt; \n  glimpse()\n\nRows: 1,955\nColumns: 10\n$ sale_price   &lt;dbl&gt; 215000, 105000, 172000, 189900, 213500, 191500, 236500, 1…\n$ gr_liv_area  &lt;dbl&gt; 1656, 896, 1329, 1629, 1338, 1280, 1616, 1804, 1655, 1465…\n$ lot_area     &lt;dbl&gt; 31770, 11622, 14267, 13830, 4920, 5005, 5389, 7500, 10000…\n$ year_built   &lt;dbl&gt; 1960, 1961, 1958, 1997, 2001, 1992, 1995, 1999, 1993, 199…\n$ overall_qual &lt;dbl&gt; 6, 5, 6, 5, 8, 8, 8, 7, 6, 6, 7, 8, 8, 8, 9, 4, 6, 6, 7, …\n$ garage_cars  &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, …\n$ garage_qual  &lt;fct&gt; ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, t…\n$ ms_zoning    &lt;fct&gt; rl, rh, rl, rl, rl, rl, rl, rl, rl, rl, rl, rl, rl, rl, r…\n$ lot_config   &lt;fct&gt; corner, inside, corner, inside, inside, inside, inside, i…\n$ bldg_type    &lt;fct&gt; 1fam, 1fam, 1fam, 1fam, twnhse, twnhse, twnhse, 1fam, 1fa…\n\n\nCoding sidebar: See more details on the tidy selection helpers like all_of() and where()\n\nAlas, these response labels were pretty poorly chosen so some didn’t convert well. And some are really hard to understand too.\n\nAvoid this problem and choose good response labels from the start for your own data\nHere, we show you what we got from using tidy_responses()\n\n\ndata_all |&gt; \n  select(where(is.factor)) |&gt;\n  walk(\\(column) print(levels(column)))\n\n[1] \"no_garage\" \"po\"        \"fa\"        \"ta\"        \"gd\"        \"ex\"       \n[1] \"a_agr\" \"c_all\" \"fv\"    \"i_all\" \"rh\"    \"rl\"    \"rm\"   \n[1] \"corner\"  \"culdsac\" \"fr2\"     \"fr3\"     \"inside\" \n[1] \"1fam\"   \"2fmcon\" \"duplex\" \"twnhs\"  \"twnhse\"\n\n\n\nLets clean them up a bit more manually\n\ndata_all &lt;- data_all |&gt; \n  mutate(ms_zoning = fct_recode(ms_zoning,\n                                res_low = \"rl\",\n                                res_med = \"rm\",\n                                res_high = \"rh\",\n                                float = \"fv\",\n                                agri = \"a_agr\",\n                                indus = \"i_all\",\n                                commer = \"c_all\"),\n1         bldg_type = fct_recode(bldg_type,\n                                one_fam = \"1fam\",\n                                two_fam = \"2fmcon\",\n                                town_end = \"twnhse\",\n                                town_inside = \"twnhs\"))\n\n\n1\n\nNote that I did not need to list all levels in the recode. Only the levels I wanted to change.\n\n\n\n\nThe full dataset is now clean!\n\n\n2.3.9 Train/Validate/Test Splits\nThe final task we typically do as part of the data preparation process is to split the full dataset into training, validation and test sets.\n\nTest sets are “typically” between 20-30% of your full dataset\n\nThere are costs and benefits to larger test sets\nWe will learn about these costs/benefits in the unit on resampling\nI have already held out the test set\n\nThere are many approaches to validation sets\n\nFor now (until unit 5) we will use a single validation set approach\nWe will use 25% of the remaining data (after holding out the test set) as a validation set for this example\n\nIt is typical to split data on the outcome within strata\n\nFor a categorical outcome, this makes the proportions of the response categories more balanced across the train, validation, and test sets\nFor a numeric outcome, we first break up the distribution into temporary bins (see breaks = 4 below) and then we split within these bins\n\nIMPORTANT: Set a seed so that you can reproduce these splits if you later do more cleaning\n\n\nset.seed(20110522)\nsplits &lt;- data_all |&gt; \n  initial_split(prop = 3/4, strata = \"sale_price\", breaks = 4)\n\n\nWe then extract the training set from the splits and save it\n\nTraining sets are used for “analysis”- hence the name of the function\n\n\nsplits |&gt; \n1  analysis() |&gt;\n  glimpse() |&gt; \n  write_csv(here::here(path_data, \"ames_clean_class_trn.csv\"))\n\n\n1\n\nanalysis() pulls out the training set from our split of data_all\n\n\n\n\nRows: 1,465\nColumns: 10\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;dbl&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;fct&gt; ta, ta, no_garage, ta, ta, ta, ta, no_garage, no_garage, …\n$ ms_zoning    &lt;fct&gt; res_high, res_low, res_low, res_low, res_low, res_med, re…\n$ lot_config   &lt;fct&gt; inside, corner, fr2, fr2, inside, inside, inside, inside,…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, town_inside, town_end, duplex,…\n\n\n\nWe will not need the validation set for modeling EDA\n\nIt should NOT be used for anything other than evaluating models to select the best model configuration\nWe do NOT do Modeling EDA or Model Fitting with the validation set\nSave it in this clean form for easy use when you need it\nWe use the validation set to “assess” models that we have fit in training sets - hence the name of the function\n\n\nsplits |&gt; \n1  assessment() |&gt;\n  glimpse() |&gt; \n  write_csv(here::here(path_data, \"ames_clean_class_val.csv\"))\n\n\n1\n\nassessment() pulls out the validation set from our split of data_all\n\n\n\n\nRows: 490\nColumns: 10\n$ sale_price   &lt;dbl&gt; 215000, 189900, 189000, 171500, 212000, 164000, 394432, 1…\n$ gr_liv_area  &lt;dbl&gt; 1656, 1629, 1804, 1341, 1502, 1752, 1856, 1004, 1092, 106…\n$ lot_area     &lt;dbl&gt; 31770, 13830, 7500, 10176, 6820, 12134, 11394, 11241, 168…\n$ year_built   &lt;dbl&gt; 1960, 1997, 1999, 1990, 1985, 1988, 2010, 1970, 1971, 197…\n$ overall_qual &lt;dbl&gt; 6, 5, 7, 7, 8, 8, 9, 6, 5, 6, 7, 9, 8, 8, 7, 8, 6, 5, 5, …\n$ garage_cars  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 3, 2, 3, 1, 1, 2, …\n$ garage_qual  &lt;fct&gt; ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, t…\n$ ms_zoning    &lt;fct&gt; res_low, res_low, res_low, res_low, res_low, res_low, res…\n$ lot_config   &lt;fct&gt; corner, inside, inside, inside, corner, inside, corner, c…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, one_fam, town_end, one_fam, on…"
  },
  {
    "objectID": "002_exploratory_data_analysis.html#exploratory-data-analysis-for-modeling",
    "href": "002_exploratory_data_analysis.html#exploratory-data-analysis-for-modeling",
    "title": "2  Exploratory Data Analysis",
    "section": "2.4 Exploratory Data Analysis for Modeling",
    "text": "2.4 Exploratory Data Analysis for Modeling\nNow let’s begin our Modeling EDA\nWe prefer to write separate scripts for Cleaning vs, Modeling EDA (but not displayed here)\n\nThis keeps these two processes separate in our minds\nCleaning EDA is done with full dataset but Modeling EDA is only done with a training set - NEVER use validation or test set\n\n\nLets re-load (and glimpse) our training set to pretend we are at the start of a new script.\nNow that we are done cleaning the data, we should start to fully class our variables for how we will use them for modeling EDA and modeling more generally.\n\nNumeric predictors are classes as numeric (int or double)\ncategorical predictors are classed as unordered or ordered factors.\n\n\n data_trn &lt;- read_csv(here::here(path_data, \"ames_clean_class_trn.csv\")) |&gt; \n  glimpse()\n\nRows: 1,465\nColumns: 10\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;dbl&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;chr&gt; \"ta\", \"ta\", \"no_garage\", \"ta\", \"ta\", \"ta\", \"ta\", \"no_gara…\n$ ms_zoning    &lt;chr&gt; \"res_high\", \"res_low\", \"res_low\", \"res_low\", \"res_low\", \"…\n$ lot_config   &lt;chr&gt; \"inside\", \"corner\", \"fr2\", \"fr2\", \"inside\", \"inside\", \"in…\n$ bldg_type    &lt;chr&gt; \"one_fam\", \"one_fam\", \"one_fam\", \"town_inside\", \"town_end…\n\n\nOpps:\n\nNotice that overall_qual is back to being classed as numeric (dbl).\n\nThis is because read_csv() guesses the type for each column and we used only numbers for this ordinal categorical variable.\n\n\nNotice that your factors are back to character\n\nThis is because csv files don’t save anything other than the values (labels for factors). They are the cleaned labels though!\n\nYou should class all variables using the same approach as before (often just a copy/paste). My preferred way is via mutates\n\n\n data_trn &lt;- \n  read_csv(here::here(path_data, \"ames_clean_class_trn.csv\"), \n1           col_types = cols()) |&gt;\n2  mutate(across(where(is.character), factor)) |&gt;\n3  mutate(overall_qual = factor(overall_qual),\n4         overall_qual = fct_relevel(overall_qual, as.character(1:10)),\n         garage_qual = fct_relevel(garage_qual, c(\"no_garage\", \"po\", \"fa\", \n5                                                  \"ta\", \"gd\", \"ex\"))) |&gt;\n  glimpse()\n\n\n1\n\nuse col_types = cols() to suppress messages about default class assignments\n\n2\n\nuse mutate() with across() to change all character variables to factors\n\n3\n\nuse mutate() with factor() to change numeric variable to factor.\n\n4\n\nuse mutate() with fct_relevel() to explicitly set levels of an ordered factor\n\n5\n\nnotice the warning about the unknown level. Always explore warnings! In this instance, its fine. There were only two observations with ex and neither ended up in the training split. Still best to include this level to note it exists!\n\n\n\n\nRows: 1,465\nColumns: 10\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;fct&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;fct&gt; ta, ta, no_garage, ta, ta, ta, ta, no_garage, no_garage, …\n$ ms_zoning    &lt;fct&gt; res_high, res_low, res_low, res_low, res_low, res_med, re…\n$ lot_config   &lt;fct&gt; inside, corner, fr2, fr2, inside, inside, inside, inside,…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, town_inside, town_end, duplex,…\n\n\n\nCoding sidebar: We will likely re-class the Ames dataset many times (for training, validation, test). We could copy/paste these mutates each time but whenever you do something more than twice, I recommend writing a function. We might write this one to re-class the ames variables\n\nclass_ames &lt;- function(df){\n  \n  df |&gt;\n    mutate(across(where(is.character), factor)) |&gt; \n    mutate(overall_qual = factor(overall_qual), \n           overall_qual = fct_relevel(overall_qual, as.character(1:10)), \n           garage_qual = fct_relevel(garage_qual, c(\"no_garage\", \"po\", \"fa\", \n                                                    \"ta\", \"gd\", \"ex\")))\n}\n\nNow we can use it every time we read in one of the Ames datasets\n\ndata_trn &lt;- \n  read_csv(here::here(path_data, \"ames_clean_class_trn.csv\"), col_types = cols()) |&gt; \n  class_ames() |&gt; \n  glimpse()\n\nRows: 1,465\nColumns: 10\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;fct&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;fct&gt; ta, ta, no_garage, ta, ta, ta, ta, no_garage, no_garage, …\n$ ms_zoning    &lt;fct&gt; res_high, res_low, res_low, res_low, res_low, res_med, re…\n$ lot_config   &lt;fct&gt; inside, corner, fr2, fr2, inside, inside, inside, inside,…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, town_inside, town_end, duplex,…\n\n\n\nThere are 3 basic types of Modeling EDA you should always do\n\nExplore missingness for predictors\nExplore univariate distributions for outcome and predictors\nExplore bivariate relationships between predictors and outcome\n\nAs a result of this exploration, we will:\n\nIdentify promising predictors\nDetermine appropriate feature engineering for those predictors (e.g., transformations)\nIdentify outliers and consider how to handle when model building\nConsider how to handle imputation for missing data (if any)\n\n\n2.4.1 Overall Summary of Feature Matrix\nBefore we dig into individual variables and their distributions and relationships with the outcome, it’s nice to start with a big picture of the dataset\n\nWe use another customized version of skim() from the skimr package to provide this\nJust needed to augment it with skewness and kurtosis statistics for numeric variables\nand remove histogram b/c we don’t find that small histogram useful\nincluded in fun_eda.R on github\n\n\nskew_na &lt;- partial(e1071::skewness, na.rm = TRUE)\nkurt_na &lt;- partial(e1071::kurtosis, na.rm = TRUE)\n\nskim_all &lt;- skimr::skim_with(numeric = skimr::sfl(skew = skew_na, \n                                                  kurtosis = kurt_na, \n                                                  hist = NULL))\n\n\ndata_trn |&gt; \n  skim_all()\n\n\n\n\nData summary\n\n\n\n\nName\n\n\ndata_trn\n\n\n\n\nNumber of rows\n\n\n1465\n\n\n\n\nNumber of columns\n\n\n10\n\n\n\n\n_______________________\n\n\n\n\n\n\nColumn type frequency:\n\n\n\n\n\n\nfactor\n\n\n5\n\n\n\n\nnumeric\n\n\n5\n\n\n\n\n________________________\n\n\n\n\n\n\nGroup variables\n\n\nNone\n\n\n\n\n\nVariable type: factor\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nordered\n\n\nn_unique\n\n\ntop_counts\n\n\n\n\n\n\noverall_qual\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n10\n\n\n5: 424, 6: 350, 7: 304, 8: 176\n\n\n\n\ngarage_qual\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\nta: 1312, no_: 81, fa: 57, gd: 13\n\n\n\n\nms_zoning\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n7\n\n\nres: 1157, res: 217, flo: 66, com: 13\n\n\n\n\nlot_config\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\nins: 1095, cor: 248, cul: 81, fr2: 39\n\n\n\n\nbldg_type\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\none: 1216, tow: 108, dup: 63, tow: 46\n\n\n\n\n\nVariable type: numeric\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nmean\n\n\nsd\n\n\np0\n\n\np25\n\n\np50\n\n\np75\n\n\np100\n\n\nskew\n\n\nkurtosis\n\n\n\n\n\n\nsale_price\n\n\n0\n\n\n1\n\n\n180696.15\n\n\n78836.41\n\n\n12789\n\n\n129500\n\n\n160000\n\n\n213500\n\n\n745000\n\n\n1.64\n\n\n4.60\n\n\n\n\ngr_liv_area\n\n\n0\n\n\n1\n\n\n1506.84\n\n\n511.44\n\n\n438\n\n\n1128\n\n\n1450\n\n\n1759\n\n\n5642\n\n\n1.43\n\n\n5.19\n\n\n\n\nlot_area\n\n\n0\n\n\n1\n\n\n10144.16\n\n\n8177.55\n\n\n1476\n\n\n7500\n\n\n9375\n\n\n11362\n\n\n164660\n\n\n11.20\n\n\n182.91\n\n\n\n\nyear_built\n\n\n0\n\n\n1\n\n\n1971.35\n\n\n29.65\n\n\n1880\n\n\n1953\n\n\n1972\n\n\n2000\n\n\n2010\n\n\n-0.54\n\n\n-0.62\n\n\n\n\ngarage_cars\n\n\n1\n\n\n1\n\n\n1.78\n\n\n0.76\n\n\n0\n\n\n1\n\n\n2\n\n\n2\n\n\n4\n\n\n-0.26\n\n\n0.10\n\n\n\n\n\n\n\nCareful review of this output provides a great orientation to our data\n\n\n2.4.2 Univariate Distributions\nExploration of univariate distributions are useful to\n\nUnderstand variation and distributional shape\nMay suggest need to consider transformations as part of feature engineering\nCan identify univariate outliers (valid but disconnected from distribution so not detected in cleaning)\n\nWe generally select different visualizations and summary statistics for categorical vs. numeric variables\n\n2.4.2.1 Categorical Variables\n\n2.4.2.1.1 Barplots\nThe primary visualization for categorical variables is the bar plot\nDefine and customize it within a function for repeated use. We share this and all the remaining plots used in this unit in fun_plot.R. Source it to use them without having to re-code each time\n\nplot_bar &lt;- function(df, x){\n  x_label_size &lt;- if_else(skimr::n_unique(df[[x]]) &lt; 7, 11, 7)\n  \n  df |&gt;\n    ggplot(aes(x = .data[[x]])) +\n    geom_bar() +\n    theme(axis.text.x = element_text(angle = 90, size = x_label_size, vjust = 0.5, hjust = 1),\n          axis.text.y = element_text(size = 11))\n}\n\nCoding sidebar: When defining functions, generally put data as first argument so you can pipe in data using tidy pipelines\nThere are pros and cons to writing functions that accept variable names that are quoted vs. unquoted\n\nIt depends a bit on how you will use them.\n.data[[argument]] is used in functions with quoted arguments\nembracing {{}} is used for unquoted arguments\nFor these plot functions, I use quoted variable names and then pipe those into map() to make multiple plots (see below)\nsee ?vignette(\"programming\") or info on tidy evaluation in Wickham, Çetinkaya-Rundel, and Grolemund (2023) for more details\n\n\nBar plots reveal low frequency responses for nominal and ordinal variables\n\nSee bldg_type\n\n\ndata_trn |&gt; plot_bar(\"bldg_type\")\n\n\n\n\n\nBar plots can display distributional shape for ordinal variables. May suggest the need for transformations if we later treat the ordinal variable as numeric\n\nSee overall_qual. Though it is not very skewed.\n\n\ndata_trn |&gt; plot_bar(\"overall_qual\")\n\n\n\n\n\nCoding sidebar:\nWe can make all of our plots iteratively using map() from the `purrr package.\n\ndata_trn |&gt; \n1  select(where(is.factor)) |&gt;\n2  names() |&gt;\n3  map(\\(name) plot_bar(df = data_trn, x = name)) |&gt;\n4  plot_grid(plotlist = _, ncol = 2)\n\n\n1\n\nSelect only the factor columns\n\n2\n\nGet their names as strings (that is why we use quoted variables in these plot functions\n\n3\n\nUse map() to iterative plot_bar() over every column. (see iteration in Wickham, Çetinkaya-Rundel, and Grolemund (2023))\n\n4\n\nUse plot_grid() from cowplot package to display the list of plots in a grid\n\n\n\n\n\n\n\n\n\n2.4.2.1.2 Tables\nWe tend to prefer visualizations vs. summary statistics for EDA. However, tables can be useful.\nHere is a function that was described in Wickham, Çetinkaya-Rundel, and Grolemund (2023) that we like because\n\nIncludes counts and proportions\nIncludes NA as a category\n\nWe have included it in fun_eda.R for your use.\n\ntab &lt;- function(df, var, sort = FALSE) {\n  df |&gt;  dplyr::count({{ var }}, sort = sort) |&gt; \n    dplyr::mutate(prop = n / sum(n))\n} \n\nTables can be used to identify responses that have very low frequency and to think about the need to handle missing values\n\nSee ms_zoning\nMay want to collapse low frequency (or low percentage) categories to reduce the number of features needed to represent the predictor\n\n\ndata_trn |&gt; tab(ms_zoning)\n\n# A tibble: 7 × 3\n  ms_zoning     n     prop\n  &lt;fct&gt;     &lt;int&gt;    &lt;dbl&gt;\n1 agri          2 0.00137 \n2 commer       13 0.00887 \n3 float        66 0.0451  \n4 indus         1 0.000683\n5 res_high      9 0.00614 \n6 res_low    1157 0.790   \n7 res_med     217 0.148   \n\n\n\nor maybe sorted\n\n\ndata_trn |&gt; tab(ms_zoning, sort = TRUE)\n\n# A tibble: 7 × 3\n  ms_zoning     n     prop\n  &lt;fct&gt;     &lt;int&gt;    &lt;dbl&gt;\n1 res_low    1157 0.790   \n2 res_med     217 0.148   \n3 float        66 0.0451  \n4 commer       13 0.00887 \n5 res_high      9 0.00614 \n6 agri          2 0.00137 \n7 indus         1 0.000683\n\n\nbut could see this with plot as well\n\ndata_trn |&gt; plot_bar(\"ms_zoning\")\n\n\n\n\n\n\n\n2.4.2.2 Numeric Variables\n\n2.4.2.2.1 Histograms\nHistograms are a useful/common visualization for numeric variables\nLet’s define a histogram function (included in fun_plots.r)\n\nBin size should be explored a bit to find best representation\nSomewhat dependent on n (my default here is based on this training set)\nThis is one of the limitations of histograms\n\n\nplot_hist &lt;- function(df, x, bins = 100){\n  df |&gt;\n    ggplot(aes(x = .data[[x]])) +\n    geom_histogram(bins = bins) +\n    theme(axis.text.x = element_text(size = 11),\n          axis.text.y = element_text(size = 11))\n}\n\nLet’s look at sale_price\n\nIt is positively skewed\nMay suggest units (dollars) are not interval in nature (makes sense)\nCould cause problems for some algorithms (e.g., lm) when features are normal\n\n\ndata_trn |&gt; plot_hist(\"sale_price\")\n\n\n\n\n\n\n2.4.2.2.2 Smoothed Frequency Polygons\nFrequency polygons are also commonly used\nDefine a frequency polygon function and use it (included in fun_plots.r)\n\nBins may matter again\n\n\nplot_freqpoly &lt;- function(df, x, bins = 50){\n  df |&gt;\n    ggplot(aes(x = .data[[x]])) +\n    geom_freqpoly(bins = bins) +\n    theme(axis.text.x = element_text(size = 11),\n          axis.text.y = element_text(size = 11))\n}\n\n\ndata_trn |&gt; plot_freqpoly(\"sale_price\")\n\n\n\n\n\n\n2.4.2.2.3 Simple Boxplots\nBoxplots display\n\nMedian as line\n25%ile and 75%ile as hinges\nHighest and lowest points within 1.5 * IQR (interquartile-range: difference between scores at 25% and 75%iles)\nOutliers outside of 1.5 * IQR\n\nDefine a boxplot function and use it (included in fun_plots.r)\n\nplot_boxplot &lt;- function(df, x){\n  x_label_size &lt;- if_else(skimr::n_unique(df[[x]]) &lt; 7, 11, 7)\n  \n  df |&gt;\n    ggplot(aes(x = .data[[x]])) +\n    geom_boxplot() +\n    theme(axis.text.y = element_blank(),\n          axis.ticks.y = element_blank(),\n          axis.text.x = element_text(angle = 90, size = x_label_size, vjust = 0.5, hjust = 1))\n}\n\n\ndata_trn |&gt; plot_boxplot(\"sale_price\")\n\n\n\n\n\n\n2.4.2.2.4 Combined Boxplot and Violin Plots\nThe combination of a boxplot and violin plot is particularly useful\n\nThis is our favorite\nGet all the benefits of the boxplot\nCan clearly see shape of distribution given the violin plot overlay\nCan also clearly see the tails\n\nDefine a combined plot (included in fun_plots.r)\n\nplot_box_violin &lt;- function(df, x){\n  x_label_size &lt;- if_else(skimr::n_unique(df[[x]]) &lt; 7, 11, 7)\n  \n  df |&gt;\n    ggplot(aes(x = .data[[x]])) +\n    geom_violin(aes(y = 0), fill = \"green\", color = NA) +\n    geom_boxplot(width = .1, fill = NA, lwd = 1.1, fatten = 1.1) +\n    theme(axis.text.y = element_blank(),\n          axis.ticks.y = element_blank(),\n          axis.title.y = element_blank(),\n          axis.text.x = element_text(angle = 90, size = x_label_size, vjust = 0.5, hjust = 1))\n}\n\nHere is the plot for sale_price\n\nIn this instance, the skew is NOT due to only a few outliers\n\n\ndata_trn |&gt; plot_box_violin(\"sale_price\")\n\n\n\n\n\nCoding sidebar:\n\nYou can make figures for all numeric variables at once using select() and map() as before\n\n\ndata_trn |&gt; \n1  select(where(is.numeric)) |&gt;\n  names() |&gt; \n  map(\\(name) plot_box_violin(df = data_trn, x = name)) |&gt; \n  plot_grid(plotlist = _, ncol = 2)\n\n\n1\n\nNow select numeric rather than factor but otherwise same as previous example\n\n\n\n\n\n\n\n\n\n2.4.2.2.5 Summary Statistics\nskim_all() provided all the summary statistics you likely needed for numeric variables\n\nmean & median (p50)\nsd & IQR (see difference between p25 and p75)\nskew & kurtosis\n\nYou can get skim of only numeric variables if you like\n\ndata_trn |&gt; \n  select(where(is.numeric)) |&gt; \n  skim_all()\n\n\n\n\nData summary\n\n\n\n\nName\n\n\nselect(data_trn, where(is…\n\n\n\n\nNumber of rows\n\n\n1465\n\n\n\n\nNumber of columns\n\n\n5\n\n\n\n\n_______________________\n\n\n\n\n\n\nColumn type frequency:\n\n\n\n\n\n\nnumeric\n\n\n5\n\n\n\n\n________________________\n\n\n\n\n\n\nGroup variables\n\n\nNone\n\n\n\n\n\nVariable type: numeric\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nmean\n\n\nsd\n\n\np0\n\n\np25\n\n\np50\n\n\np75\n\n\np100\n\n\nskew\n\n\nkurtosis\n\n\n\n\n\n\nsale_price\n\n\n0\n\n\n1\n\n\n180696.15\n\n\n78836.41\n\n\n12789\n\n\n129500\n\n\n160000\n\n\n213500\n\n\n745000\n\n\n1.64\n\n\n4.60\n\n\n\n\ngr_liv_area\n\n\n0\n\n\n1\n\n\n1506.84\n\n\n511.44\n\n\n438\n\n\n1128\n\n\n1450\n\n\n1759\n\n\n5642\n\n\n1.43\n\n\n5.19\n\n\n\n\nlot_area\n\n\n0\n\n\n1\n\n\n10144.16\n\n\n8177.55\n\n\n1476\n\n\n7500\n\n\n9375\n\n\n11362\n\n\n164660\n\n\n11.20\n\n\n182.91\n\n\n\n\nyear_built\n\n\n0\n\n\n1\n\n\n1971.35\n\n\n29.65\n\n\n1880\n\n\n1953\n\n\n1972\n\n\n2000\n\n\n2010\n\n\n-0.54\n\n\n-0.62\n\n\n\n\ngarage_cars\n\n\n1\n\n\n1\n\n\n1.78\n\n\n0.76\n\n\n0\n\n\n1\n\n\n2\n\n\n2\n\n\n4\n\n\n-0.26\n\n\n0.10\n\n\n\n\n\n\n\n\n\n\n\n2.4.3 Bivariate Relationships with Outcome\nBivariate relationships with the outcome are useful to detect\n\nWhich predictors display some relationship with the outcome\nWhat feature engineering (transformations) might maximize that relationship\nAre there any bivariate (model) outliers\n\nAgain, we prefer visualizations but summary statistics are also available\n\n2.4.3.1 Both Numeric\n\n2.4.3.1.1 Scatterplots\nScatterplots are the preferred visualization when both variables are numeric\nDefine a scatterplot function (included in fun_plots.r)\n\nadd a simple line\nadd a LOWESS line (Locally Weighted Scatterplot Smoothing)\nThese lines are useful for considering shape of relationship\n\n\nplot_scatter &lt;- function(df, x, y){\n  df |&gt;\n    ggplot(aes(x = .data[[x]], y = .data[[y]])) +\n    geom_point() +\n    geom_smooth(method = \"lm\", formula = y ~ x, col = \"red\") +\n    geom_smooth(method = \"loess\", formula = y ~ x, col = \"green\") +\n    theme(axis.text.x = element_text(size = 11),\n          axis.text.y = element_text(size = 11))\n}\n\n\nLet’s consider relationship between gr_liv_area and sale_price\n\nCare most about influential points (both model outlier and leverage)\nCan be typically spotted in bivariate plots (but could do more sophisticated assessments)\nWe might:\n\nretain as is\ndrop\nbring to fence\n\n\nIf bivariate outliers are detected, you should return to cleaning mode to verify that they aren’t result of scoring/coding errors. If they are:\n\nFix in full dataset\nUse same train/test split after fixing\n\n\ndata_trn |&gt; plot_scatter(\"gr_liv_area\", \"sale_price\")\n\n\n\n\n\nHere is another example where the relationship might be non-linear\n\ndata_trn |&gt; plot_scatter(\"year_built\", \"sale_price\")\n\n\n\n\n\nA transformation of sale_price might help the relationship with \\(year\\_built\\) but might hurt gr_liv_area\nMaybe need to transform both sale_price and gr_liv_area as both were skewed\nThis might require some more EDA but here is a start\n\nQuick and temporary Log (base e) of sale_price\nThis doesn’t seem promising by itself\n\n\ndata_trn |&gt; \n  mutate(sale_price = log(sale_price)) |&gt; \n  plot_scatter(\"gr_liv_area\", \"sale_price\")\n\n\n\ndata_trn |&gt; \n  mutate(sale_price = log(sale_price)) |&gt;\n  plot_scatter(\"year_built\", \"sale_price\")\n\n\n\n\n\nCan make scatterplots for ordered factors as well\n\nBut other (perhaps better) options also exist for this combination of variable classes.\nUse as.numeric() to allow for lm and LOWESS lines on otherwise categorical variable\n\n\ndata_trn |&gt; \n  mutate(overall_qual = as.numeric(overall_qual)) |&gt; \n  plot_scatter(\"overall_qual\", \"sale_price\")\n\n\n\n\n\nCoding sidebar: Use jitter() with x to help with overplotting\n\ndata_trn |&gt; \n  mutate(overall_qual = jitter(as.numeric(overall_qual))) |&gt; \n  plot_scatter(\"overall_qual\", \"sale_price\")\n\n\n\n\n\nWhen the dataset is large, overplotting can even be a problem with true numeric variables\n\nYou can bin the values to remove this problem\nContinue to use lm and LOWESS lines\nThis dataset doesn’t have much of an overplotting problem but…..\n\n\nplot_hexbin &lt;- function(df, x, y){\n  df |&gt;\n    ggplot(aes(x = .data[[x]], y = .data[[y]])) +\n    geom_hex() +\n    geom_smooth(method = \"lm\", col = \"red\") +\n    geom_smooth(method = \"loess\", col = \"green\")  +\n    theme(axis.text.x = element_text(size = 11),\n          axis.text.y = element_text(size = 11))\n}\n\n\ndata_trn |&gt; plot_hexbin(\"gr_liv_area\", \"sale_price\")\n\n\n\n\n\n\n\n2.4.3.1.2 Correlations & Plots\nCorrelations are useful summary statistics for numeric variables\nSome statistical algorithms are sensitive to high correlations among features (multi-collinearity)\nAt best, highly correlated features add unnecessary flexibility and can lead to overfitting\nWe can visualize correlations among predictors/features using corrplot.mixed() from corrplot package\n\nBest for numeric variables\nCan include ordered categorical or two level unordered categorical variables if transformed to numeric\nCan include unordered categorical variables with &gt; 2 levels if first transformed appropriately (e.g., dummy features, not demonstrated yet)\nWorks best with relatively small set of variables\nNeed to consider how to handle missing values\n\n\ndata_trn |&gt; \n  mutate(overall_qual = as.numeric(overall_qual),\n         garage_qual = as.numeric(garage_qual)) |&gt; \n  select(where(is.numeric)) |&gt; \n  cor(use = \"pairwise.complete.obs\") |&gt; \n  corrplot::corrplot.mixed()\n\n\n\n\ncoding sidebar Note use of namespace (corrplot::corrplot.mixed()) to call this function from corrplot\n\n\n\n2.4.3.2 Categorical and Numeric\n\n2.4.3.2.1 Grouped Box + Violin Plots\nA grouped version of the combined box and violin plot is our preferred visualization for relationship between categorical and numeric variables (included in fun_plots.r)\n\nOften best when feature is categorical and outcome is numeric but can reverse\nCan use with ordered or unordered categorical variable\nWickham, Çetinkaya-Rundel, and Grolemund (2023) also describes use of grouped frequency polygons for this combination of variable classes\n\n\nplot_grouped_box_violin &lt;- function(df, x, y){\n  x_label_size &lt;- if_else(skimr::n_unique(df[[x]]) &lt; 7, 11, 7)\n  \n  df |&gt;\n    ggplot(aes(x = .data[[x]], y = .data[[y]])) +\n    geom_violin(fill = \"green\", color = NA) +\n    geom_boxplot(width = .1, fill = NA, lwd = 1.1, fatten = 1.1) +\n    theme(axis.text.x = element_text(angle = 90, size = x_label_size, \n                                     vjust = 0.5, hjust = 1),\n          axis.text.y = element_text(size = 11))\n}\n\nHere is the relationship between overall_qual and sale_price\n\nTend to prefer this over the scatterplot (with as.numeric()) for ordered categorical variables\nIncreasing spread of sale_price at higher levels of overall_qual is clearer in this plot\n\n\ndata_trn |&gt; plot_grouped_box_violin(\"overall_qual\", \"sale_price\")\n\n\n\n\n\nHere is a box + violin with an unordered categorical variable\n\nMore variation and skew in sale_price for one family homes (additional features, moderators?)\nPosition of townhouse (interior vs. exterior) seems to matter (don’t collapse?)\n\n\ndata_trn |&gt; plot_grouped_box_violin(\"bldg_type\", \"sale_price\")\n\n\n\n\n\nWhen we have a categorical predictor (ordered or unordered) and a numeric outcome, we often want to see both the relationship between the variables AND the variability on the categorical variable alone. We like this combined plot enough when doing EDA to provide a specific function (included in fun_plots.r)! It is our go to for understanding the potential effect of a categorical predictor\n\nplot_categorical &lt;- function(df, x, y, ordered = FALSE){\n  if (ordered) {\n    df &lt;- df |&gt;\n      mutate(!!x := fct_reorder(.data[[x]], .data[[y]]))\n  }\n  \n  x_label_size &lt;- if_else(skimr::n_unique(df[[x]]) &lt; 7, 11, 7)\n  \n  p_bar &lt;- df |&gt;\n    ggplot(aes(x = .data[[x]])) +\n    geom_bar()  +\n    theme(axis.text.x = element_text(angle = 90, size = x_label_size, \n                                     vjust = 0.5, hjust = 1),\n          axis.text.y = element_text(size = 11))\n  \n  p_box &lt;- df |&gt;\n    ggplot(aes(x = .data[[x]], y = .data[[y]])) +\n    geom_violin(fill = \"green\", color = NA) +\n    geom_boxplot(width = .1, fill = NA, lwd = 1.1, fatten = 1.1) +\n    theme(axis.text.x = element_text(angle = 90, size = x_label_size, \n                                     vjust = 0.5, hjust = 1),\n          axis.text.y = element_text(size = 11))\n  \n  return(list(p_bar, p_box))\n}\n\n\ndata_trn |&gt; plot_categorical(\"bldg_type\", \"sale_price\") |&gt; \n  plot_grid(plotlist = _, ncol = 1)\n\n\n\n\n\n\n\n2.4.3.3 Both Categorical\n\n2.4.3.3.1 Stacked Barplots\nStacked Barplots:\n\nCan be useful with both ordered and unordered categorical variables\nCan create with either raw counts or percentages.\n\nDisplays different perspective (particularly with uneven distributions across levels)\nDepends on your question\n\nOften, you will place the outcome on the x-axis and the feature is coded by fill\n\n\nplot_grouped_barplot_count &lt;- function(df, x, y){\n  x_label_size &lt;- if_else(skimr::n_unique(df[[x]]) &lt; 7, 11, 7)\n  \n  df |&gt;\n    ggplot(aes(x = .data[[y]], fill = .data[[x]])) +\n    geom_bar(position = \"stack\") +\n    theme(axis.text.x = element_text(angle = 90, size = x_label_size, \n                                     vjust = 0.5, hjust = 1),\n          axis.text.y = element_text(size = 11))\n}\n\nplot_grouped_barplot_percent &lt;- function(df, x, y){\n  x_label_size &lt;- if_else(skimr::n_unique(df[[x]]) &lt; 7, 11, 7)\n  \n  df |&gt;\n    ggplot(aes(x = .data[[y]], fill = .data[[x]])) +\n    geom_bar(position = \"fill\") +\n    labs(y = \"Proportion\") +\n    theme(axis.text.x = element_text(angle = 90, size = x_label_size, \n                                     vjust = 0.5, hjust = 1),\n          axis.text.y = element_text(size = 11))\n}\n\n\nFor example, if we wanted to learn about how bldg_type varies by lot_config, see these plots\n\ndata_trn |&gt; plot_grouped_barplot_count(\"lot_config\", \"bldg_type\")\n\n\n\n\n\ndata_trn |&gt; plot_grouped_barplot_percent(\"lot_config\", \"bldg_type\")\n\n\n\n\n\nMay want to plot both ways\n\ndata_trn |&gt; plot_grouped_barplot_percent(\"lot_config\", \"bldg_type\")\n\n\n\n\n\ndata_trn |&gt; plot_grouped_barplot_percent(\"bldg_type\", \"lot_config\")\n\n\n\n\n\n\n2.4.3.3.2 Tile Plot\nTile plots may be useful if both categorical variables are ordered\n\nplot_tile &lt;- function(df, x, y){\n  df |&gt;\n    count(.data[[x]], .data[[y]]) |&gt;\n    ggplot(aes(x = .data[[x]], y = .data[[y]])) +\n    geom_tile(mapping = aes(fill = n))\n}\n\n\ndata_trn |&gt; plot_tile(\"overall_qual\", \"garage_qual\")\n\n\n\n\n\nYou might also consider a scatterplot with jitter in this instance\n\ndata_trn |&gt; \n  mutate(overall_qual = jitter(as.numeric(overall_qual)),\n         garage_qual = as.numeric(garage_qual)) |&gt; \n  plot_scatter(\"overall_qual\", \"garage_qual\")\n\n\n\n\n\n\n2.4.3.3.3 Two-way Tables\nTwo-way tables are sometimes a useful summary statistic for two categorical variables. We can use tabyl() from the janitor package for this\nFor example, the relationship between bldg_type and lot_config\n\ndata_trn |&gt; janitor::tabyl(bldg_type, lot_config)\n\n   bldg_type corner culdsac fr2 fr3 inside\n      duplex     13       0   3   0     47\n     one_fam    221      73  29   1    892\n    town_end      8       5   3   0     92\n town_inside      0       3   3   0     40\n     two_fam      6       0   1   1     24"
  },
  {
    "objectID": "002_exploratory_data_analysis.html#working-with-recipes",
    "href": "002_exploratory_data_analysis.html#working-with-recipes",
    "title": "2  Exploratory Data Analysis",
    "section": "2.5 Working with Recipes",
    "text": "2.5 Working with Recipes\nRecipes are used for feature engineering in tidymodels using the recipes package\n\nUsed for transforming raw predictors into features used in our models\nDescribes all steps to make feature matrix. For example:\n\nTransforming factors into “dummy” features if needed\nLinear and non-linear transformations (e.g., log, box-cox)\nPolynomials and interactions (i.e., x1 * x1 or x1 * x2)\nMissing value imputations\n\nProper use of recipes is an important tool to prevent data leakage between train and either validation or test.\nRecipes use only information from the training set in all feature engineering\nConsider example of standardizing x1 for a feature in train vs. validation and test. Must use mean and sd from TRAIN to standardize x1 in train, validate, and test. VERY IMPORTANT.\n\nWe use recipes in a two step process - prep() and bake()\n\n“Prepping” a recipe involves calculating any statistics needed for the transformations that will be applied to engineer features (e.g., mean and standard deviation to normalize a numeric variable).\n\nPrepping is done with the prep() function.\nPrepping is always done only with training data. A “prepped” recipe does not derive any statistics from validation or test sets.\n\n“Baking” is the process of calculating the features\n\nBaking is done with the bake() function.\nWe used our prepped recipe when we bake.\nWhereas we only prep a recipe with training data, we can use a prepped recipe to bake features from any dataset (training, validation, or test).\n\n\nWe will work with recipes extensively when model building starting in unit 3\nFor now, we will only use the recipe to indicate roles as a gentle introduction.\nWe will expand on this recipe in unit 3\nRecipe syntax is very similar to generic tidyverse syntax (created by same group)\n\nActually a subset of tidyverse functions\nLess flexible/powerful but focused on our needs and easier to learn\nYou will eventually know both\n\n\nRecipes are used in Modeling scripts (which is a third type of script after cleaning and modeling EDA scripts)\n\nLets reload training again to pretend we are starting a new script\n\n\n data_trn &lt;- read_csv(file.path(path_data, \"ames_clean_class_trn.csv\"), \n                      col_types = cols()) |&gt; \n1  class_ames() |&gt;\n  glimpse()\n\n\n1\n\nRemember our function for classing!\n\n\n\n\nRows: 1,465\nColumns: 10\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;fct&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;fct&gt; ta, ta, no_garage, ta, ta, ta, ta, no_garage, no_garage, …\n$ ms_zoning    &lt;fct&gt; res_high, res_low, res_low, res_low, res_low, res_med, re…\n$ lot_config   &lt;fct&gt; inside, corner, fr2, fr2, inside, inside, inside, inside,…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, town_inside, town_end, duplex,…\n\n\n\nRecipes can be used to indicate the outcome and predictors that will be used in the model\n\nCan use . to indicate all predictors\n\nCurrently, our preferred method with some exceptions\nWe can exclude some predictors later by changing their role, removing them with a later recipe step (\\(step\\_rm()\\)), or specifying a more precise formula when we fit the model\nSee Roles in Recipes for more info\n\nCan use specific names of predictors along with \\(+\\) if only a few predictors\n\ne.g., sale_price ~ lot_area + year_built + overall_qual\n\nDo NOT indicate interactions here\n\nAll predictors are combined with +\nInteractions are specified by a later explicit feature engineering step\n\n\n\nrec &lt;- recipe(sale_price ~ ., data = data_trn)\n\nrec\n\nsummary(rec)\n\n# A tibble: 10 × 4\n   variable     type      role      source  \n   &lt;chr&gt;        &lt;list&gt;    &lt;chr&gt;     &lt;chr&gt;   \n 1 gr_liv_area  &lt;chr [2]&gt; predictor original\n 2 lot_area     &lt;chr [2]&gt; predictor original\n 3 year_built   &lt;chr [2]&gt; predictor original\n 4 overall_qual &lt;chr [3]&gt; predictor original\n 5 garage_cars  &lt;chr [2]&gt; predictor original\n 6 garage_qual  &lt;chr [3]&gt; predictor original\n 7 ms_zoning    &lt;chr [3]&gt; predictor original\n 8 lot_config   &lt;chr [3]&gt; predictor original\n 9 bldg_type    &lt;chr [3]&gt; predictor original\n10 sale_price   &lt;chr [2]&gt; outcome   original\n\n\n\n\n2.5.1 Prepping and Baking a Recipe\nLet’s make a feature matrix from the training set\nThere are two discrete (and important) steps * prep() * bake()\nFirst we prep the recipe using the training data\n\n1rec_prep &lt;- rec |&gt;\n2  prep(training = data_trn)\n\n\n1\n\nWe start by prepping our raw/original recipe (rec)\n\n2\n\nWe use the prep() function on on the training data. Recipes are ALWAYS prepped using training data. This makes sure that are recipes will always only use information from the training set when making features for any subsequent dataset.\n\n\n\n\n\nSecond, we bake the training data using this prepped recipe to get a feature matrix from it.\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(new_data = data_trn)\n\n\nFinally, we should generally at least glimpse (and typically do some more EDA) on our features to make sure our recipe is doing what we expect.\n\nfeat_trn |&gt; glimpse()\n\nRows: 1,465\nColumns: 10\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;fct&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;fct&gt; ta, ta, no_garage, ta, ta, ta, ta, no_garage, no_garage, …\n$ ms_zoning    &lt;fct&gt; res_high, res_low, res_low, res_low, res_low, res_med, re…\n$ lot_config   &lt;fct&gt; inside, corner, fr2, fr2, inside, inside, inside, inside,…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, town_inside, town_end, duplex,…\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n\nfeat_trn |&gt; skim_all()\n\n\n\n\nData summary\n\n\n\n\nName\n\n\nfeat_trn\n\n\n\n\nNumber of rows\n\n\n1465\n\n\n\n\nNumber of columns\n\n\n10\n\n\n\n\n_______________________\n\n\n\n\n\n\nColumn type frequency:\n\n\n\n\n\n\nfactor\n\n\n5\n\n\n\n\nnumeric\n\n\n5\n\n\n\n\n________________________\n\n\n\n\n\n\nGroup variables\n\n\nNone\n\n\n\n\n\nVariable type: factor\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nordered\n\n\nn_unique\n\n\ntop_counts\n\n\n\n\n\n\noverall_qual\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n10\n\n\n5: 424, 6: 350, 7: 304, 8: 176\n\n\n\n\ngarage_qual\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\nta: 1312, no_: 81, fa: 57, gd: 13\n\n\n\n\nms_zoning\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n7\n\n\nres: 1157, res: 217, flo: 66, com: 13\n\n\n\n\nlot_config\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\nins: 1095, cor: 248, cul: 81, fr2: 39\n\n\n\n\nbldg_type\n\n\n0\n\n\n1\n\n\nFALSE\n\n\n5\n\n\none: 1216, tow: 108, dup: 63, tow: 46\n\n\n\n\n\nVariable type: numeric\n\n\n\n\n\nskim_variable\n\n\nn_missing\n\n\ncomplete_rate\n\n\nmean\n\n\nsd\n\n\np0\n\n\np25\n\n\np50\n\n\np75\n\n\np100\n\n\nskew\n\n\nkurtosis\n\n\n\n\n\n\ngr_liv_area\n\n\n0\n\n\n1\n\n\n1506.84\n\n\n511.44\n\n\n438\n\n\n1128\n\n\n1450\n\n\n1759\n\n\n5642\n\n\n1.43\n\n\n5.19\n\n\n\n\nlot_area\n\n\n0\n\n\n1\n\n\n10144.16\n\n\n8177.55\n\n\n1476\n\n\n7500\n\n\n9375\n\n\n11362\n\n\n164660\n\n\n11.20\n\n\n182.91\n\n\n\n\nyear_built\n\n\n0\n\n\n1\n\n\n1971.35\n\n\n29.65\n\n\n1880\n\n\n1953\n\n\n1972\n\n\n2000\n\n\n2010\n\n\n-0.54\n\n\n-0.62\n\n\n\n\ngarage_cars\n\n\n1\n\n\n1\n\n\n1.78\n\n\n0.76\n\n\n0\n\n\n1\n\n\n2\n\n\n2\n\n\n4\n\n\n-0.26\n\n\n0.10\n\n\n\n\nsale_price\n\n\n0\n\n\n1\n\n\n180696.15\n\n\n78836.41\n\n\n12789\n\n\n129500\n\n\n160000\n\n\n213500\n\n\n745000\n\n\n1.64\n\n\n4.60\n\n\n\n\n\n\n\nWe can now use our features from training to train models, but that will take place in the next unit!\nWe could also use the prepped recipe to bake validation or test data to evaluate trained models. That too will happen in the next unit!"
  },
  {
    "objectID": "002_exploratory_data_analysis.html#discussion-topics",
    "href": "002_exploratory_data_analysis.html#discussion-topics",
    "title": "2  Exploratory Data Analysis",
    "section": "2.6 Discussion Topics",
    "text": "2.6 Discussion Topics\n\nHouse keeping\n\nUnit 2 solutions\nQuizzes\nCourse evals for extra credit (to quiz score)!\nUnit 3 homework\n\ntest set predictions\nfree lunch!\n\n\nReview\n\nGoal is to develop model that closely approximates DGP\nGoal is to evaluate (estimate) how close our model is to the DGP (how much error) with as little error as possible\nBias, overfitting/variance for any estimate (model and performance of model)\ncandidate model configurations\nfit, select, evaluate\ntraining, validation, test\n\nReview: 2.2.1 Stages of Data Analysis and Model Development\nBest practices (discuss quickly)\n\ncsv for data sharing, viewing, git (though be careful with data in github or other public repo!)\nvariable values saved as text when nominal and ordinal (self-documenting)\nCreate data dictionary - Documentation is critical!!\nsnake_case for variables and self-documenting names (systematic names too)\n\nReview: 2.3.1 Data Leakage Issues\n\nReview section in webbook\nCleaning EDA is done with full dataset (but univariate). Very limited (variable names, values, find errors)\nModeling EDA is only done with a training set (or even “eyeball” sample) - NEVER use validate or test set\nNever estimate anything with full data set (e.g., missing values, standardize, etc)\nUse recipes, prep (all estimation) with held in data than bake the appropriate set\nPut test aside\nYou work with validation but never explore with validation (will still catch leakage with test but will be mislead to be overly optimistic and spoil test)\n\nFunctions sidenote - fun_modeling.R on github\nReview: 2.4.2 Prepping and Baking a Recipe\n\nReview section in web book\nprep always with held in data, bake with held in & out data.\n\nEDA for modeling\n\nlimitless, just scratched the surface\nDiffers some based on dimenstionality of dataset\nLearning about DGP\n\nunderstand univariate distributions, frequencies\nbivariate relationships\ninteractions (3 or more variables)\npatterns in data\n\n\nExtra topics, time permitting\n\n8.1. Missing data\n* Exclude vs. Impute in training data.  Outcomes?\n* How to impute\n* Missing in validate or test (can't exclude?). Exclude cases with missing outcomes.\n8.2. Outliers * Drop or fix errors! * Goal is always to estimate DGP * Exclude * Retain * Bring to fence * Don’t exclude/change outcome in validate/test\n8.3. Issues with high dimensionality\n* Hard to do predictor level EDA\n* Common choices (normality transformations)\n* observed vs. predicted plots\n* Methods for automated variable selection (glmnet)\n8.4. Distributional Shape\n* Measurement issues (interval scale)\n* Implications for relationships with other variables\n* Solutions?\n8.5. Linearity vs. More Complex Relationships\n* Transformations\n* Choice of statistical algorithm\n* Do you need a linear model?\n8.6. Interactions\n* Domain expertise\n* Visual options for interactions\n* But what do do with high dimensional data?\n* Explanatory vs. prediction goals (algorithms that accommodate interactions)\n8.7. How to handle all of these decisions in the machine learning framework\n* Goal is to develop a model that most closely approximates the DGP\n* How does validation and test help this?\n* Preregistration?\n  * Pre-reg for performance metric, resampling method   \n  * Use of resampling for other decisions\n  * Use of resampling to find correct model to test explanatory goals\n8.8. Model Assumptions\n* Why do we make assumptions?\n  * Inference\n  * Flexibility wrt DGP\n\n\n\n\nWickham, Hadley. 2019. Advanced r. 2nd ed. https://adv-r.hadley.nz/.\n\n\nWickham, Hadley, Çetinkaya-Rundel Mine, and Garrett Grolemund. 2023. R for Data Science: Visualize, Model, Transform, and Import Data. 2nd ed. https://r4ds.hadley.nz/."
  },
  {
    "objectID": "test.html#standards",
    "href": "test.html#standards",
    "title": "20  Test",
    "section": "20.1 Standards",
    "text": "20.1 Standards\n\n20.1.1 For displaying figures:\n\n\n\n\n\n\n\n20.1.2 For displaying code and even variable names\ndemo &lt;- function(x) variable_2\n\n\n20.1.3 For code annotation\n\nlibrary(tidyverse)\n\n1d &lt;- tibble (x = 1:5) |&gt;\n2  glimpse()\n\n\n1\n\nmake a df\n\n2\n\nglimpse a df\n\n\n\n\nRows: 5\nColumns: 1\n$ x &lt;int&gt; 1, 2, 3, 4, 5\n\n\n\n\n20.1.4 For displaying color (like red questions)\nthis sentence is in red\nThis is an alternative method but more complex: I love R.\nred yellow green blue\nyellow background for better contrast"
  }
]