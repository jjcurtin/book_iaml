[
  {
    "objectID": "003_regression.html#overview-of-unit",
    "href": "003_regression.html#overview-of-unit",
    "title": "3  Introduction to Regression Models",
    "section": "3.1 Overview of Unit",
    "text": "3.1 Overview of Unit\n\n3.1.1 Learning Objectives\n\nUse of root mean square error (RMSE) in training and validation sets for model performance evaluation\nThe General Linear Model as a machine learning model\n\nExtensions to categorical variables (Dummy coding features)\nExtensions to interactive and non-linear effects of features\n\nK Nearest Neighbor (KNN)\n\nHyperparameter \\(k\\)\nScaling predictors\nExtensions to categorical variables\n\n\n\n\n\n3.1.2 Readings\n\nJames et al. (2023) Chapter 3, pp 59 - 109\n\n\n\n3.1.3 Lecture Videos\n\nLecture 1: Overview\nLecture 2: The Simple Linear Model\nLecture 3: Extension to Multiple Predictors\nLecture 4: Extension to Categorical Predictors\nLecture 5: Extension to Interactions and Non-Linear Effects\nLecture 6: Introduction to KNN\nLecture 7: Distance and Scaling in KNN\nLecture 8: KNN with Ames\nDiscussion\n\n\n\n\n3.1.4 Application Assignment and Quiz\n\nclean data: train; validate; test\ndata dictionary\nlm qmd\nknn qmd\nsolution: lm; knn\n\nPost questions to the Slack channel for application assignments.\nSubmit the application assignment here and complete the unit quiz by 8 pm on Wednesday, February 7th\n\nOur goal in this unit is to build a machine learning regression model that can accurately (we hope) predict the sale_price for future sales of houses (in Iowa? more generally?)\nTo begin this project we need to:\n\nSet up conflicts policies\nWe will hide this in future units\n\n\noptions(conflicts.policy = \"depends.ok\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\n\nℹ SHA-1 hash of file is \"175d942e14f108d74912bfb2593b77637328ecb1\"\n\ntidymodels_conflictRules()\n\n\n\nLoad the packages we will need. I am shifting here to only loading tidymodels and tidyverse because the other functions we need are only called occassionally (so we will call them by namespace to see how that “feels”.)\n\n\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\n\n\n\nsource additional class functions libraries\nWe will hide this in future units\n\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\n\nℹ SHA-1 hash of file is \"c045eee2655a18dc85e715b78182f176327358a7\"\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\n\nℹ SHA-1 hash of file is \"def6ce26ed7b2493931fde811adff9287ee8d874\"\n\n\n\nset display options\nWe will hide this in future units\n\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\n\n\nhandle paths\n\n\npath_data &lt;- \"./data\"\n\n\n\nSet up function to class ames data (copied with one improvement from last unit)\n\n\nclass_ames &lt;- function(df){\n  df |&gt;\n    mutate(across(where(is.character), factor)) |&gt; \n    mutate(overall_qual = factor(overall_qual, levels = 1:10), \n1           garage_qual = suppressWarnings(fct_relevel(garage_qual,\n                                                      c(\"no_garage\", \"po\", \"fa\", \n                                                    \"ta\", \"gd\", \"ex\"))))\n}\n\n\n1\n\nWarnings should be considered errors until investigated. Once investigated, they can be ignored. To explicitly ignore, use suppressWarnings()\n\n\n\n\n\n\nOpen the cleaned training set\n\n\ndata_trn &lt;- \n  read_csv(here::here(path_data, \"ames_clean_class_trn.csv\"), \n           col_types = cols()) |&gt;  \n  class_ames() |&gt; \n  glimpse()\n\nRows: 1,465\nColumns: 10\n$ sale_price   &lt;dbl&gt; 105000, 126000, 115000, 120000, 99500, 112000, 122000, 12…\n$ gr_liv_area  &lt;dbl&gt; 896, 882, 864, 836, 918, 1902, 900, 1225, 1728, 858, 1306…\n$ lot_area     &lt;dbl&gt; 11622, 8400, 10500, 2280, 7892, 8930, 9819, 9320, 13260, …\n$ year_built   &lt;dbl&gt; 1961, 1970, 1971, 1975, 1979, 1978, 1967, 1959, 1962, 195…\n$ overall_qual &lt;fct&gt; 5, 4, 4, 7, 6, 6, 5, 4, 5, 5, 3, 5, 4, 5, 3, 5, 2, 6, 5, …\n$ garage_cars  &lt;dbl&gt; 1, 2, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 2, 2, 1, 1, 2, 2, 1, …\n$ garage_qual  &lt;fct&gt; ta, ta, no_garage, ta, ta, ta, ta, no_garage, no_garage, …\n$ ms_zoning    &lt;fct&gt; res_high, res_low, res_low, res_low, res_low, res_med, re…\n$ lot_config   &lt;fct&gt; inside, corner, fr2, fr2, inside, inside, inside, inside,…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, town_inside, town_end, duplex,…\n\n\n\n\nOpen the cleaned validation set\n\n\ndata_val &lt;- read_csv(here::here(path_data, \"ames_clean_class_val.csv\"),\n                     col_types = cols()) |&gt; \n  class_ames() |&gt; \n  glimpse()\n\nRows: 490\nColumns: 10\n$ sale_price   &lt;dbl&gt; 215000, 189900, 189000, 171500, 212000, 164000, 394432, 1…\n$ gr_liv_area  &lt;dbl&gt; 1656, 1629, 1804, 1341, 1502, 1752, 1856, 1004, 1092, 106…\n$ lot_area     &lt;dbl&gt; 31770, 13830, 7500, 10176, 6820, 12134, 11394, 11241, 168…\n$ year_built   &lt;dbl&gt; 1960, 1997, 1999, 1990, 1985, 1988, 2010, 1970, 1971, 197…\n$ overall_qual &lt;fct&gt; 6, 5, 7, 7, 8, 8, 9, 6, 5, 6, 7, 9, 8, 8, 7, 8, 6, 5, 5, …\n$ garage_cars  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 3, 2, 1, 2, 2, 2, 2, 3, 2, 3, 1, 1, 2, …\n$ garage_qual  &lt;fct&gt; ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, ta, t…\n$ ms_zoning    &lt;fct&gt; res_low, res_low, res_low, res_low, res_low, res_low, res…\n$ lot_config   &lt;fct&gt; corner, inside, inside, inside, corner, inside, corner, c…\n$ bldg_type    &lt;fct&gt; one_fam, one_fam, one_fam, one_fam, town_end, one_fam, on…\n\n\nNOTE: Remember, I have held back an additional test set that we will use only once to evaluate the final model that we each develop in this unit.\n\nWe will also make a dataframe to track validation error across the models we fit\n\nerror_val &lt;- tibble(model = character(), rmse_val = numeric()) |&gt; \n  glimpse()\n\nRows: 0\nColumns: 2\n$ model    &lt;chr&gt; \n$ rmse_val &lt;dbl&gt; \n\n\n\nWe will fit regression models with various model configurations.\nThese configurations will differ with respect to statistical algorithm:\n\nA General Linear Model (lm) - a parametric approach\nK Nearest Neighbor (KNN) - a non-parametric approach\n\nThese configurations will differ with respect to the features\n\nSingle feature (i.e., simple regression)\nVarious sets of multiple features that vary by:\n\nRaw predictors used\nTransformations applied to those predictors as part of feature engineering\nInclusion (or not) of interactions among features\n\nThe KNN model configurations will also differ with respect to its hyperparameter- \\(k\\)\n\n\nTo build models that will work well in new data (e.g., the data that I have held back from you so far):\n\nWe have split the remaining data into a training and validation set for our own use during model building\nWe will fit models in train\nWe will evaluate them in validation\n\nRemember that we:\n\nUsed a 75/25 stratified (on sale_price) split of the data at the end of cleaning EDA to create training and validation sets\nAre only using a subset of the available predictors. The same ones I used for the EDA unit\n\nYou will work with all of my predictors and all the predictors you used for your EDA when you do the application assignment for this unit\n\nPause for a moment to answer this question:\n\n\n\n\n\n\nQuestion: Why do we need independent validation data to select the best model configuration? In other words, why cant we just fit and evaluate all of the models in our one training set?\n\n\n\n\n\n\n\nShow Answer\nThese models will all overfit the dataset within which they are fit to some degree.   \nIn other words, they will predict both systematic variance (the DGP) and some noise in the training set.  However, they will differ in how much they overfit the training set.   As the models get more flexible they will have the potential to overfit to a greater degree.   Models with a larger number of features (e.g., more predictors, features based on interactions as well as raw predictors) will overfit to a greater degree.  All other things equal, the non-parametric KNN will also be more flexible than the general linear model so it may overfit to a greater degree as well if the true DGP is linear on the features.  Therefore, just because a model fits the training set well does not mean it will work well in new data because the noise will be different in every new dataset.  This overfitting will be removed from our performance estimate if we calculate it with new data (the validation set).\n\n\n\n\n\n\nLet’s take a quick look at the available raw predictors in the training set\n\ndata_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\ndata_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n10\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n5\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nn_unique\ntop_counts\n\n\n\n\noverall_qual\n0\n1\n10\n5: 424, 6: 350, 7: 304, 8: 176\n\n\ngarage_qual\n0\n1\n5\nta: 1312, no_: 81, fa: 57, gd: 13\n\n\nms_zoning\n0\n1\n7\nres: 1157, res: 217, flo: 66, com: 13\n\n\nlot_config\n0\n1\n5\nins: 1095, cor: 248, cul: 81, fr2: 39\n\n\nbldg_type\n0\n1\n5\none: 1216, tow: 108, dup: 63, tow: 46\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n1\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\n\n\n\n\nRemember from our modeling EDA that we have some issues to address as part of our feature engineering:\n\nMissing values\nPossible transformation of sale_price\nPossible transformation of other numeric predictors\nWe will need to use some feature engineering techniques to handle categorical variables\nWe may need to consider interactions among features\n\nAll of this will be accomplished with a recipe\nBut first, let’s discuss/review our first statistical algorithm"
  },
  {
    "objectID": "003_regression.html#the-simple-general-linear-model-lm",
    "href": "003_regression.html#the-simple-general-linear-model-lm",
    "title": "3  Introduction to Regression Models",
    "section": "3.2 The Simple (General) Linear Model (LM)",
    "text": "3.2 The Simple (General) Linear Model (LM)\nWe will start with only a quick review of the use of the simple (one feature) linear model (LM) as a machine learning model because you should be very familiar with this statistical model at this point\n\\(Y = \\beta_0 + \\beta_1*X_1 + \\epsilon\\)\nApplied to our regression problem, we might fit a model such as:\n\\(sale\\_price = \\beta_0 + \\beta_1*gr\\_liv\\_area + \\epsilon\\)\nThe (general) linear model is a parametric model. We need to estimate two parameters, \\(\\beta_0\\) and \\(\\beta_1\\), using our training dataset.\nYou already know how to do this using lm() in base R. However, we will use the tidymodels modeling approach.\n\nWe use tidymodels because:\n\nIt provides a consistent interface to many (and growing numbers) of statistical algorithms\nIt provides very strong and easy feature engineering routines (e.g., missing data, scaling, transformations, near-zero variance, collinearity) via recipes\nIt simplifies model performance evaluation using resampling approaches (that you don’t know yet!)\nIt supports numerous performance metrics\nIt is tightly integrated within the tidyverse\nIt is under active development and support\nYou can see documentation for all of the packages at the tidymodels website. It is worth a quick review now to get a sense of what is available\n\n\nTo fit a model with a specific configuration, we need to:\n\nSet up a feature engineering recipe\nUse the recipe to make a feature matrix\n\nprep() it with training data\nbake() it with data you want to use to calculate feature matrix\n\nSelect and define the statistical algorithm\nFit the algorithm in the feature matrix in our training set\n\nThese steps are accomplished with functions from the recipes and parsnip packages.\n\nWe will start with a simple model configuration\n\nGeneral linear model (lm)\nOne feature (raw gr_liv_area)\nFit in training data\n\n\nSet up a VERY SIMPLE feature engineering recipe\n\nInclude outcome on the left size of ~\nInclude raw predictors (not yet features) on the right side of ~.\n\nIndicate the training data\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area, data = data_trn) \n\n\n\nWe can see a summary of it to verify it is doing what you expect\n\n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 1\n\n\n\nWe can then prep the recipe and bake the data to make our feature matrix from the training dataset\n\nAgain, remember we always prep a recipe with training data but use the prepped recipe to bake any data\nIn this instance we will prep with data_trn and then bake data_trn so that we have features from our training set to train/fit the model.\n\n\nrec_prep &lt;- rec |&gt; \n  prep(training = data_trn)\n\n\nWe can view this prepped recipe and see that it has now been trained on training data (N = 1465)\n\n\nrec_prep\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 1\n\n\n\n\n\n── Training information \n\n\nTraining data contained 1465 data points and no incomplete rows.\n\n\n\n\nAnd now we can bake the training data to make a feature matrix\n\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(new_data = data_trn)\n\n\nYou should always review the feature matrix to make sure it looks as you expect\n\nincludes outcome (sale_price)\nincludes expected feature (gr_liv_area)\nSample size is as expected\nNo missing data\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n2\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\n\n\n\n\nNow let’s consider the statistical algorithm\n\ntidymodels breaks this apart into two pieces for clarity\nFirst, you specify the broad category of algorithm\n\ne.g., linear_reg(), nearest_neighbor(), logistic_reg()\n\nThen you select a function from a specific R package (or base R) that will implement the algorithm\n\ntidymodels calls this setting the engine\ne.g., lm, kknn, glm, glmnet\n\n\n\nYou can see the available engines (and modes: regression vs. classification) for the broad classes of algorithms\nWe will work with many of these algorithms later in the course\n\nshow_engines(\"linear_reg\")\n\n# A tibble: 7 × 2\n  engine mode      \n  &lt;chr&gt;  &lt;chr&gt;     \n1 lm     regression\n2 glm    regression\n3 glmnet regression\n4 stan   regression\n5 spark  regression\n6 keras  regression\n7 brulee regression\n\nshow_engines(\"nearest_neighbor\")\n\n# A tibble: 2 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 kknn   classification\n2 kknn   regression    \n\nshow_engines(\"logistic_reg\")\n\n# A tibble: 7 × 2\n  engine    mode          \n  &lt;chr&gt;     &lt;chr&gt;         \n1 glm       classification\n2 glmnet    classification\n3 LiblineaR classification\n4 spark     classification\n5 keras     classification\n6 stan      classification\n7 brulee    classification\n\nshow_engines(\"decision_tree\")\n\n# A tibble: 5 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 rpart  classification\n2 rpart  regression    \n3 C5.0   classification\n4 spark  classification\n5 spark  regression    \n\nshow_engines(\"rand_forest\")\n\n# A tibble: 6 × 2\n  engine       mode          \n  &lt;chr&gt;        &lt;chr&gt;         \n1 ranger       classification\n2 ranger       regression    \n3 randomForest classification\n4 randomForest regression    \n5 spark        classification\n6 spark        regression    \n\nshow_engines(\"mlp\")\n\n# A tibble: 6 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 keras  classification\n2 keras  regression    \n3 nnet   classification\n4 nnet   regression    \n5 brulee classification\n6 brulee regression    \n\n\n\nYou can load even more engines from the discrim package. We will use some of these later too. You need to load the package to use these engines.\n\nlibrary(discrim, exclude = \"smoothness\") # needed for these engines\n\nshow_engines(\"discrim_linear\") \n\n# A tibble: 4 × 2\n  engine        mode          \n  &lt;chr&gt;         &lt;chr&gt;         \n1 MASS          classification\n2 mda           classification\n3 sda           classification\n4 sparsediscrim classification\n\nshow_engines(\"discrim_regularized\") \n\n# A tibble: 1 × 2\n  engine mode          \n  &lt;chr&gt;  &lt;chr&gt;         \n1 klaR   classification\n\nshow_engines(\"naive_Bayes\")\n\n# A tibble: 2 × 2\n  engine     mode          \n  &lt;chr&gt;      &lt;chr&gt;         \n1 klaR       classification\n2 naivebayes classification\n\n\n\nYou can also better understand how the engine will be called using translate()\nNot useful here but will be with more complicated algorithms\n\nlinear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  translate()\n\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\nModel fit template:\nstats::lm(formula = missing_arg(), data = missing_arg(), weights = missing_arg())\n\n\n\nLet’s combine our feature matrix with an algorithm to fit a model in our training set using only raw gr_liv_area as a feature\nNote the specification of\n\nThe category of algorithm\nThe engine (no need to set mode of engine b/c lm are only for the regression mode)\nThe use of the . to indicate all features in the matrix.\n\nnot that useful here because there is only one feature: gr_liv_area\nwill be useful when we have many features in the matrix\n\nWe use the the feature matrix (rather than raw data) from the training set to fit the model.\n\n\nfit_lm_1 &lt;- \n1  linear_reg() |&gt;\n2  set_engine(\"lm\") |&gt;\n3  fit(sale_price ~ ., data = feat_trn)\n\n\n1\n\ncategory of algorithm\n\n2\n\nengine\n\n3\n\nuse of . for all features and use of feature matrix from training set\n\n\n\n\n\nWe can get the parameter estimates, standard errors, and statistical tests for each \\(\\beta\\) = 0 for this model using tidy() from the broom package (loaded as part of the tidyverse)\n\nfit_lm_1 |&gt;  tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic   p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept)   16561.   4537.        3.65 2.72e-  4\n2 gr_liv_area     109.      2.85     38.2  4.78e-222\n\n\n\nThere are a variety of ways to pull out the estimates for each feature (and intercept)\nOption 1: Pull all estimates from the tidy object\n\nfit_lm_1 |&gt; \n  tidy() |&gt; \n  pull(estimate)\n\n[1] 16560.9991   108.9268\n\n\n\nOption 2: Extract a single estimate using $ and row number. Be careful that order of features won’t change! This assumes the feature coefficient for the relevant feature is always the second coefficient.\n\ntidy(fit_lm_1)$estimate[[2]]\n\n[1] 108.9268\n\n\n\nOption 3: Filter tidy df to the relevant row (using term ==) and pull the estimate. Safer!\n\nfit_lm_1 |&gt; \n  tidy() |&gt; \n  filter(term == \"gr_liv_area\") |&gt; \n  pull(estimate)\n\n[1] 108.9268\n\n\n\nOption 4: Write a function if we plan to do this a lot. We include this function in the fun_ml.R script in our repo. Better still (safe and code efficient)!\n\n#|eval: false\n\nget_estimate &lt;- function(the_fit, the_term){\n  the_fit |&gt; \n    tidy() |&gt; \n    filter(term == the_term) |&gt; \n    pull(estimate)\n}\n\nand then use this function\n\nget_estimate(fit_lm_1, \"gr_liv_area\")\n\n[1] 108.9268\n\nget_estimate(fit_lm_1, \"(Intercept)\")\n\n[1] 16561\n\n\n\nRegardless of the method, we now have a simple parametric model for sale_price\n\\(\\hat{sale\\_price} = 1.6561\\times 10^{4} + 108.9 * gr\\_liv\\_area\\)\n\nWe can get the predicted values for sale_price (i.e., \\(\\hat{sale\\_price}\\)) in our validation set using predict()\nHowever, we first need to make a feature matrix for our validation set\n\nWe use the same recipe that we previously prepped with training data (data_trn)\nBut now we bake the validation data,data_val\n\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(new_data = data_val)\n\n\nAs always, we should skim these new features\n\nSample size matches what we expect for validation set\nNo missing data\nIncludes expected outcome and features\n\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n2\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1493.0\n483.78\n480\n1143.5\n1436\n1729.5\n3608\n0.92\n1.16\n\n\nsale_price\n0\n1\n178512.8\n75493.59\n35311\n129125.0\n160000\n213000.0\n556581\n1.42\n2.97\n\n\n\n\n\n\nNow we can get predictions using our model with validation features\npredict() returns a dataframe with one column named .pred and one row for every observation in dataframe (e.g., validation feature set)\n\npredict(fit_lm_1, feat_val)\n\n# A tibble: 490 × 1\n     .pred\n     &lt;dbl&gt;\n 1 196944.\n 2 194003.\n 3 213065.\n 4 162632.\n 5 180169.\n 6 207401.\n 7 218729.\n 8 125923.\n 9 135509.\n10 133004.\n# ℹ 480 more rows\n\n\n\nWe can visualize how well this model performs in the validation set by plotting predicted sale_price (\\(\\hat{sale\\_price}\\)) vs. sale_price (ground truth in machine learning terminology) for these data\nWe might do this a lot so let’s write a function. We have also included this function in fun_ml.R\n\nplot_truth &lt;- function(truth, estimate) {\n  ggplot(mapping = aes(x = truth, y = estimate)) + \n    geom_abline(lty = 2, color = \"red\") + \n    geom_point(alpha = 0.5) + \n    labs(y = \"predicted outcome\", x = \"outcome\") +\n    coord_obs_pred()   # scale axes uniformly (from tune package)\n}\n\n\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_1, feat_val)$.pred)\n\n\n\n\nPerfect performance would have all the points right on the dotted line (same value for actual and predicted outcome)\n\nOur model doesn’t do that well yet. Not surprising\nPattern also has some indication of fanning of residuals AND some non-linearity with higher outcome scores that suggests need for a power transformation of outcome (e.g., log)\nThis is consistent with our earlier modeling EDA\nPerhaps not that bad here b/c both sale_price and gr_liv_area were positively skewed\nWe will need consider this eventually\n\n\nWe can quantify model performance by selecting a performance metric\n\nThe yardstick package within the tidymodels framework supports calculation of many performance metrics for regression and classification models\nSee the list of all currently available metrics\n\nRoot mean square error (RMSE) is a common performance metric for regression models\n\nYou focused on a related metric, sum of squared error (SSE), in PSY 610/710\nRMSE simply divides SSE by N (to get mean squared error; MSE) and then takes the square root to return the metric to the original units for the outcome variable\nIt is easy to calculate using rmse_vec() from the yardstick package\n\n\nrmse_vec(truth = feat_val$sale_price, \n         estimate = predict(fit_lm_1, feat_val)$.pred)\n\n[1] 51375.08\n\n\n\nLet’s record how well this model performed in validation so we can compare it to subsequent models\n\nerror_val &lt;- bind_rows(error_val, \n                       tibble(model = \"simple linear model\", \n                              rmse_val = rmse_vec(truth = feat_val$sale_price, \n                                                  estimate = predict(fit_lm_1,\n                                                                     feat_val)$.pred)))\nerror_val\n\n# A tibble: 1 × 2\n  model               rmse_val\n  &lt;chr&gt;                  &lt;dbl&gt;\n1 simple linear model   51375.\n\n\n\nFor explanatory purposes, we might want to visualize the relationship between a feature and the outcome (in addition to examining the parameter estimates and the associated statistical tests)\n\nHere is a plot of \\(\\hat{sale\\_price}\\) by gr_liv_area superimposed over a scatterplot of the raw data from the validation set\n\n\nfeat_val |&gt; \n  ggplot(aes(x = gr_liv_area)) +\n    geom_point(aes(y = sale_price), color = \"gray\") +\n    geom_line(aes(y = predict(fit_lm_1, data_val)$.pred), \n              linewidth = 1.25, color = \"blue\") + \n    ggtitle(\"Validation Set\")\n\n\n\n\n\nAs expected, there is a moderately strong positive relationship between gr_liv_area and sale_price.\n\nWe can also again see the heteroscadasticity in the errors that might be corrected by a power transformation of sale_price (or gr_liv_area)"
  },
  {
    "objectID": "003_regression.html#extension-of-lm-to-multiple-predictors",
    "href": "003_regression.html#extension-of-lm-to-multiple-predictors",
    "title": "3  Introduction to Regression Models",
    "section": "3.3 Extension of LM to Multiple Predictors",
    "text": "3.3 Extension of LM to Multiple Predictors\nWe can improve model performance by moving from simple linear model to a linear model with multiple features derived from multiple predictors\nWe have many other numeric variables available to use, even in this pared down version of the dataset.\n\ndata_trn |&gt;  skim_all()\n\n\nData summary\n\n\nName\ndata_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n10\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n5\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nn_unique\ntop_counts\n\n\n\n\noverall_qual\n0\n1\n10\n5: 424, 6: 350, 7: 304, 8: 176\n\n\ngarage_qual\n0\n1\n5\nta: 1312, no_: 81, fa: 57, gd: 13\n\n\nms_zoning\n0\n1\n7\nres: 1157, res: 217, flo: 66, com: 13\n\n\nlot_config\n0\n1\n5\nins: 1095, cor: 248, cul: 81, fr2: 39\n\n\nbldg_type\n0\n1\n5\none: 1216, tow: 108, dup: 63, tow: 46\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n1\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\n\n\n\n\nLet’s expand our model to also include lot_area, year_built, and garage_cars\nAgain, we need:\n\nA feature engineering recipe\nTraining (and eventually validation) feature matrices\nAn algorithm to fit in training feature matrix\n\n\nWith the addition of new predictors, we now have a feature engineering task\n\nWe have missing data on garage_cars in the training set\nWe need to decide how we will handle it\n\nA simple solution is to do median imputation - substitute the median of the non-missing scores for any missing score.\n\nThis is fast and easy to understand\nIt works OK (but there are certainly better options that we will consider later in the course)\n\nsee other options in Step Functions - Imputation section on tidymodels website\n\nThere is only one missing value so it likely doesn’t matter much anyway\n\nLet’s add this to our recipe. All of the defaults are appropriate but you should see ?step_impute_median() to review them\n\nrec &lt;- \n1  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars,\n         data = data_trn) |&gt; \n  step_impute_median(garage_cars)\n\n\n1\n\nNotice we now list four predictors for our recipe using + between them\n\n\n\n\n\nLet’s look at the recipe\n\nWe will have 1 outcome and 4 features (predictors) in the feature matrix when we use this recipe.\nWe will do median imputation for garage_cars\n\n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 4\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n\nNow we need to\n\nFirst prep recipe\n\n\nrec_prep &lt;- rec |&gt; \n1  prep(data_trn)\n\n\n1\n\nI am going to stop using training = at this point. Remember, we prep recipes with training data.\n\n\n\n\n\n\nNext, bake the training data with prepped recipe to get training features\n\n\nfeat_trn &lt;- rec_prep |&gt; \n1  bake(data_trn)\n\n\n1\n\nI am going to stop using new_data = but remember, we can bake any dataset to make features for that dataset.\n\n\n\n\n\nAnd take a quick look at the features\n\nSample size is correct\n4 features and the outcome variable\nAll features are numeric\nNo missing data for garage_qual\n\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\n\n\n\n\n\nAnd finally, bake the validation data with the same prepped recipe to get validation features\n\n\nfeat_val &lt;- rec_prep |&gt; \n1  bake(data_val)\n\n\n1\n\nNotice that here we are now baking data_val\n\n\n\n\n\nAnd take a quick look\n\nCorrect sample size (N = 490)\n4 features and outcome\nAll numeric\nNo missing data\n\n\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1493.00\n483.78\n480\n1143.5\n1436.0\n1729.50\n3608\n0.92\n1.16\n\n\nlot_area\n0\n1\n10462.08\n10422.55\n1680\n7500.0\n9563.5\n11780.75\n215245\n15.64\n301.66\n\n\nyear_built\n0\n1\n1971.08\n30.96\n1875\n1954.0\n1975.0\n2000.00\n2010\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n1.74\n0.76\n0\n1.0\n2.0\n2.00\n4\n-0.24\n0.22\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311\n129125.0\n160000.0\n213000.00\n556581\n1.42\n2.97\n\n\n\n\n\n\nNow let’s combine our algorithm and training features to fit this model configuration with 4 features\n\nfit_lm_4 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n1  fit(sale_price ~ ., data = feat_trn)\n\n\n1\n\nthe . is a bit more useful now\n\n\n\n\n\nThis yields these parameter estimates (which as we know from 610/710 were selected to minimize SSE in the training set):\n\nfit_lm_4 |&gt; tidy()\n\n# A tibble: 5 × 5\n  term            estimate std.error statistic   p.value\n  &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 (Intercept) -1665041.    89370.       -18.6  1.14e- 69\n2 gr_liv_area       76.8       2.62      29.3  3.56e-149\n3 lot_area           0.514     0.146      3.51 4.60e-  4\n4 year_built       854.       46.2       18.5  7.66e- 69\n5 garage_cars    22901.     1964.        11.7  4.09e- 30\n\n\n\nHere is our parametric model\n\\(\\hat{sale\\_price} = -1.6650409\\times 10^{6} + 76.8 * gr\\_liv\\_area + 0.5 * lot\\_area + 854.3 * year\\_built + 2.29008\\times 10^{4} * garage\\_cars\\)\nCompared with our previous simple regression model:\n\\(\\hat{sale\\_price} = 1.6561\\times 10^{4} + 108.9 * gr\\_liv\\_area\\)\n\nOf course, these four features are correlated both with sale_price but also with each other\nLet’s look at correlations in the training set.\n\nfeat_trn |&gt; \n  cor() |&gt; \n  corrplot::corrplot.mixed()\n\n\n\n\n\n\n\n\n\n\n\nQuestion: What are the implications of the correlations among many of these predictors?\n\n\n\n\n\n\n\nShow Answer\nThe multiple regression model coefficients represent unique effects, controlling for \nall other variables in the model.  You can see how the unique effect of `gr_liv_area` \nis smaller than its overall effect from the simple regression.   This also means \nthat the overall predictive strength of the model will not be a sum of the effects \nof each predictor considered in isolation - it will likely be less.  Also, if the \ncorrelations are high, problems with multicollinearity will emerge.  This will yield \nlarge standard errors which means that the models will start to have more variance when \nfit in different training datasets!  We will soon learn about other regularized \nversions of the GLM that do not have these issues with correlated predictors.\n\n\n\n\n\n\nHow well does this more complex model perform in validation? Let’s compare the previous and current visualizations of sale_price vs. \\(\\hat{sale\\_price}\\)\n\nLooks like the errors are smaller (closer to the diagonal line that would represent prefect prediction)\nClear signs of non-linearity are now present as well. Time for more Modeling EDA!!\n\n\nplot_1 &lt;- plot_truth(truth = feat_val$sale_price, \n                     estimate = predict(fit_lm_1, feat_val)$.pred)\n\nplot_4 &lt;- plot_truth(truth = feat_val$sale_price, \n                     estimate = predict(fit_lm_4, feat_val)$.pred)\n\ncowplot::plot_grid(plot_1, plot_4, \n          labels = list(\"1 feature\", \"4 features\"), hjust = -1.5)\n\n\n\n\nCoding sidebar: Notice the use of plot_grid() from the cowplot package to make side by side plots. This also required returning the individual plots as objects (just assign to a object name, e.g., plot_1)\n\nLet’s compare model performance for the two models using RMSE in the validation set\n\nThe one feature simple linear model\n\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_lm_1, feat_val)$.pred)\n\n[1] 51375.08\n\n\n\nThe four feature linear model. A clear improvement!\n\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_lm_4, feat_val)$.pred)\n\n[1] 39903.25\n\n\n\nLet’s the new performance metric to our results table\n\nerror_val &lt;- \n  bind_rows(error_val, \n            tibble(model = \"4 feature linear model\", \n                   rmse_val = rmse_vec(feat_val$sale_price, \n                                       predict(fit_lm_4, feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 2 × 2\n  model                  rmse_val\n  &lt;chr&gt;                     &lt;dbl&gt;\n1 simple linear model      51375.\n2 4 feature linear model   39903.\n\n\n\nGiven the non-linearity suggested by the truth vs. estimate plots, we might wonder if we could improve the fit if we transformed our features to be closer to normal\nThere are a number of recipe functions that do transformations (see Step Functions - Individual Transformations)\nWe will apply step_YeoJohnson(), which is similar to a Box-Cox transformation but can be more broadly applied because the scores don’t need to be strictly positive\n\nLet’s do it all again, now with transformed features!\n\nDefine the feature engineering recipe\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars, \n         data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_YeoJohnson(lot_area, gr_liv_area, year_built, garage_cars)\n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 4\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n• Yeo-Johnson transformation on: lot_area, gr_liv_area, year_built, ...\n\n\n\n\nPrep the recipe with training set\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nUse prepped recipe to bake the training set into features\n\nNotice the features are now less skewed (but sale_price is still skewed)\n\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n5.22\n0.16\n4.60\n5.11\n5.23\n5.33\n5.86\n0.00\n0.12\n\n\nlot_area\n0\n1\n14.10\n1.14\n10.32\n13.69\n14.20\n14.64\n21.65\n0.08\n5.46\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880.00\n1953.00\n1972.00\n2000.00\n2010.00\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n2.12\n0.98\n0.00\n1.11\n2.37\n2.37\n5.23\n-0.03\n0.04\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789.00\n129500.00\n160000.00\n213500.00\n745000.00\n1.64\n4.60\n\n\n\n\n\n\nUse same prepped recipe to bake the validation set into features\n\nAgain, features are less skewed\n\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n5\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n5.22\n0.16\n4.65\n5.11\n5.23\n5.32\n5.66\n-0.17\n0.19\n\n\nlot_area\n0\n1\n14.14\n1.17\n10.57\n13.69\n14.24\n14.72\n22.44\n0.11\n6.12\n\n\nyear_built\n0\n1\n1971.08\n30.96\n1875.00\n1954.00\n1975.00\n2000.00\n2010.00\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n2.06\n0.96\n0.00\n1.11\n2.37\n2.37\n5.23\n0.01\n0.24\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311.00\n129125.00\n160000.00\n213000.00\n556581.00\n1.42\n2.97\n\n\n\n\n\n\n\nFit model\n\n\nfit_lm_4yj &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\n\nView truth vs. estimate plot\n\n\nplot_truth(truth = feat_val$sale_price,\n           estimate = predict(fit_lm_4yj, feat_val)$.pred)\n\n\n\n\n\n\nand look at the error\n\n\nerror_val &lt;- bind_rows(error_val, \n                        tibble(model = \"4 feature linear model with YJ\", \n                               rmse_val = rmse_vec(feat_val$sale_price, \n                                                   predict(fit_lm_4yj,\n                                                           feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 3 × 2\n  model                          rmse_val\n  &lt;chr&gt;                             &lt;dbl&gt;\n1 simple linear model              51375.\n2 4 feature linear model           39903.\n3 4 feature linear model with YJ   41660.\n\n\nThat didn’t help at all. Error still high and still non-linearity in plot.\nWe may need to consider\n\na transformation of sale_price (We will leave that to you for the application assignment if you are daring!)\nor a different algorithm that can handle non-linear relationships better\n\n\n\n\nj ## Extension to Categorical Predictors\n\n\nMany important predictors in our models may be categorical (nominal and some ordinal predictors)\n\n\n- Some statistical algorithms (e.g., random forest) can accept even nominal predictors as features without any further feature engineering - But many cannot. Linear models cannot. - The type of feature engineering may differ for nominal vs. ordinal categorical predictors - For nominal categorical predictors: - We need to learn a common approach to transform them to numeric features - dummy coding. We will learn the concept in general AND how to accomplish within a feature engineering recipe. - For ordinal predictors: - We can treat them like numeric predictors - We can treat them like nominal categorical predictors - See article on Categorical Predictors on the tidymodels website for more details\n\n\n### Dummy Coding\n\n\nFor many algorithms, we will need to use feature engineering to convert a categorical predictor to numeric features. One common technique is to use dummy coding. When dummy coding a predictor, we transform the original categorical predictor with m levels into m-1 dummy coded features.\n\n\nTo better understand how and why we do this, lets consider a version of ms_zoning in the Ames dataset.\n\n\n::: {.cell}\n\n\n{.r .cell-code} data_trn |&gt; pull(ms_zoning) |&gt; table()\n\n\n::: {.cell-output .cell-output-stdout} ```\n\n\nagri commer float indus res_high res_low res_med 2 13 66 1 9 1157 217 ``` ::: :::\n\n\nWe will recode ms_zoning to have only 3 levels to make our example simple (though dummy codes can be used for predictors with any number of levels)\n\n\n::: {.cell}\n\n\n{.r .cell-code} data_dummy &lt;- data_trn |&gt; select(sale_price, ms_zoning)  |&gt; # &lt;1&gt; mutate(ms_zoning3 = fct_collapse(ms_zoning, # &lt;2&gt; \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"), \"commercial\" = c(\"agri\", \"commer\", \"indus\"), \"floating\" = \"float\")) |&gt; # &lt;3&gt; select(-ms_zoning) # &lt;4&gt; :::\n\n\n1. Make a df (dataframe) with only sale_price and ms_zoning 2. fct_collapse() from the forcats package is our preferred way to collapse levels of a factor. See fct_recode() for more generic recoding of levels. 3. We could have left this line out and float would have stayed as a level named float 4. Remove original ms_zoning predictor\n\n\n\nTake a look at the new predictor\n\ndata_dummy |&gt; \n  pull(ms_zoning3) |&gt; \n  table() \n\n\n commercial    floating residential \n         16          66        1383 \n\n\n\n\n\n\n\n\n\nQuestion: Why can’t we simply recode each level with a different consecutive value (e.g., commercial = 1, floating =2 , residential = 3)?\n\n\n\n\n\n\n\nShow Answer\nThere is no meaningful way to order the numbers that we assign to the levels of \nthis unordered categorical predictor.  The shape and strength of the relationship\nbetween it and sale_price will completely change based on arbitrary ordering of \nthe levels.\n\n\n\n\n\n\nImagine fitting a straight line to predict sale_price from ms_zoning3 using these three different ways to arbitrarily assign numbers to levels.\n\ndata_dummy |&gt; \n  mutate(ms_zoning3 = case_when(ms_zoning3 == \"residential\" ~ 1,\n                                ms_zoning3 == \"commercial\" ~ 2,\n                                ms_zoning3 == \"floating\" ~ 3)) |&gt; \n  ggplot(aes(x = ms_zoning3, y = sale_price)) +\n    geom_bar(stat=\"summary\", fun = \"mean\")\n\n\n\n\n\ndata_dummy |&gt; \n  mutate(ms_zoning3 = case_when(ms_zoning3 == \"residential\" ~ 2,\n                                ms_zoning3 == \"commercial\" ~ 1,\n                                ms_zoning3 == \"floating\" ~ 3)) |&gt; \n  ggplot(aes(x = ms_zoning3, y = sale_price)) +\n    geom_bar(stat=\"summary\", fun = \"mean\")\n\n\n\n\n\ndata_dummy |&gt; \n  mutate(ms_zoning3 = case_when(ms_zoning3 == \"residential\" ~ 3,\n                                ms_zoning3 == \"commercial\" ~ 1,\n                                ms_zoning3 == \"floating\" ~ 2)) |&gt; \n  ggplot(aes(x = ms_zoning3, y = sale_price)) +\n    geom_bar(stat=\"summary\", fun = \"mean\")\n\n\n\n\n\nDummy coding resolves this issue.\nWhen using dummy codes, we transform (i.e., feature engineer) our original m-level categorical predictor to m-1 dummy features.\n\nEach of these m-1 features represents a contrast between a specific level of the categorical variable and a reference level\nThe full set of m-1 features represents the overall effect of the categorical predictor variable.\nWe assign values of 0 or 1 to each observation on each feature in a meaningful pattern (see below)\n\n\nFor example, with our three-level predictor: ms_zoning3\n\nWe need 2 dummmy features (d1, d2) to represent this 3-level categorical predictor\nDummy feature 1 is coded 1 for residential and 0 for all other levels\nDummy feature 2 is coded 1 for floating and 0 for all other levels\n\nHere is this coding scheme displayed in a table\n\n\n# A tibble: 3 × 3\n  ms_zoning3     d1    d2\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 commercial      0     0\n2 residential     1     0\n3 floating        0     1\n\n\n\nWith this coding:\n\nCommercial properties are coded 0 for both d1 and d2.\n\nThis means that commercial properties will become the reference level against which both residential and floating village are compared.\nBecause we are focused on prediction, the choice of reference level is mostly arbitrary. For explanatory goals, you might consider which level is best suited to be the reference.\n3.4 There is much deeper coverage of dummy and other contrast coding in 610/710\n\nWe can add these two features manually to the data frame and view a handful of observations to make this coding scheme more concrete\n\n\n# A tibble: 8 × 4\n  sale_price ms_zoning3     d1    d2\n       &lt;dbl&gt; &lt;fct&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1     105000 residential     1     0\n2     126000 residential     1     0\n3      13100 commercial      0     0\n4     115000 residential     1     0\n5     149500 floating        0     1\n6      40000 commercial      0     0\n7     120000 residential     1     0\n8     151000 floating        0     1\n\n\n\nIf we now fit a model where we predict sale_price from these two dummy coded features, each feature would represent the contrast of the mean sale_price for the level coded 1 vs. the mean sale_price for the level that is coded 0 for all features (i.e., commercial)\n\nd1 is the contrast of mean sale_price for residential vs. commercial\nd2 is the contrast of mean sale_price for floating vs. commercial\nThe combined effect of these two features represents the overall effect of ms_zoning3 on sale_price\n\n\nLets do this quickly in base r using lm() as you have done previously in 610.\n\nm &lt;- lm(sale_price ~ d1 + d2, data = data_dummy) \n\nm |&gt; summary()\n\n\nCall:\nlm(formula = sale_price ~ d1 + d2, data = data_dummy)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-166952  -50241  -20241   31254  565259 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)    81523      19409   4.200 2.83e-05 ***\nd1             98219      19521   5.031 5.47e-07 ***\nd2            143223      21634   6.620 5.03e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 77640 on 1462 degrees of freedom\nMultiple R-squared:  0.03151,   Adjusted R-squared:  0.03018 \nF-statistic: 23.78 on 2 and 1462 DF,  p-value: 6.858e-11\n\n\nThe mean sale price of residential properties is NA dollars higher than commercial properties.\nThe mean sale price of floating villages is NA dollars higher than commercial properties.\n\nTo understand this conceptually, it is easiest to visualize the linear model that would predict sale_price with these two dichotomous features.\n\nThere are only three columns of sale_price because the only possible values for d1 and d2 (which are both dichotomous) are\n\n0,0 (commercial)\n1,0 (residential)\n0,1 (floating village)\n\nThis regression with two features yields a prediction plane (displayed)\nThe left/right tilt of the plane will be the parameter estimate for d1 and it is the contrast of residential vs. commercial\nThe front/back tilt of the plane will be the parameter estimate for d2 and it is the contrast of floating village vs. commercial\n\n\n\n\n\n\n\nStatistical sidebar:\n\nAny full rank (# levels - 1) set of features regardless of coding system predicts exactly the same (e.g., dummy, helmert, contrast coding)\nPreference among coding systems is simply to get single df contrasts of theoretical importance (i.e., for explanation rather than prediction)\nFinal (mth) dummy feature is not included b/c its is completely redundant (perfectly multicollinear) with other dummy features. This would also prevent a linear model from fitting (‘dummy variable trap’).\nHowever, some statistical algorithms do not have problems with perfect multicollinearity (e.g., LASSO, ridge regression).\n\nFor these algorithms, you will sometimes see modified version of dummy coding called one-hot coding.\n\nThis approach uses one additional dummy coded feature for the final category.\n\nWe won’t spend time on this but you should be familiar with the term b/c it is often confused with dummy coding.\n\n\n\nCoding Sidebar\nWhen creating dummy coded features from factors that have levels with infrequent observations, you may occasionally end up with novel levels in your validation or test sets that were not present in your training set.\n\nThis will cause you issues.\n\nThese issues are mostly resolved if you make sure to explicitly list all possible levels for a factor when classing that factor in the training data, even if the level doesn’t exist in the training data.\n\nWe provide more detail on this issue in an appendix.\n\n\n\n3.4.1 Nominal Predictors\nNow that we understand how to use dummy coding to feature engineer nominal predictors, let’s consider some potentially important ones that are available to us.\nWe can discuss if any look promissing.\n\nLets return first to ms_zoning\n\ndata_trn |&gt; \n  plot_categorical(\"ms_zoning\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\nWe might:\n\nRepresent it with 6 dummy features (because there are 7 raw levels) but many of the categories are very low n - won’t account for much variance?\nCombine all the commercial categories (agri, commer, indus), which would take care of most of the low n groups. They also all tend to have the lower prices.\nCombine all the residential to get a better feature to variance accounted ratio. They all tend to have similar prices on average and res_high is also pretty low n. \n\nData dictionary entry: Identifies the general zoning classification of the sale.\n\nagri: Agriculture\ncommer: Commercial\nfloat: Floating Village Residential\nindus: Industrial\nres_high: Residential High Density\nres_med: Residential Medium Density\n3.5 res_low: Residential Low Density\n\nlot_config\n\ndata_trn |&gt; \n  plot_categorical(\"lot_config\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\n\nMost are inside lots, some of the lot categories are low n\nMedian sale_price is not very different between configurations\nNot very promising but could help some (particularly given the large sample size)\n\nData dictionary entry: Lot configuration\n\ninside: Inside lot\ncorner: Corner lot\nculdsac: Cul-de-sac\nfr2: Frontage on 2 sides of property\nfr3: Frontage on 3 sides of property\n\n\nbldg_type\n\ndata_trn |&gt; \n  plot_categorical(\"bldg_type\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\n\nMost of the houses are in one category - one_fam\nThere is not much difference in median sale_price among categories\nNot very promising\n\nData dictionary entry: Type of dwelling\n\none_fam: Single-family Detached\n\ntwo_fam: Two-family Conversion; originally built as one-family dwelling\nduplex: Duplex\ntown_end: Townhouse End Unit\ntown_inside: Townhouse Inside Unit\n\n\nLet’s do some feature engineering with ms_zoning. We can now do this formally in a recipe so that it can be used in our modeling workflow.\nFirst, if you noticed earlier, there are some levels for ms_zoning that are pretty infrequent. Lets make sure both data_trn and data_val have all levels set for this factor.\n\ndata_trn |&gt; pull(ms_zoning) |&gt; levels()\n\n[1] \"agri\"     \"commer\"   \"float\"    \"indus\"    \"res_high\" \"res_low\"  \"res_med\" \n\ndata_val |&gt; pull(ms_zoning) |&gt; levels()\n\n[1] \"commer\"   \"float\"    \"indus\"    \"res_high\" \"res_low\"  \"res_med\" \n\n\nAs expected, we are missing a level (agri) in data_val. Lets fix that here\n\ndata_val &lt;- data_val |&gt; \n  mutate(ms_zoning = factor(ms_zoning, \n                            levels = c(\"agri\", \"commer\", \"float\", \"indus\", \n                                       \"res_high\", \"res_low\", \"res_med\")))\n\n(Note: Ideally, you would go back to cleaning EDA and add this level to the full dataset and then re-split into training, validation and test. This is a sloppy shortcut!)\n\nWith that fixed, let’s proceed:\n\nWe will collapse categories down to three levels (commercial, residential, floating village) as before but now using step_mutate() combined with fct_collapse() to do this inside of our recipe.\n\nWe will convert to dummy features using step_dummy(). The first level of the factor will be set to the reference level when we call step_dummy().\nstep_dummy() is a poor choice for function name. It actually uses whatever contrast coding we have set up in R. However, the default is are dummy coded contrasts (R calls this treatment contrasts). See ?contrasts and options(\"contrasts\") for more info.\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars + ms_zoning, \n         data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\")) |&gt;\n  step_dummy(ms_zoning)\n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 5\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n• Variable mutation for: fct_collapse(ms_zoning, residential = c(\"res_high\",\n  \"res_med\", \"res_low\"), commercial = c(\"agri\", \"commer\", \"indus\"), floating =\n  \"float\")\n\n\n• Dummy variables from: ms_zoning\n\n\n\nCoding Sidebar\nYou should also read more about some other step_() functions that you might use for categorical predictors: - step_other() to combine all low frequency categories into a single “other” category. - step_unknown() to assign missing values their own category - You can use selector functions. For example, you could make dummy variables out of all of your factors in one step using step_dummy(all_nominal_predictors()).\nSee the Step Functions - Dummy Variables and Encoding section on the tidymodels website for additional useful functions.\nWe have also described these in the section on factor steps in Appendix 1\n\nLet’s see if the addition of ms_zoning helped\n\nNotice the addition of the dummy coded features to the feature matrix\nNotice the removal of the factor ms_zoning\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n7\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\nms_zoning_floating\n0\n1\n0.05\n0.21\n0\n0\n0\n0\n1\n4.38\n17.22\n\n\nms_zoning_residential\n0\n1\n0.94\n0.23\n0\n1\n1\n1\n1\n-3.86\n12.90\n\n\n\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n7\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1493.00\n483.78\n480\n1143.5\n1436.0\n1729.50\n3608\n0.92\n1.16\n\n\nlot_area\n0\n1\n10462.08\n10422.55\n1680\n7500.0\n9563.5\n11780.75\n215245\n15.64\n301.66\n\n\nyear_built\n0\n1\n1971.08\n30.96\n1875\n1954.0\n1975.0\n2000.00\n2010\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n1.74\n0.76\n0\n1.0\n2.0\n2.00\n4\n-0.24\n0.22\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311\n129125.0\n160000.0\n213000.00\n556581\n1.42\n2.97\n\n\nms_zoning_floating\n0\n1\n0.05\n0.22\n0\n0.0\n0.0\n0.00\n1\n4.07\n14.58\n\n\nms_zoning_residential\n0\n1\n0.93\n0.25\n0\n1.0\n1.0\n1.00\n1\n-3.51\n10.33\n\n\n\n\n\nNow lets fit a model with these features\n\nfit_lm_6 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_6, feat_val)$.pred)\n\n\n\nerror_val &lt;- error_val |&gt; \n  bind_rows(tibble(model = \"6 feature linear model w/ms_zoning\", \n                   rmse_val = rmse_vec(feat_val$sale_price,\n                                       predict(fit_lm_6,\n                                               feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 4 × 2\n  model                              rmse_val\n  &lt;chr&gt;                                 &lt;dbl&gt;\n1 simple linear model                  51375.\n2 4 feature linear model               39903.\n3 4 feature linear model with YJ       41660.\n4 6 feature linear model w/ms_zoning   39846.\n\n\nRemoving Yeo Johnson transformation but adding dummy coded ms_zoning may have helped a little\n[Will the addition of new predictors/features to a model always reduce RMSE in train? in validation?].{red} 1\n\n\n3.5.1 Ordered Categorical Predictors\nWe have two paths to pursue for ordered categorical predictors\n\nWe can treat them like unordered categorical predictors (e.g., dummy code)\nWe can treat them like numeric predictors (either raw or with an added transformation if needed)\n\n\nLet’s consider overall_qual\n\ndata_trn |&gt; \n  plot_categorical(\"overall_qual\", \"sale_price\") |&gt; \n  cowplot::plot_grid(plotlist = _, ncol = 2)\n\n\n\n\nObservations:\n\nLow frequency for low and to some degree high quality response options. If dummy coding, may want to collapse some (1-2)\nThere is a monotonic relationship (mostly linear) with sale_price. Treat as numeric?\nNot skewed so doesn’t likely need to be transformed if treated as numeric\nNumeric will take one feature vs. many (9?) features for dummy codes.\n\nDummy codes are more flexible but we may not need this flexibility (and unnecessary flexibility increases overfitting)\n\n\nLet’s add overall_qual to our model as numeric\nRemember that this predictor was ordinal so we paid special attention to the order of the levels when we classed this factor. Lets confirm they are in order\n\ndata_trn |&gt; pull(overall_qual) |&gt; levels()\n\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n\n\nTo convert this to numeric (with levels in this order), we can use another simple mutate inside our recipe.\n\nrec &lt;- \n  recipe(sale_price ~  ~ gr_liv_area + lot_area + year_built + garage_cars + \n           ms_zoning + overall_qual, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\"),\n              overall_qual = as.numeric(overall_qual)) |&gt;\n  step_dummy(ms_zoning)\n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 6\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n• Variable mutation for: fct_collapse(ms_zoning, residential = c(\"res_high\",\n  \"res_med\", \"res_low\"), commercial = c(\"agri\", \"commer\", \"indus\"), floating =\n  \"float\"), as.numeric(overall_qual)\n\n\n• Dummy variables from: ms_zoning\n\n\nCoding Sidebar\nThere is a step function called step_ordinalscore() but it requires that the factor is classed as an ordered factor. It is also more complicated than needed in our opinion. Just use as.numeric()\n\nLet’s evaluate this model\n\nMaking features\nSkipping the skim to save space (we promised we checked it previously!)\nFitting model\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\nfit_lm_7 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\nPlotting results\nQuantifying held out error\n\n\nplot_truth(truth = feat_val$sale_price, \n                                 estimate = predict(fit_lm_7, feat_val)$.pred)\n\n\n\nerror_val &lt;- bind_rows(error_val, \n                        tibble(model = \"7 feature linear model\", \n                               rmse_val = rmse_vec(feat_val$sale_price, predict(fit_lm_7, feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 5 × 2\n  model                              rmse_val\n  &lt;chr&gt;                                 &lt;dbl&gt;\n1 simple linear model                  51375.\n2 4 feature linear model               39903.\n3 4 feature linear model with YJ       41660.\n4 6 feature linear model w/ms_zoning   39846.\n5 7 feature linear model               34080.\n\n\nThat helped!"
  },
  {
    "objectID": "003_regression.html#extensions-to-interactive-models-and-non-linear-models",
    "href": "003_regression.html#extensions-to-interactive-models-and-non-linear-models",
    "title": "3  Introduction to Regression Models",
    "section": "3.6 Extensions to Interactive Models and Non-linear Models",
    "text": "3.6 Extensions to Interactive Models and Non-linear Models\n\n3.6.1 Interactions\nThere may be interactive effects among our predictors\n\nSome statistical algorithms (e.g., KNN) can naturally accommodate interactive effects without any feature engineering\nLinear models cannot\nNothing to fear, tidymodels makes it easy to feature engineer interactions\n[BUT - as we will learn, we generally think that if you expect lots of interactions, the linear model may not be the best model to use]\n\n\nFor example, it may be that the relationship between year_built and sale_price depends on overall_qual.\n\nOld houses are expensive if they are in good condition\nbut old houses are very cheap if they are in poor condition\n\nIn the tidymodels framework\n\nCoding interactions is done by feature engineering, not by formula (Note that formula does not change below in recipe)\nThis seems appropriate to us as we are making new features to represent interactions\nWe still use an R formula like interface to specify the interaction term features that will be created\nsee more details on the tidymodels website\n\n\nrec &lt;- \n  recipe(sale_price ~  ~ gr_liv_area + lot_area + year_built + garage_cars + \n           ms_zoning + overall_qual, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\"),\n              overall_qual = as.numeric(overall_qual)) |&gt;\n  step_dummy(ms_zoning) |&gt; \n  step_interact(~ overall_qual:year_built)\n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 6\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n• Variable mutation for: fct_collapse(ms_zoning, residential = c(\"res_high\",\n  \"res_med\", \"res_low\"), commercial = c(\"agri\", \"commer\", \"indus\"), floating =\n  \"float\"), as.numeric(overall_qual)\n\n\n• Dummy variables from: ms_zoning\n\n\n• Interactions with: overall_qual:year_built\n\n\n\nLet’s prep, bake, fit, and evaluate!\n\nNote the new interaction term (we just skim feat_trn here)\nNamed using “x” to specify the interaction\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n9\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n9\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\noverall_qual\n0\n1\n6.08\n1.41\n1\n5\n6\n7\n10\n0.20\n-0.03\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\nms_zoning_floating\n0\n1\n0.05\n0.21\n0\n0\n0\n0\n1\n4.38\n17.22\n\n\nms_zoning_residential\n0\n1\n0.94\n0.23\n0\n1\n1\n1\n1\n-3.86\n12.90\n\n\noverall_qual_x_year_built\n0\n1\n12015.69\n2907.93\n1951\n9800\n11808\n14021\n20090\n0.24\n-0.11\n\n\n\n\n\n\nfix model\nplot\ncalculate held out error\n\n\nfit_lm_8 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~., \n      data = feat_trn)\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_8, feat_val)$.pred)\n\n\n\nerror_val &lt;- bind_rows(error_val, \n                      tibble(model = \n                               \"8 feature linear model w/interaction\", \n                             rmse_val = rmse_vec(feat_val$sale_price,\n                                                 predict(fit_lm_8,\n                                                         feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 6 × 2\n  model                                rmse_val\n  &lt;chr&gt;                                   &lt;dbl&gt;\n1 simple linear model                    51375.\n2 4 feature linear model                 39903.\n3 4 feature linear model with YJ         41660.\n4 6 feature linear model w/ms_zoning     39846.\n5 7 feature linear model                 34080.\n6 8 feature linear model w/interaction   32720.\n\n\n\nThat helped!\n\n\nYou can also feature engineer interactions with categorical predictors\n\nThe categorical predictors should first be converted to dummy code features\nYou will indicate the interactions using the variable names that will be assigned to these dummy code features\nUse starts_with() or matches() to make it easy if there are many features associated with a categorical predictor\nCan use “~ .^2” to include all two way interactions (be careful if you have dummy coded features!)\n\nLet’s code an interaction between ms_zoning & year_built.\n\nOld homes are cool\nOld commercial spaces are never cool\nMaybe this is why the main effect of ms_zoning wasn’t useful\n\n\nrec &lt;- \n  recipe(sale_price ~  ~ gr_liv_area + lot_area + year_built + garage_cars + \n           ms_zoning + overall_qual, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\"),\n              overall_qual = as.numeric(overall_qual)) |&gt;\n  step_dummy(ms_zoning) |&gt; \n  step_interact(~ overall_qual:year_built) |&gt; \n  step_interact(~ starts_with(\"ms_zoning_\"):year_built)  \n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 6\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n• Variable mutation for: fct_collapse(ms_zoning, residential = c(\"res_high\",\n  \"res_med\", \"res_low\"), commercial = c(\"agri\", \"commer\", \"indus\"), floating =\n  \"float\"), as.numeric(overall_qual)\n\n\n• Dummy variables from: ms_zoning\n\n\n• Interactions with: overall_qual:year_built\n\n\n• Interactions with: starts_with(\"ms_zoning_\"):year_built\n\n\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\nYup, we have two new interaction features as expected\n\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n11\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n11\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n1506.84\n511.44\n438\n1128\n1450\n1759\n5642\n1.43\n5.19\n\n\nlot_area\n0\n1\n10144.16\n8177.55\n1476\n7500\n9375\n11362\n164660\n11.20\n182.91\n\n\nyear_built\n0\n1\n1971.35\n29.65\n1880\n1953\n1972\n2000\n2010\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n1.78\n0.76\n0\n1\n2\n2\n4\n-0.26\n0.10\n\n\noverall_qual\n0\n1\n6.08\n1.41\n1\n5\n6\n7\n10\n0.20\n-0.03\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789\n129500\n160000\n213500\n745000\n1.64\n4.60\n\n\nms_zoning_floating\n0\n1\n0.05\n0.21\n0\n0\n0\n0\n1\n4.38\n17.22\n\n\nms_zoning_residential\n0\n1\n0.94\n0.23\n0\n1\n1\n1\n1\n-3.86\n12.90\n\n\noverall_qual_x_year_built\n0\n1\n12015.69\n2907.93\n1951\n9800\n11808\n14021\n20090\n0.24\n-0.11\n\n\nms_zoning_floating_x_year_built\n0\n1\n90.29\n415.84\n0\n0\n0\n0\n2009\n4.38\n17.22\n\n\nms_zoning_residential_x_year_built\n0\n1\n1860.03\n453.95\n0\n1948\n1968\n1997\n2010\n-3.83\n12.78\n\n\n\n\n\n\nFit model\nPlot\nQuantify held out error\n\n\nfit_lm_10 &lt;- \n  linear_reg() |&gt; \n  set_engine(\"lm\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_lm_10, feat_val)$.pred)\n\n\n\nerror_val &lt;- error_val |&gt; \n  bind_rows(tibble(model = \"10 feature linear model w/interactions\", \n                   rmse_val = rmse_vec(feat_val$sale_price,\n                                       predict(fit_lm_10,\n                                               feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 7 × 2\n  model                                  rmse_val\n  &lt;chr&gt;                                     &lt;dbl&gt;\n1 simple linear model                      51375.\n2 4 feature linear model                   39903.\n3 4 feature linear model with YJ           41660.\n4 6 feature linear model w/ms_zoning       39846.\n5 7 feature linear model                   34080.\n6 8 feature linear model w/interaction     32720.\n7 10 feature linear model w/interactions   32708.\n\n\n\nNot really any better\nShouldn’t just include all interactions without reason\n\nEither you have done EDA to support them or\nYou have substantive interest in them (explanatory question)\nIf you want all interactions, use a statistical algorithm that supports those relationships without feature engineering (e.g., KNN, random forest and other decision trees)\n\n\n\n\n\n3.6.2 Non-linear Models\nWe may also want to model non-linear effects of our predictors\n\nSome non-parametric models can accommodate non-linear effects without feature engineering (e.g., KNN, Random Forest).\nNon-linear effects can be accommodated in a linear model with feature engineering\n\nTransformations of Y or X. See Step Functions - Individual Transformations on tidymodels website\nOrdinal predictors can be coded with dummy variables\nQuantitative variables can be split at threshold\nPolynomial contrasts for quantitative or categorical predictors (see step_poly())\n\nWe will continue to explore these options throughout the course"
  },
  {
    "objectID": "003_regression.html#knn-regression",
    "href": "003_regression.html#knn-regression",
    "title": "3  Introduction to Regression Models",
    "section": "3.7 KNN Regression",
    "text": "3.7 KNN Regression\nK Nearest Neighbor\n\nIs a non-parametric regression and classification statistical algorithm\n\nIt does not yield specific parameter estimates for features/predictors (or statistical tests for those parameter estimates)\nThere are still ways to use it to address explanatory questions (visualizations, model comparisons, feature importance)\n\nVery simple but also powerful (listed commonly among top 10 algorithms)\n\nBy powerful, it is quite flexible and can accommodate many varied DGPs without the need for much feature engineering with its predictors\nMay not need most transformations of X or Y\nMay not need to model interactions\nStill need to handle missing data, outliers, and categorical predictors\n\nAlgorithm “memorizes” the training set (lazy learning)\n\nLazy learning is most useful for large, continuously changing datasets with few attributes (features) that are commonly queried (e.g., online recommendation systems)\n\nPrediction for any new observation is based on \\(k\\) most similar observations from the dataset\n\n\\(k\\) provides direct control over the bias-variance trade-off for this algorithm\n\n\n\nTo better understand KNN let’s simulate training data for three different DGPs (linear - y, polynomial - y2, and step - y3)\n\nLet’s start with a simple example where the DGP for Y is linear on one predictor (X)\nThis figure displays:\n\nDGP\nPrediction line from a simple linear model\nRed lines to represent three new observations (X = 10, 50, 90) we want to make predictions for via a standard KNN\n\n[What would 5-NN predictions look like for each of these three new values of X?].{red} 2\nDGP: \\(y = rnorm(150, x, 10)\\)\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n\n\n\n\n\n\nKNN can easily accommodate non-linear relationships between numeric predictors and outcomes without any feature engineering for predictors\nIn fact, it can flexibly handle any shape of relationship\nDGP: \\(y2 = rnorm(150, x^4 / 800000, 8)\\)\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\nDGP: \\(y3 = if\\_else(x &lt; 40, rnorm(150, 25, 10), rnorm(150, 75, 10))\\)\n\n\nWarning in geom_vline(xintercept = 90, color = \"red\", linewith = 1.5): Ignoring\nunknown parameters: `linewith`\n\n\n\n\n\n\n\n3.7.1 The hyperparameter k\nKNN is our first example of a statistical algorithm that includes a hyperparameter, in this case \\(k\\)\n\nAlgorithm hyperparameters differ from parameters in that they cannot be estimated while fitting the algorithm to the training set\nThey must be set in advance\nk = 5 is the default for kknn(), the engine from the kknn package that we will use to fit a KNN within tidymodels.\n\n\\(kknn()\\) weights observations (neighbors) based on distance.\n\nAn option exists for unweighted as well but not likely used much (default is optimal weighting, use it!).\n\n\n\nUsing the polynomial DGP above, let’s look at a 5-NN yields\n\nNote the new category of algorithm, new engine, and the need to set a mode (because KNN can be used for regression and classification)\nWe can look in the package documentation to better understand what is being done (?kknn::train.kknn).\n\n\nnearest_neighbor() |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  translate()\n\nK-Nearest Neighbor Model Specification (regression)\n\nComputational engine: kknn \n\nModel fit template:\nkknn::train.kknn(formula = missing_arg(), data = missing_arg(), \n    ks = min_rows(5, data, 5))\n\n\nSet up simple feature engineering recipe and get training features (nothing happening but let’s follow normal routine anyway)\n\nrec &lt;- \n  recipe(y2 ~ x, data = data_trn_demo)\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn_demo)\n\nfeat_trn_demo &lt;- rec_prep |&gt; \n  bake(data_trn_demo)\n\n\nFit 5NN\n\nfit_5nn_demo &lt;- \n  nearest_neighbor() |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y2 ~ ., data = feat_trn_demo)\n\n\nGet a validation set (a new sample using same polynomial DGP)\n\ndata_val_demo &lt;- tibble(x = runif(200, 1, 100),\n               y = rnorm(200, x, 10),\n               y_dgp = rnorm(200, x ,0),\n               y2 = rnorm(200, x^4 / 800000, 8),\n               y2_dgp = rnorm(200, x^4 / 800000 ,0),\n               y3 = if_else(x &lt; 40, rnorm(200, 25, 10),  rnorm(200, 75, 10)),\n               y3_dgp = if_else(x &lt; 40, rnorm(200, 25, 0),  rnorm(200, 75, 0)))\n\nfeat_val_demo &lt;- rec_prep |&gt; \n  bake(data_val_demo)\n\nDisplay 5NN predictions in validation\n\nKNN (with k = 5) does a pretty good job of representing the shape of the DGP (low bias)\nKNN displays some (but minimal) evidence of overfitting\nSimple linear model does not perform well (clear/high bias)\n\n\nfeat_val_demo |&gt; \n  bind_cols(data_val_demo |&gt; select(y, y2_dgp)) |&gt; # add in other outcomes from data\n  ggplot(aes(x = x, y = y2)) +\n    geom_line(aes(x = x, y = y2_dgp, color = \"blue\"), linewidth = 1.5) +\n    geom_smooth(aes(color = \"green\"), method = 'lm', formula = y ~ x,  se = FALSE) +\n    geom_line(aes(x = x, y = predict(fit_5nn_demo, feat_val_demo)$.pred, color = \"red\"), linewidth = 1.5) +\n    geom_point(aes(y = y2), color = \"black\") +\n    scale_color_identity(name = \"Model\",\n                       breaks = c(\"blue\", \"green\", \"red\"),\n                       labels = c(\"DGP\", \"linear model\", \"k = 5\"),\n                       guide = \"legend\")\n\n\n\n\n\nLet’s pause and consider our conceptual understanding of the impact of \\(k\\) on the bias-variance trade-off\n[How will the size of \\(k\\) influence model performance (e.g., bias, overfitting/variance)?].{red} 3\n[How will k = 1 perform in training and validation sets?].{red} 4\n\nk = 1\nFit new model\nRecipe and features have not changed\n\nfit_1nn_demo &lt;- \n1  nearest_neighbor(neighbors = 1) |&gt;\n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y2 ~ ., data = feat_trn_demo)\n\n\n1\n\nSet k with neighbors =\n\n\n\n\n\nVisualize prediction models in Train and Validation\n\n\n\n\n\n\nCalculate RMSE in validation for two KNN models\nk = 1\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_1nn_demo, feat_val_demo)$.pred)\n\n[1] 10.91586\n\n\nk = 5\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_5nn_demo, feat_val_demo)$.pred)\n\n[1] 8.387035\n\n\n\nWhat if we go the other way and increase \\(k\\) to 75\n\nfit_75nn_demo &lt;- \n  nearest_neighbor(neighbors = 75) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y2 ~ ., data = feat_trn_demo)\n\n\nVisualize prediction models in Train and Validation\n\n#|echo: false\nplot_train &lt;- feat_trn_demo |&gt; \n  bind_cols(data_trn_demo |&gt; select(y, y2_dgp)) |&gt; # add in other outcomes for fig\n  ggplot(aes(x = x, y = y2)) +\n    geom_line(aes(x = x, y = y2_dgp, color = \"blue\"), linewidth = 1.5) +\n    geom_line(aes(x = x, y = predict(fit_5nn_demo, feat_trn_demo)$.pred, color = \"red\"), linewidth = 1.5) +\n    geom_line(aes(x = x, y = predict(fit_1nn_demo, feat_trn_demo)$.pred, color = \"green\"), linewidth = 1.5) +\n    geom_line(aes(x = x, y = predict(fit_75nn_demo, feat_trn_demo)$.pred, color = \"yellow\"), linewidth = 1.5) +\n    geom_point(aes(y = y2), color = \"black\") +\n    scale_color_identity(name = \"Model\",\n                       breaks = c(\"blue\", \"red\", \"green\", \"yellow\"),\n                       labels = c(\"DGP\", \"k = 5\", \"k = 1\", \"k = 75\"),\n                       guide = \"legend\")\n\nplot_val &lt;- feat_val_demo |&gt; \n  bind_cols(data_val_demo |&gt; select(y, y2_dgp)) |&gt; # add in other outcomes for fig\n  ggplot(aes(x = x, y = y2)) +\n    geom_line(aes(x = x, y = y2_dgp, color = \"blue\"), linewidth = 1.5) +\n    geom_line(aes(x = x, y = predict(fit_5nn_demo, feat_val_demo)$.pred, color = \"red\"), linewidth = 1.5) +\n    geom_line(aes(x = x, y = predict(fit_1nn_demo, feat_val_demo)$.pred, color = \"green\"), linewidth = 1.5) +\n    geom_line(aes(x = x, y = predict(fit_75nn_demo, feat_val_demo)$.pred, color = \"yellow\"), linewidth = 1.5) +\n    geom_point(aes(y = y2), color = \"black\") +\n     scale_color_identity(name = \"Model\",\n                       breaks = c(\"blue\", \"red\", \"green\", \"yellow\"),\n                       labels = c(\"DGP\", \"k = 5\", \"k = 1\", \"k = 75\"),\n                       guide = \"legend\")\n\ncowplot::plot_grid(plot_train, plot_val, labels = list(\"Training Set\", \"Validation Set\"), ncol = 2, nrow = 1, hjust = -1)\n\n\n\n\n\nCalculate RMSE in validation for three KNN models\nThis is the bias-variance trade-off in action\nk = 1\nhigh variance\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_1nn_demo, feat_val_demo)$.pred)\n\n[1] 10.91586\n\n\nk = 5\njust right (well better at least)\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_5nn_demo, feat_val_demo)$.pred)\n\n[1] 8.387035\n\n\nk = 75\nhigh bias\n\nrmse_vec(feat_val_demo$y2, \n         predict(fit_75nn_demo, feat_val_demo)$.pred)\n\n[1] 15.34998\n\n\n\n\n\n3.7.2 Defining “Nearest”\nTo make a prediction for some new observation, we need to identify the observations from the training set that are nearest to it\n\nNeed a distance measure to define “nearest”\nThere are a number of different distance measures available (e.g., Euclidean, Manhattan, Chebyshev, Cosine, Minkowski)\nEuclidean is most commonly used in KNN\nIMPORTANT: We care only about:\n\nDistance between a validation observation and all the training observations\nNeed to find the \\(k\\) observations in training that are nearest to the validation observation (i.e., its neighbors)\nDistance is defined based on these observations’ features, not their outcomes\n\n\n\nEuclidean distance between any two points is an n-dimensional extension of the Pythagorean formula (which applies explicitly with 2 features/2 dimensional space).\n\\(C^2 = A^2 + B^2\\)\n\\(C = \\sqrt{A^2 + B^2}\\)\n…where C is the distance between two points\n\nThe Euclidean distance between 2 points (p and q) in two dimensions (2 predictors, x1 = A, x2 = B)\n\\(Distance = \\sqrt{A^2 + B^2}\\)\n\\(Distance = \\sqrt{(q1 - p1)^2 + (q2 - p2)^2}\\)\n\\(Distance = \\sqrt{(2 - 1)^2 + (5 - 2)^2}\\)\n\\(Distance = 3.2\\)\n\n\n\n\n\n\nOne dimensional (one feature) is simply the subtraction of scores on that feature (x1) between p and q\n\\(Distance = \\sqrt{(q1 - p1)^2}\\)\n\\(Distance = \\sqrt{(2 - 1)^2}\\)\n\\(Distance = 1\\)\n\n\n\n\n\nN-dimensional generalization for n features:\n\\(Distance = \\sqrt{(q1 - p1)^2 + (q2 - p2)^2 + ... + (qn - pn)^2}\\)\n\nManhattan distance is also referred to as city block distance\n\nTravel down the “A” street for 1 unit\nTravel down the “B” street for 3 units\nTotal distance = 4 units\n\nFor two features/dimensions\n\\(Distance = |A + B|\\)\n\n\n\n\n\n\nkknn() uses Minkowski distance (see Wikipedia or less mathematical description)\n\nIt is a more complex parameterized distance formula\n\nThis parameter is called p, referred to as distance in kknn()\n\nEuclidean and Manhattan distances are special cases where p = 2 and 1, respectively\nThe default p in kknn() = 2 (Euclidean distance)\n\nThis default (like all defaults) can be changed when you define the algorithm using nearest_neighbor()\n\n\n\n3.7.3 Scaling X\nDistance is dependent on scales of all the features. We need to put all features on the same scale\n\nScale all features to SD = 1 (using step_scale(all_numeric_predictors()))\nRange correct [0, 1] all features (using step_range(all_numeric_predictors()))\n\n\n\n3.7.4 Categorical Predictors\nKNN requires numeric features (for distance calculation).\n\nFor categorical predictors, you will need to use dummy coding or other feature engineering that results in numeric features.\ne.g., step_dummy(all_factor_predictors())\n\n\n\n\n3.7.5 KNN with Ames Housing Prices\nLet’s use KNN with Ames\n\nTrain a model using only numeric predictors and overall_qual as numeric\nUse the default k = 5 algorithm\nrange correct all features\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars + overall_qual, \n         data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(overall_qual = as.numeric(overall_qual)) |&gt; \n1  step_scale(all_numeric_predictors())\n\nrec\n\n\n1\n\nRemember to take advantage of these selectors for easier code! See ?has_role for more details\n\n\n\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 5\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n• Variable mutation for: as.numeric(overall_qual)\n\n\n• Scaling for: all_numeric_predictors()\n\n\n\nrec_prep &lt;- rec |&gt; \n  prep(feat_trn)\n\nfeat_trn &lt;- rec_prep |&gt;\n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\nSkim training features. Note all SD = 1\n\nfeat_trn |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_trn\n\n\nNumber of rows\n1465\n\n\nNumber of columns\n6\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n6\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n2.95\n1.00\n0.86\n2.21\n2.84e+00\n3.44\n11.03\n1.43\n5.19\n\n\nlot_area\n0\n1\n1.24\n1.00\n0.18\n0.92\n1.15e+00\n1.39\n20.14\n11.20\n182.91\n\n\nyear_built\n0\n1\n66.48\n1.00\n63.40\n65.86\n6.65e+01\n67.45\n67.79\n-0.54\n-0.62\n\n\ngarage_cars\n0\n1\n2.33\n1.00\n0.00\n1.31\n2.62e+00\n2.62\n5.23\n-0.26\n0.10\n\n\noverall_qual\n0\n1\n4.30\n1.00\n0.71\n3.54\n4.24e+00\n4.95\n7.07\n0.20\n-0.03\n\n\nsale_price\n0\n1\n180696.15\n78836.41\n12789.00\n129500.00\n1.60e+05\n213500.00\n745000.00\n1.64\n4.60\n\n\n\n\n\nSkim validation features. Note SD. [Why not exactly 1?].{red}\n\nfeat_val |&gt; skim_all()\n\n\nData summary\n\n\nName\nfeat_val\n\n\nNumber of rows\n490\n\n\nNumber of columns\n6\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n6\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nskew\nkurtosis\n\n\n\n\ngr_liv_area\n0\n1\n2.92\n0.95\n0.94\n2.24\n2.81\n3.38\n7.05\n0.92\n1.16\n\n\nlot_area\n0\n1\n1.28\n1.27\n0.21\n0.92\n1.17\n1.44\n26.32\n15.64\n301.66\n\n\nyear_built\n0\n1\n66.47\n1.04\n63.23\n65.90\n66.61\n67.45\n67.79\n-0.66\n-0.41\n\n\ngarage_cars\n0\n1\n2.27\n0.99\n0.00\n1.31\n2.62\n2.62\n5.23\n-0.24\n0.22\n\n\noverall_qual\n0\n1\n4.28\n0.98\n0.71\n3.54\n4.24\n4.95\n7.07\n0.00\n0.35\n\n\nsale_price\n0\n1\n178512.82\n75493.59\n35311.00\n129125.00\n160000.00\n213000.00\n556581.00\n1.42\n2.97\n\n\n\n\n\n\nFit 5NN\n\nfit_5nn_5num &lt;- \n  nearest_neighbor() |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\nerror_val &lt;- bind_rows(error_val, \n                        tibble(model = \"5 numeric predictor 5nn\", \n                               rmse_val = rmse_vec(feat_val$sale_price, predict(fit_5nn_5num, feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 8 × 2\n  model                                  rmse_val\n  &lt;chr&gt;                                     &lt;dbl&gt;\n1 simple linear model                      51375.\n2 4 feature linear model                   39903.\n3 4 feature linear model with YJ           41660.\n4 6 feature linear model w/ms_zoning       39846.\n5 7 feature linear model                   34080.\n6 8 feature linear model w/interaction     32720.\n7 10 feature linear model w/interactions   32708.\n8 5 numeric predictor 5nn                  32837.\n\n\n\nNot bad!\n\n\nKNN also mostly solved the linearity problem\n\nWe might be able to improve the linear models with better transformations of X and Y\nHowever, this wasn’t needed for KNN!\n\n\nplot_truth(truth = feat_val$sale_price, \n           estimate = predict(fit_5nn_5num, feat_val)$.pred)\n\n\n\n\n\nBut 5NN may be overfit. k = 5 is pretty low\nAgain with k = 20\n\nfit_20nn_5num &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\nerror_val &lt;- error_val |&gt; \n  bind_rows(tibble(model = \"5 numeric predictor 20nn\", \n                   rmse_val = rmse_vec(feat_val$sale_price, \n                                       predict(fit_20nn_5num, \n                                               feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 9 × 2\n  model                                  rmse_val\n  &lt;chr&gt;                                     &lt;dbl&gt;\n1 simple linear model                      51375.\n2 4 feature linear model                   39903.\n3 4 feature linear model with YJ           41660.\n4 6 feature linear model w/ms_zoning       39846.\n5 7 feature linear model                   34080.\n6 8 feature linear model w/interaction     32720.\n7 10 feature linear model w/interactions   32708.\n8 5 numeric predictor 5nn                  32837.\n9 5 numeric predictor 20nn                 30535.\n\n\n\nThat helped some\n\n\nOne more time with k = 50 to see where we are in the bias-variance function\n\nfit_50nn_5num &lt;- \n  nearest_neighbor(neighbors = 50) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\nerror_val &lt;- error_val |&gt; \n  bind_rows(tibble(model = \"5 numeric predictor 50nn\", \n                   rmse_val = rmse_vec(feat_val$sale_price, \n                                       predict(fit_50nn_5num, \n                                               feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 10 × 2\n   model                                  rmse_val\n   &lt;chr&gt;                                     &lt;dbl&gt;\n 1 simple linear model                      51375.\n 2 4 feature linear model                   39903.\n 3 4 feature linear model with YJ           41660.\n 4 6 feature linear model w/ms_zoning       39846.\n 5 7 feature linear model                   34080.\n 6 8 feature linear model w/interaction     32720.\n 7 10 feature linear model w/interactions   32708.\n 8 5 numeric predictor 5nn                  32837.\n 9 5 numeric predictor 20nn                 30535.\n10 5 numeric predictor 50nn                 31055.\n\n\n\nToo high, now we have bias……\nWe will learn a more rigorous method for selecting the optimal value for \\(k\\) (i.e., tuning this hyperparameter) in unit 5\n\n\nTo better understand bias-variance trade-off, let’s look at error across these three values of \\(k\\) in train and validation for Ames\nTraining\n\nRemember that training error would be 0 for k = 1\nTraining error is increasing as \\(k\\) increases b/c it KNN is overfitting less (so its not fitting the noise in train as well)\n\n\nrmse_vec(feat_trn$sale_price, \n         predict(fit_5nn_5num, feat_trn)$.pred)\n\n[1] 19012.94\n\nrmse_vec(feat_trn$sale_price, \n         predict(fit_20nn_5num, feat_trn)$.pred)\n\n[1] 27662.2\n\nrmse_vec(feat_trn$sale_price, \n         predict(fit_50nn_5num, feat_trn)$.pred)\n\n[1] 31069.12\n\n\nValidation\n\nValidation error is first going down as \\(k\\) increases (and it would have been very high for k = 1)\nBias is likely increasing a bit\nBut this is compensated by big decreases in overfitting variance\nThe trade-off is good for k = 20 relative to 5 and 1\nAt some point, as \\(k\\) increases the increase in bias outweighed the decrease in variance and validation error increased too.\n\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_5nn_5num, feat_val)$.pred)\n\n[1] 32837.37\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_20nn_5num, feat_val)$.pred)\n\n[1] 30535.04\n\nrmse_vec(feat_val$sale_price, \n         predict(fit_50nn_5num, feat_val)$.pred)\n\n[1] 31054.6\n\n\n\nLet’s do one final example and add one of our unordered categorical variables into the model: ms_zoning\n\nNeed to collapse levels and then dummy\n\n\nrec &lt;- \n  recipe(sale_price ~ gr_liv_area + lot_area + year_built + garage_cars + \n           overall_qual + ms_zoning, data = data_trn) |&gt; \n  step_impute_median(garage_cars) |&gt; \n  step_mutate(overall_qual = as.numeric(overall_qual)) |&gt; \n  step_mutate(ms_zoning = fct_collapse(ms_zoning,\n                                 \"residential\" = c(\"res_high\", \"res_med\", \"res_low\"),\n                                 \"commercial\" = c(\"agri\", \"commer\", \"indus\"),\n                                 \"floating\" = \"float\")) |&gt;\n  step_dummy(ms_zoning) |&gt; \n  step_scale(all_numeric_predictors())\n\nrec\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 6\n\n\n\n\n\n── Operations \n\n\n• Median imputation for: garage_cars\n\n\n• Variable mutation for: as.numeric(overall_qual)\n\n\n• Variable mutation for: fct_collapse(ms_zoning, residential = c(\"res_high\",\n  \"res_med\", \"res_low\"), commercial = c(\"agri\", \"commer\", \"indus\"), floating =\n  \"float\")\n\n\n• Dummy variables from: ms_zoning\n\n\n• Scaling for: all_numeric_predictors()\n\n\n\nrec_prep &lt;- rec |&gt; \n  prep(data_trn)\n\nfeat_trn &lt;- rec_prep |&gt; \n  bake(data_trn)\n\nfeat_val &lt;- rec_prep |&gt; \n  bake(data_val)\n\n\nFit and evaluate\n\nfit_20nn_5num_mszone &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(sale_price ~ ., data = feat_trn)\n\n\nerror_val &lt;- error_val |&gt; \n  bind_rows(tibble(model = \"5 numeric predictor 20nn with ms_zoning\", \n                   rmse_val = rmse_vec(feat_val$sale_price, \n                                       predict(fit_20nn_5num_mszone, \n                                               feat_val)$.pred)))\n\nerror_val\n\n# A tibble: 11 × 2\n   model                                   rmse_val\n   &lt;chr&gt;                                      &lt;dbl&gt;\n 1 simple linear model                       51375.\n 2 4 feature linear model                    39903.\n 3 4 feature linear model with YJ            41660.\n 4 6 feature linear model w/ms_zoning        39846.\n 5 7 feature linear model                    34080.\n 6 8 feature linear model w/interaction      32720.\n 7 10 feature linear model w/interactions    32708.\n 8 5 numeric predictor 5nn                   32837.\n 9 5 numeric predictor 20nn                  30535.\n10 5 numeric predictor 50nn                  31055.\n11 5 numeric predictor 20nn with ms_zoning   30172.\n\n\n\nNow it helps.\n\nMight have to do with interactions with other predictors that we didn’t model in the linear model\nKNN automatically accommodates interactions. Why?\nThis model is a bit more complex and might benefit further from higher \\(k\\)\n\nAs a teaser, here is another performance metric for this model - \\(R^2\\). Not too shabby! Remember, there is certainly some irreducible error in sale_price that will put a ceiling on \\(R^2\\) and a floor on RMSE\n\nrsq_vec(feat_val$sale_price, \n        predict(fit_20nn_5num_mszone, feat_val)$.pred)\n\n[1] 0.8404044\n\n\nOverall, we now have a model that predicts housing prices with about 30K of RMSE and accounting for 84% of the variance. I am sure you can improve on this!"
  },
  {
    "objectID": "003_regression.html#discussion",
    "href": "003_regression.html#discussion",
    "title": "3  Introduction to Regression Models",
    "section": "3.8 Discussion",
    "text": "3.8 Discussion\n\nAnnouncements\n\n\nBug in print method for recipes\n\nFor bug report with (long) reprex:\nFor now use: remotes::install_github(\"tidymodels/recipes#1084\")\n\nReprex\n\nRead new appendix\nWe now expect reprex for help on application assignments\nWill review in lab next week\n\nHomework is basically same for unit 4\n\nNew dataset - titanic\nDo EDA but we don’t need to see it\nFit KNN and RDA models (will learn about LDA, QDA and RDA in unit)\nSubmit predictions. Free lunch!\nWill know about first free lunch by next Thursday\n\nCourse feedback in quiz as trial\n\n\nQuestions\n\n\nWhat are two broad sources of error?\nWhat are two broad sources of reducible error?\nWhy do we need independent validation data to select the best model configuration?\nWhat factors make the need for a validation set even greater?\nWhat is RMSE? Connect it to metric you already know? How is it being used in lm (two ways)?; in knn (one way)?\nHow does bias and variance manifest when you look at your performance metric (RMSE) in training and validation sets?\nWill the addition of new predictors/features to a (lm?) model always reduce RMSE in train? in validation? Connect to concepts of bias and variance\n\n\nk\n\n\nWhat is it and how does it get used when making predictions?\nWhat is the impact of k on bias and variance/overfitting?\nk=1 - performance in train? in val?\n\n\nInteraction in KNN - Consider bias first (but also variance) in this example\n\n\nSimulate data\nFit models for lm and knn with and without interaction\nTook some shortcuts (no recipe, predict back into train)\n\n\nn &lt;- 200\nset.seed(5433)\n\nd &lt;- tibble(x1 = runif(n, 0,100), # uniform\n               x2 = rep(c(0,1), n/2), # dichotomous\n               x1_x2 = x1*x2, # interaction\n               y = rnorm(n, 0 + 1*x1 + 10*x2 + 10* x1_x2, 20)) #DGP + noise\n\nfit_lm &lt;- \n  linear_reg() |&gt;   \n  set_engine(\"lm\") |&gt;   \n  fit(y ~ x1 + x2, data = d)\n\nfit_lm_int &lt;- \n  linear_reg() |&gt;   \n  set_engine(\"lm\") |&gt;   \n  fit(y ~ x1 + x2 + x1_x2, data = d)\n\nfit_knn &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y ~ x1 + x2, data = d)\n\nfit_knn_int &lt;- \n  nearest_neighbor(neighbors = 20) |&gt;   \n  set_engine(\"kknn\") |&gt;   \n  set_mode(\"regression\") |&gt; \n  fit(y ~ x1 + x2 + x1_x2, data = d)\n\nd &lt;- d |&gt; \n  mutate(pred_lm = predict(fit_lm, d)$.pred,\n         pred_lm_int = predict(fit_lm_int, d)$.pred,\n         pred_knn = predict(fit_knn, d)$.pred,\n         pred_knn_int = predict(fit_knn_int, d)$.pred)\n\n\nPredictions from linear model with and without interaction\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_lm)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"lm without interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_lm_int)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"lm with interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\n\n\nPredictions from linear model with and without interaction\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_knn)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"KNN without interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\nd |&gt; \n  ggplot(aes(x = x1, group = factor(x2), color = factor(x2))) +\n    geom_line(aes(y = pred_knn_int)) +\n    geom_point(aes(y = y)) +\n    ggtitle(\"KNN with interaction\") +\n    ylab(\"y\") +\n    scale_color_discrete(name = \"x2\")\n\n\n\n\n\nWhat are implications of this for when to use flexible algorithm like knn vs. lm?\n\nif data are high dimensional?\nroutine use?\n\n\n\nTransformations of numeric predictors\n\n\nUse of plot_truth() [predicted vs. observed]\nResiduals do not have mean of 0 for every \\(\\hat{y}\\)\n\nConsequence: biased parameter estimates. Linear is bad DGP\nAlso bad test of questions RE the predictor (underestimate? misinform)\n\nNon-normal residuals\n\nConsequence: lm parameter estimates still unbiased (for linear DGP) but more “efficient” solutions exist\nBad for prediction b/c higher variance than other solutions\nMay suggest omission of variables\n\nHeteroscasticity\n\nConsequence: Inefficient and inaccurate standard errors.\nStatistical tests wrong\nPoor prediction for some (where larger variance of resituals) \\(\\hat{y}\\)\nhigher variance overall than other solutions - bad again for prediction\n\nTransformation of outcome?\n\nmetric\nback to raw predictions\n\n\n\nKNN (black box) for explanatory purposes\n\n\nVisualizations (think of interaction plot above) make clear the effect\nWill learn more (better visualizations, variable importance, model comparisons) in later unit\n\n\nExploration\n\n\n“I feel that I can come up with models that decrease the RMSE, but I don’t have good priors on whether adding any particular variable or observation will result in an improved model. I still feel a little weird just adding and dropping variables into a KNN and seeing what gets the validation RMSE the lowest (even though because we’re using validation techniques it’s a fine technique)”\n\nExploration is learning. This is research. If you knew the answer you wouldn’t be doing the study\nDomain knowledge is still VERY important\nSome algorithms (LASSO, glmnet) will help with feature selection\nstaying organized\n\nScript structure\nGood documentation - RMD as analysis notebook\n\nSome overfitting to validation will occur? Consequence? Solutions?\n\n\n\nLM vs. KNN better with predictors or overall\n\n\n“Why do some features seem to improve performance more in linear models or only in KNNs?”\n“What are some contexts where KNN doesn’t work well? In other words, what are the advantages/disadvantages of using KNN?”\n\nAlways comes down to bias vs. variance\nFlexibility and N are key moderators of these two key factors.\n\nk? - impact on bias, variance?\n\n\n\n“In GLM, why correlation/collinearity among predictors will cause larger variance? Is it because of overfitting?”\n“Curse of dimensionality” - Bias vs. variance\n\n\nMissing features produce biased models.\nUnnecessary features or even many features relative to N produce variance\nDoes your available N in your algorithm support the features you need to have low bias.\n\nMostly an empirical question - can’t really tell otherwise outside of simulated data. Validation set is critical!\nFlexible models often need more N holding predictors constant\nRegularization (unit 6) will work well when lots of predictors\n\n\n\n\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2023. An Introduction to Statistical Learning: With Applications in R. 2nd ed. Springer Texts in Statistics. New York: Springer-Verlag."
  },
  {
    "objectID": "003_regression.html#footnotes",
    "href": "003_regression.html#footnotes",
    "title": "3  Introduction to Regression Models",
    "section": "",
    "text": "As you know, the estimation procedure in linear models is OLS. Parameter estimates are derived to minimize the SSE in the data set in which they are derived. For this reason, adding a predictor will never increase RMSE in the training set and it will usually lower it even when it is not part of the DGP. However, this is not true in validation. A predictor will only meaningfully lower RMSE in validation if it is part of the DGP. Also, a bad predictor could even increase RMSE in validation due to overfitting.↩︎\nFor x = 10, find the five observations that have X values closest to 10. Average the Y values for those 5 observations and that is your prediction (\\(\\hat{Y}\\)) associated with that new value of X. Repeat to make predictions for \\(\\hat{Y}\\) for any other value of X, e.g., 50, 90, or any other value↩︎\nSmaller values of \\(k\\) will tend to increase overfitting (and therefore variance across training samples) but decrease bias. Larger values of k will tend to decrease overfitting but increase bias. We need to find the Goldilocks “sweet spot”↩︎\n\\(k\\) = 1 will perfectly fit the training set. Therefore it is very dependent on the training set (high variance). It will fit both the DGP and the noise in the training set. Clearly it will likely not do as well in validation (it will be overfit to training). \\(k\\) needs to be larger if there is more noise (to average over more cases). \\(k\\) needs to be smaller if the relationships are complex. (More on choosing \\(k\\) by resampling in unit 5.↩︎"
  }
]