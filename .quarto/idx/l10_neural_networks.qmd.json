{"title":"Advanced Models: Neural Networks","markdown":{"yaml":{"editor_options":{"chunk_output_type":"console"}},"headingText":"Advanced Models: Neural Networks","containsRefs":false,"markdown":"\n\n::: {.content-visible unless-format=\"revealjs\"}\n:::\n::: {.content-visible when-format=\"revealjs\"}\n# IAML Unit 10:  Advanced Models - Neural Networks\n:::\n\n\n## Learning Objectives\n\n- What are neural networks\n- Types of neural networks\n- Neural network architecture\n  - layers and units\n  - weights and biases\n  - activation functions\n  - cost functions\n  - optimization\n    - epochs\n    - batches\n    - learning rate\n- How to fit 3 layer MLPs in tidymodels using Keras\n\n\n--------------------------------------------------------------------------------\n\n## Introduction to Nerual Networks with Keras in R\n\nWe will be using the `keras` engine to fit our neural networks in R.\n\nThe `keras` [package](https://cran.r-project.org/web/packages/keras/index.html) provides an [R Interface](https://keras.rstudio.com/) to the [Keras API in Python](https://keras.io/).\n\n--------------------------------------------------------------------------------\n\nFrom the website:\n\n- Keras is a high-level neural networks API developed with a focus on **enabling fast experimentation**. Being able to go from idea to result with the least possible delay is key to doing good research. \n\n- Keras has the following key features:\n  - Allows the same code to run on CPU or on GPU, seamlessly.\n  - **User-friendly API** - which makes it easy to quickly prototype deep learning models.\n  - Built-in support for basic multi-layer perceptrons, convolutional networks (for computer vision), recurrent networks (for sequence processing), and any combination of both.\n  - Supports arbitrary network architectures: multi-input or multi-output models, layer sharing, model sharing, etc. This means that Keras is appropriate for building essentially any deep learning model, from a memory network to a neural Turing machine.\n\n--------------------------------------------------------------------------------\n\nKeras is actually a wrapper around an even more extensive open source platform, [TensorFlow](https://www.tensorflow.org/), which has also been ported to the [R environment](https://tensorflow.rstudio.com/)\n\n- TensorFlow is an end-to-end open source platform for machine learning. It has a comprehensive, flexible ecosystem of tools, libraries and community resources that lets researchers push the state-of-the-art in ML and developers easily build and deploy ML powered applications.\n\n- TensorFlow was originally developed by researchers and engineers working on the Google Brain Team within Google's Machine Intelligence research organization for the purposes of conducting machine learning and deep neural networks research\n\n--------------------------------------------------------------------------------\n\nIf you are serious about focusing primarily or exclusively on neural networks, you will probably work directly within Keras in R or Python. However, tidymodels gives us access to 3 layer (single hidden layer) MLP neural networks through the `keras` engine.  This allows us to fit simple (but still powerful) neural networks using all the tools (and code/syntax) that you already know.  Yay! \n\nIf you plan to use Keras directly in R, you might start with this [book](https://www.manning.com/books/deep-learning-with-r?utm_source=google&utm_medium=shopping&utm_campaign=shopping1&gclid=Cj0KCQjwo-aCBhC-ARIsAAkNQivtssXhY1RdFiYXSwu8eRWRXLUqveHkzyhdJU48W-jTU7O-qeKmONsaAmePEALw_wcB).  I've actually found it useful even in thinking about how to interface with Keras through tidymodels.\n\n--------------------------------------------------------------------------------\n\nGetting tidymodels configured to use the `keras` engine can take a  little bit of upfront effort.\n\nWe provide [an appendix](https://jjcurtin.github.io/book_iaml/app_keras.html) to guide you through this process\n\nIf you havent already set this up, please do so immediately so that you can reach out to us for support if you need it\n\nOnce you have completed this one-time installation, you can now use the `keras` engine through tidymodels like any other engine.  No need to do anything different from your normal tidymodeling workflow.\n\n--------------------------------------------------------------------------------\n\nYou should also know that Keras is configured to use GPUs rather than CPU (GPUs allow for highly parallel fitting of neural networks).  \n\n- However, it works fine with just a CPU as well.  \n- It will generate some errors to tell you that you aren't set up with a GPU (and then it will tell you to ignore those error messages). \n- This is an instance where you can ignore the messages!\n\n--------------------------------------------------------------------------------\n\n## Setting up our Environment \n\nNow lets start fresh\n\n- We load our normal environment including source files, parallel  processing and cache support if we plan to use it (code not displayed)\n- keras will work with R without loading it or other packages (beyond what we always load).  However, there will be some function conflicts.\n  - So we will load keras and exclude the conflict\n  - We also need to load magrittr and exclude two of its conflicting functions\n  \n```{r}\n#| include: false\n\n# set up environment.  Now hidden from view\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\noptions(conflicts.policy = \"depends.ok\")\n\nlibrary(xfun, include.only = \"cache_rds\")\n\ncl <- parallel::makePSOCKcluster(parallel::detectCores(logical = FALSE))\ndoParallel::registerDoParallel(cl)\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\npath_data <- \"./data\"\n\nrerun_setting <- FALSE \n``` \n\n```{r}\nlibrary(keras, exclude = \"get_weights\")\nlibrary(magrittr, exclude = c(\"set_names\", \"extract\"))\n```\n\n--------------------------------------------------------------------------------\n\n## The MNIST dataset\n\nThe [MNIST database](https://en.wikipedia.org/wiki/MNIST_database) (Modified National Institute of Standards and Technology database) is a large database of handwritten digits that is commonly used for training and testing in the field of machine learning.\n\nIt consists of two sets: \n\n  - There are 60,000 images from 250 people in train\n  - There are 10,000 images from a different 250 people in test (from different people than in train)\n\n--------------------------------------------------------------------------------\n\nEach observation in the datasets represent a single image and its label\n\n- Each image is a 28 X 28 grid of pixels = 784 predictors (x1 - x784)\n- Each label is the actual value (0-9; y).  We will treat it as categorical because we are trying to identify each number \"category\", predicting a label of \"4\" when the image is a \"5\" is just as bad as predicting \"9\"\n\n--------------------------------------------------------------------------------\n\nLet's start by reading train and test sets\n```{r}\ndata_trn <- read_csv(here::here(path_data, \"mnist_train.csv.gz\"),\n                     col_types = cols()) |> \n  mutate(y = factor(y, levels = 0:9, labels = 0:9))\ndata_trn |> dim()\n\ndata_test <- read_csv(here::here(path_data, \"mnist_test.csv\"),\n                      col_types = cols()) |> \n    mutate(y = factor(y, levels = 0:9, labels = 0:9))\ndata_test |> dim()\n```\n\n--------------------------------------------------------------------------------\n\nHere is some very basic info on the outcome distribution \n\n- in train\n```{r}\ndata_trn |> tab(y)\n```\n\n```{r}\n#| out-height: 3in\n\ndata_trn |> plot_bar(\"y\")\n```\n\n--------------------------------------------------------------------------------\n\n- in test\n```{r}\ndata_test|> tab(y)\n```\n\n```{r}\n#| out-height: 3in\n\ndata_test |> plot_bar(\"y\")\n\n```\n\n--------------------------------------------------------------------------------\n\nLet's look at some of the images.  We will need a function to display these images.  We will use `as.cimg()` from the `imager` package\n```{r}\ndisplay_image <- function(data){\n  message(\"Displaying: \", data$y)\n  \n  data |> \n    select(-y) |> \n    unlist(use.names = FALSE) |> \n    imager::as.cimg(x = 28, y = 28) |> \n    plot(axes = FALSE)\n}\n```\n\n--------------------------------------------------------------------------------\n\nObservations 1, 3, 10, and 100 in training set\n```{r}\ndata_trn |> \n  slice(1) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\ndata_trn |> \n  slice(3) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\ndata_trn |> \n  slice(10) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\ndata_trn |> \n  slice(100) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\nAnd here is the first observation in test set\n```{r}\ndata_test |> \n  slice(1) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\nLet's understand the individual predictors a bit more\n\n- Each predictor is a pixel in the 28 X 28 grid for the image\n- Pixel intensity is coded for intensity in the range from 0 (black)\nto 255 (white)\n- First 28 variables are the top row of 28 pixels\n- Next 28 variables are the second row of 28 pixels\n- There are 28 rows of 28 predictors total (784 predictors)\n\n--------------------------------------------------------------------------------\n\n- Lets understand this by changing values for  individual predictors\n- Here is the third image again\n\n[What will happen to the image if I change the value of predictor `x25` to 255]{.red}\n\n```{r}\ndata_trn |> \n  slice(3) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n- Change the `x25` to 255\n\n```{r}\ndata_trn |> \n  slice(3) |>\n  mutate(x25 = 255) |> \n  display_image()\n```\n\n[What will happen to the image if I change the value of predictor `x29` to 255]{.uwred}\n\n--------------------------------------------------------------------------------\n\n- Change the `x29` to 255\n```{r u11-mnist-12}\ndata_trn |> \n  slice(3) |>\n  mutate(x29 = 255) |> \n  display_image()\n```\n\n[What will happen to the image if I change the value of predictor `x784` to 255]{.uwred}\n\n--------------------------------------------------------------------------------\n\n- Change the `x784` to 255\n```{r u11-mnist-13}\ndata_trn |> \n  slice(3) |>\n  mutate(x784 = 255) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n## Fitting Neural Networks\n\nLet's train some models to understand some basics about neural networks and the use of\nKeras within tidymodels\n\n- We will fit some configurations in the full training set and evaluate their performance in test\n\n- We are NOT using test to select among configurations (it wouldn't be a true test set then)\nbut only for instructional purposes.\n\n- We will start with an absolute minimal recipe and mostly defaults for the statistical\nalgorithm\n\n- We will build up to more complex (and better) configurations\n\n- We will end with a demonstration of the use of the single validation set approach to select among model configurations\n\n--------------------------------------------------------------------------------\n\nLet's start with a minimal recipe\n\n- 10 level categorical outcome as factor\n- Will be used to establish 10 output neurons\n```{r}\nrec_min <- \n  recipe(y ~ ., data = data_trn)\n```\n\n--------------------------------------------------------------------------------\n\nHere are feature matrices for train and test using this recipe\n\n```{r}\nrec_min_prep <- rec_min |> \n  prep(data_trn)\n\nfeat_trn <- rec_min_prep |> \n  bake(NULL)\n\nfeat_test <-rec_min_prep |> \n  bake(data_test)\n```\n\n--------------------------------------------------------------------------------\n\nAnd let's use a mostly out of the box (defaults) 3 layer (1 hidden layer) using Keras engine\n\nDefaults:\n\n- hidden units = 5\n- penalty = 0\n- dropout = 0\n- activation = \"softmax\" for hidden units layer\n- epochs = 20\n- seeds = sample.int(10^5, size = 3)\n\n--------------------------------------------------------------------------------\n\nThe default activation for the hidden units when using Keras through tidymodels is `softmax` not sigmoid as per the basic models discussed in the book and lectures.\n\n- The activation for the output layer will always be `softmax` for classification problems when using Keras through tidymodels\n  - This is likely a good choice\n  - It provides scores that function like probabilities for each categorical response\n- The activation for the output layer will always be 'linear' for regression problems.  \n  - Also a generally good choice\n- The hidden units can have a variety of different activation functions\n  - `linear`, `softmax`, `relu`, and `elu` through tidymodels\n  - Additional activation functions (and many other \"dials\") are available in Keras directly\n\n--------------------------------------------------------------------------------\n\nWe will adjust `seeds` from the start\n\nThere are a number of points in the fitting process where random numbers needed by Keras\n\n- initializing weights for hidden and output layers\n- selecting units for `dropout`\n- selecting batches within epochs\n\n`tidymodels` lets us provide three seeds to make the first two bullet points more reproducible.  \n\nThere seems to still be some randomness across runs due to batch selection (and possibly other opaque steps)\n\n```{r}\nset.seed(1234567)\nfit_seeds <- sample.int(10^5, size = 3)  # c(87591, 536, 27860)\n```\n\n--------------------------------------------------------------------------------\n\nWe will also set verbose = 0 for now\n\n- This turns off messages and plots about epoch level performance\n- At this point, verbose would only report performance in the training data, which isn't that informative\n- We will turn it on later when we learn how to get performance in a validation set\n- Nonetheless, you might still turn it on if you just want feedback on how long it will take for the fit to complete.\n\n--------------------------------------------------------------------------------\n\nLet's fit this first model configuration in training set\n\n- `verbose = 0`\n- `seeds = fit_seeds`\n```{r}\n#| label: fit_1\n\nfit_1 <-\n    mlp() |>\n    set_mode(\"classification\") |> \n    set_engine(\"keras\", \n               verbose = 0, \n               seeds = fit_seeds) |>\n    fit(y ~ ., data = feat_trn)\n```\n\nNOTE: The first model fit with Keras in each new session will generate those warnings/errors about GPU. You can ignore them.\n\n--------------------------------------------------------------------------------\n\nHere is this model's performance in test\n\nIt's not that great ([What would you expect by chance?]{.red})\n```{r}\naccuracy_vec(feat_test$y, predict(fit_1, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\nTheoretically, the scale of the inputs should not matter\n\nHOWEVER, gradient descent works better with inputs on the same scale\n\nWe will also want inputs with the same variance if we later apply L2 regularization to our models\n\n- There is a lot of discussion about how best to scale inputs\n- Best if the input means are near zero\n- Best if variances are comparable\n\n--------------------------------------------------------------------------------\n\nWe could:\n\n- Use `step_normalize()`  [Bad choice of function names by tidymodel folks; standardize vs. normalize]\n- Use `step_range()`\n- Book range corrected based on known true range (`/ 255`)\n\nWe will use `step_normalize()`\n\n--------------------------------------------------------------------------------\n\n```{r}\nrec_scaled_wrong <- \n  recipe(y ~ ., data = data_trn) |>\n  step_normalize(all_predictors())\n```\n\nThis is wrong! Luckily we glimpsed our feature matrix (not displayed here)\n\n::: {.callout-important}\n# Question: What went wrong and what should we do?\n:::\n\n::: {.fragment .uwred}\nMany of the features have zero variance b/c they are black for ALL of the  images (e.g., top rows of pixels.  We can not scale a predictor with zero variance  b/c when we divide by the SD = 0, we get NaN).  At a minimum, we should remove  zero variance predictors in training from training and test\n:::\n\n--------------------------------------------------------------------------------\n\nFor example\n```{r}\ndata_trn$x1 |> sd()\n```\n\n--------------------------------------------------------------------------------\n\nLet's remove zero variance predictors before we scale\n\n- To be clear, zero variance features are NOT a problem for neural networks (though clearly they won't help either).\n- But they WILL definitely cause problems for some scaling transformations.\n```{r}\nrec_scaled <- \n  recipe(y ~ ., data = data_trn) |>\n  step_zv(all_predictors()) |> \n  step_normalize(all_predictors())\n```\n\n--------------------------------------------------------------------------------\n\nWe now have 717 (+ y) features rather than 28 * 28 = 784 features\n\n```{r}\nrec_scaled_prep <- rec_scaled |> \n  prep(data_trn)\n\nfeat_trn <- rec_scaled_prep |> \n  bake(NULL)\n\ndim(feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\nLet's also make the feature matrix for test.  This will exclude features that were zero variance in **train** and scale them by their mean and sd in **train**\n\n```{r}\nfeat_test <- rec_scaled_prep |> \n  bake(data_test)\n\ndim(feat_test)\n```\n\n--------------------------------------------------------------------------------\n\nLet's fit and evaluate this new feature set with no other changes to the model configuration\n\n```{r}\n#| label: fit_2\n\nfit_2 <-\n  mlp() |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n\n- That helped a LOT\n- Still could be better though (but it always impresses me! ;-)\n```{r}\naccuracy_vec(feat_test$y, predict(fit_2, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\nThere are many other recommendations about feature engineering to improve the inputs\n\nThese include:\n\n- Normalize (and here I mean true normalization; e.g., `step_BoxCox()`, `step_YeoJohnson()`)\n- De-correlate (e.g., `step_pca()` but retain all features?)\n\nYou can see some discussion of these issues [here](https://machinelearningmastery.com/how-to-improve-neural-network-stability-and-modeling-performance-with-data-scaling/#:~:text=Scaling%20input%20and%20output%20variables,is%20presented%20to%20a%20network) and [here](https://stats.stackexchange.com/questions/7757/data-normalization-and-standardization-in-neural-networks) to get you started.  The [paper](http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf) linked in the stack overflow response is also a useful starting point.\n\n--------------------------------------------------------------------------------\n\nSome **preliminary** modeling EDA on my part suggested these additional considerations didn't have major impact on the performance of our models with this dataset so we will stick with just scaling the features.\n\n--------------------------------------------------------------------------------\n\nIt is not surprising that a model configuration with only one hidden layer and 5 units isn't sufficient for this complex task\n\nLet's try 30 units (cheating based on the book chapter!! ;-)\n\n```{r}\n#| label: fit_5units\n\nfit_5units <- mlp(hidden_units = 30) |>\n    set_mode(\"classification\") |> \n    set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n    fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n- Bingo!  Much, much better!\n- We could see if even more units works better still but I won't follow that through here for sake of simplicity\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_5units, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\nThe Three Blue 1 Brown videos had a brief discussion of the [relu activation function](https://machinelearningmastery.com/rectified-linear-activation-function-for-deep-learning-neural-networks/).\n\nLet's see how to use other activation functions and if this one helps.\n```{r}\n#| label: fit_relu\n\nfit_relu <- mlp(hidden_units = 30, activation = \"relu\") |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_relu, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n## Dealing with Overfitting\n\nAs you might imagine, given the number of weights to be fit in even a modest neural network\n(our 30 hidden unit network has 21,850 parameters to estimate), it is easy to become overfit\n\n- 21,540 for hidden layer (717 * 30 weight + 30 biases)\n- 310 for output layer (30 * 10 weights, + 10 biases)\n```{r}\nfit_relu\n```\n\nThis will be an even bigger problem if you aren't using \"big\" data\n\n--------------------------------------------------------------------------------\n\nThere are a number of different methods available to reduce potential overfitting\n\n- Simplify the network architecture (fewer units, fewer layers)\n- L2 regularization \n- Dropout\n- Early stopping or monitoring validation error to prevent too many epochs\n\n--------------------------------------------------------------------------------\n\n### Regularization or Weight Decay\n\nL2 regularization is implemented in essentially the same fashion as you have seen \nit previously (e.g., glmnet)\n\nThe cost function is expanded to include a penalty based on the sum of the squared weights multiplied by $\\lambda$.  \n\nIn the tidymodels implementation of Keras:\n\n- $\\lambda$ is called `penalty` and is set and/or (ideally) tuned via the \n`penalty` argument in `mlp()`\n\n- Common values for the L2 `penalty` to tune a neural network are often on a logarithmic scale between 0 and 0.1, such as 0.1, 0.001, 0.0001, etc.\n\n- `penalty = 0` (the default) means no L2 regularization\n\n- Keras implements other penalties (L1, and a mixture) but not currently through tidymodels\n\n- [Here](https://machinelearningmastery.com/how-to-reduce-overfitting-in-deep-learning-with-weight-regularization/) is a starting point for more reading on regularization in neural networks\n\n--------------------------------------------------------------------------------\n\nLet's set `penalty = .0001`.   \n\n```{r}\n#| label: fit_penalty\n\nfit_penalty <- mlp(hidden_units = 30, activation = \"relu\", penalty = .0001) |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n- Looks like there is not much benefit to regularization for this network.  \n- Would likely provide much greater benefit in smaller N contexts or with more complicated model architectures (more hidden units, more hidden unit layers).\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_penalty, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n### Dropout\n\nDropout is a second technique to minimize overfitting.\n\nHere is a clear description of dropout from a blog post on the Machine Learning Mastery: \n\n- Dropout is a technique where randomly selected neurons are ignored during training. They are “dropped-out” randomly. This means that their contribution to the activation of downstream neurons is temporally removed on the forward pass and any weight updates are not applied to the neuron on the backward pass.\n\n- As a neural network learns, neuron weights settle into their context within the network. Weights of neurons are tuned for specific features providing some specialization. Neighboring neurons come to rely on this specialization, which if taken too far can result in a fragile model too specialized to the training data. \n\n- You can imagine that if neurons are randomly dropped out of the network during training, that other neurons will have to step in and handle the representation required to make predictions for the missing neurons. This is believed to result in multiple independent internal representations being learned by the network.\n\n- The effect is that the network becomes less sensitive to the specific weights of neurons. This in turn results in a network that is capable of better generalization and is less likely to overfit the training data.\n\n--------------------------------------------------------------------------------\n\nFor further reading, you might start with the 2014 paper by [Srivastava, et al](https://jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf) that proposed the technique.\n\nIn tidymodels, you can set or tune the amount of dropout via the `dropout` argument in `mlp()`\n\n- Srivastava, et al suggest starting with values around .5.  \n- You might consider a range between .1 and .5\n- `droppout = 0` (the default) means no dropout\n- In tidymodels implementation of Keras, you can use a non-zero `penalty` or `dropout` but not both\n\n--------------------------------------------------------------------------------\n\nLet's try `dropout = .1`.  \n\n```{r}\n#| label: fit_dropout\n\nfit_dropout <- mlp(hidden_units = 30, activation = \"relu\", dropout = .1) |>\n  set_mode(\"classification\") |>  \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n- Looks like there may be a little benefit but not substantial.  \n- Would likely provide much greater benefit in smaller N contexts or with more complicated model architectures (more hidden units, more hidden unit layers).\n```{r}\naccuracy_vec(feat_test$y, predict(fit_dropout, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n### Number of Epochs and Early Stopping\n\nNow that we have a model that is working well, lets return to the issue of number of epochs\n\n- Too many epochs can lead to overfitting\n- Too many epochs also just slow things down (not a bit deal if using GPU or overnight but still.....)\n- Too few epochs can lead to under-fitting (which also produces poor performance)\n- The default of `epochs = 20` is a reasonable starting point for a network with one hidden layer but may not work for all situations\n\n--------------------------------------------------------------------------------\n\nMonitoring training error (loss, accuracy) is not ideal b/c it will tend to always decrease\n\n- This is what you would get if you set `verbose = 1`\n\nValidation error is what you need to monitor\n\n- Validation error will increase when the model becomes overfit to training\n- We can have Keras hold back some portion of the training data for validation\n  - `validation_split = 1/6`\n  - We pass it in as an optional argument in `set_engine()`\n  - We can use this to monitor validation error rather than training error by epoch. \n  - You can fit an exploratory model with `epochs = 50` to review the plot\n  - This can allow us to determine an appropriate value for `epochs`\n \n--------------------------------------------------------------------------------\n\nLet's see this in action in the best model configuration without regularization or dropout\n\nNOTE:\n\n- `epochs = 50`\n- `verbose = 1`\n- `metrics = c(\"accuracy\")`\n- `validation_split = 1/6`\n- You will see message updates and a plot that tracks training and validation loss and accuracy across epochs\n- This is not rendered into my slides but the plot and messages are pretty clear\n- You can use this information to choose appropriate values for `epoch`\n- `val_accuracy` had plateau and `val_loss` had started to creep up by 10 epochs.\n\n```{r}\n#| label: fit_epochs50\n#| message: false\n#| output: false\n\nfit_epochs50 <- mlp(hidden_units = 30, activation = \"relu\", epochs = 50) |>\n  set_mode(\"classification\") |>  \n  set_engine(\"keras\", verbose = 1, seeds = fit_seeds, \n             metrics = c(\"accuracy\"), \n             validation_split = 1/6) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\nIn some instances, it may be that we want to do more than simply look at epoch performance plots during modeling EDA\n\nWe can instead set the number of epochs to be high but use an early stopping callback to end \nthe training early at an optimal time\n\n--------------------------------------------------------------------------------\n\nCallbacks allow us to interrupt training.   \n\n- There are many types of callbacks in Keras\n- We will only discuss `callback_early_stopping()`\n- We set up callbacks in a list\n- We pass them in as an optional argument in `set_engine()` using `callbacks = `\n- Notice the arguments for `callback_early_stopping()`\n- We also must provide validation error.  Here we set `validation_split = 1/6`\n- This is a method to **tune or select** best number of epochs.  \n  - I haven't yet figured out where the epochs at termination are saved so need to watch the feedback.  It was 35 epochs here\n  - As always, we **could** next refit to the full training set after we have determined the optimal number of epochs.  We won't do that here.\n\n--------------------------------------------------------------------------------\n\nThis fit stopped at 15 epochs\n\n```{r}\ncallback_list <- list(keras::callback_early_stopping(monitor = \"val_loss\", \n                                                     min_delta = 0, \n                                                     patience = 10))\n```\n\n```{r}\n#| label: fit_early\n#| message: false\n#| output: false\n\nfit_early <- mlp(hidden_units = 30, activation = \"relu\", epochs = 200) |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 1,\n             seeds = fit_seeds, \n             metrics = c(\"accuracy\" ), \n             validation_split = 1/6,\n             callbacks = callback_list) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_early, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n**Coding sidebar:** You can see many of the optional arguments you can set for Keras in the help [here](https://keras.rstudio.com/reference/fit.html).   \n\nAnd you can see more info about `callback_early_stopping()` [here](https://keras.rstudio.com/reference/callback_early_stopping.html)\n\n--------------------------------------------------------------------------------\n\n## Using Resampling to Select Best Model Configuration\n\nDeveloping a good network artchitecture and considering feature enginnering options involves experimentation\n  \n- This is what Keras is designed to do\n- tidymodels allows this too\n- We need to evaluate configurations with a valid method to evaluate performance\n  - validation split metric\n  - k-fold metric\n  - bootstrap method\n  - Each can be paired with `fit_resamples()` or `tune_grid()`\n- We need to be systematic\n  - `tune_grid()` helps with this too\n  - recipes can be tuned as well (outside the scope of this course)\n\n--------------------------------------------------------------------------------\n\nHere is an example where we can select among many model configurations that differ across multiple network characteristics\n\n- Evaluate with validation split accuracy \n- Sample size is relatively big so we have 10,000 validation set observations.  Should offer a low variance performance estimate\n- K-fold and bootstrap would still be better but big computation costs (too big for this web book but could be done in real life!)\n\n--------------------------------------------------------------------------------\n\nIts really just our normal workflow at this point\n\n- Get splits (validation splits in this example)\n```{r}\nset.seed(102030)\nsplits_validation <-\n  data_trn |> \n  validation_split(prop = 5/6)\n```\n\n--------------------------------------------------------------------------------\n\n- Set up grid of hyperparameter values\n```{r}\ngrid_keras <- expand_grid(hidden_units = c(5, 10, 20, 30, 50, 100), \n                          penalty = c(.00001, .0001, .01, .1))\n```\n\n--------------------------------------------------------------------------------\n\n- Use `tune_grid()` to fit models in training and predict into validation set for each combination of hyperparameter values\n```{r}\n#| label: fits_nn\n\nfits_nn <- cache_rds(\n  expr = {\n    mlp(hidden_units = tune(), penalty = tune(), activation = \"relu\") |>\n    set_mode(\"classification\") |> \n    # setting to verbose = 1 to track progress.  Training error not that useful\n    set_engine(\"keras\", verbose = 1, seeds = fit_seeds) |>  \n    tune_grid(preprocessor = rec_scaled, \n                  grid = grid_keras,\n                  resamples = splits_validation,\n                  metrics = metric_set(accuracy))\n  },\n  rerun = rerun_setting,\n  dir = \"cache/010/\",\n  file = \"fits_nn\")\n```\n\n--------------------------------------------------------------------------------\n\n- Find model configuration with best performance in the held-out validation set\n```{r}\nshow_best(fits_nn)\n```\n\n--------------------------------------------------------------------------------\n\n## Other Details\n\nWe can get a better sense of how tidymodels is interacting with Keras by looking at the function that is called\n\n```{r}\nmlp(hidden_units = 30, activation = \"relu\", dropout = .1) |>\n  set_mode(\"classification\") |>  \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |> \n  translate()\n```\n\n--------------------------------------------------------------------------------\n\n`keras_mlp()` is a wrapper around the calls to Keras.  Lets see what it does\n```{r}\nkeras_mlp\n```\n\nWe can see:\n\n- How the activation functions are setup\n- The choice of cost function: mse or binary_crossentropy\n- The optimizer: Adam\n- How the three seeds are being used\n\n--------------------------------------------------------------------------------\n\nFinally, you might  have noticed that we never set a learning rate anywhere\n\nThe [Adam optimizer](pdfs/kingma_adam_optimizer.pdf) is used instead of classic stochastic gradient descent.  The authors of this optimizer state it is:\n\n- Straightforward to implement.\n- Computationally efficient.\n- Little memory requirements.\n- Invariant to diagonal rescale of the gradients.\n- Well suited for problems that are large in terms of data and/or parameters.\n- Appropriate for non-stationary objectives.\n- Appropriate for problems with very noisy/or sparse gradients.\n- Hyper-parameters have intuitive interpretation and typically require little tuning.\n\n--------------------------------------------------------------------------------\n\nYou can start additional reading about Adam [here](https://machinelearningmastery.com/adam-optimization-algorithm-for-deep-learning/#:~:text=Adam%20is%20a%20replacement%20optimization,sparse%20gradients%20on%20noisy%20problems)\n\nFor now, if you want another optimizer or much more control over your network architecture, you may need to work directly in Keras.","srcMarkdownNoYaml":"\n\n::: {.content-visible unless-format=\"revealjs\"}\n# Advanced Models: Neural Networks\n:::\n::: {.content-visible when-format=\"revealjs\"}\n# IAML Unit 10:  Advanced Models - Neural Networks\n:::\n\n\n## Learning Objectives\n\n- What are neural networks\n- Types of neural networks\n- Neural network architecture\n  - layers and units\n  - weights and biases\n  - activation functions\n  - cost functions\n  - optimization\n    - epochs\n    - batches\n    - learning rate\n- How to fit 3 layer MLPs in tidymodels using Keras\n\n\n--------------------------------------------------------------------------------\n\n## Introduction to Nerual Networks with Keras in R\n\nWe will be using the `keras` engine to fit our neural networks in R.\n\nThe `keras` [package](https://cran.r-project.org/web/packages/keras/index.html) provides an [R Interface](https://keras.rstudio.com/) to the [Keras API in Python](https://keras.io/).\n\n--------------------------------------------------------------------------------\n\nFrom the website:\n\n- Keras is a high-level neural networks API developed with a focus on **enabling fast experimentation**. Being able to go from idea to result with the least possible delay is key to doing good research. \n\n- Keras has the following key features:\n  - Allows the same code to run on CPU or on GPU, seamlessly.\n  - **User-friendly API** - which makes it easy to quickly prototype deep learning models.\n  - Built-in support for basic multi-layer perceptrons, convolutional networks (for computer vision), recurrent networks (for sequence processing), and any combination of both.\n  - Supports arbitrary network architectures: multi-input or multi-output models, layer sharing, model sharing, etc. This means that Keras is appropriate for building essentially any deep learning model, from a memory network to a neural Turing machine.\n\n--------------------------------------------------------------------------------\n\nKeras is actually a wrapper around an even more extensive open source platform, [TensorFlow](https://www.tensorflow.org/), which has also been ported to the [R environment](https://tensorflow.rstudio.com/)\n\n- TensorFlow is an end-to-end open source platform for machine learning. It has a comprehensive, flexible ecosystem of tools, libraries and community resources that lets researchers push the state-of-the-art in ML and developers easily build and deploy ML powered applications.\n\n- TensorFlow was originally developed by researchers and engineers working on the Google Brain Team within Google's Machine Intelligence research organization for the purposes of conducting machine learning and deep neural networks research\n\n--------------------------------------------------------------------------------\n\nIf you are serious about focusing primarily or exclusively on neural networks, you will probably work directly within Keras in R or Python. However, tidymodels gives us access to 3 layer (single hidden layer) MLP neural networks through the `keras` engine.  This allows us to fit simple (but still powerful) neural networks using all the tools (and code/syntax) that you already know.  Yay! \n\nIf you plan to use Keras directly in R, you might start with this [book](https://www.manning.com/books/deep-learning-with-r?utm_source=google&utm_medium=shopping&utm_campaign=shopping1&gclid=Cj0KCQjwo-aCBhC-ARIsAAkNQivtssXhY1RdFiYXSwu8eRWRXLUqveHkzyhdJU48W-jTU7O-qeKmONsaAmePEALw_wcB).  I've actually found it useful even in thinking about how to interface with Keras through tidymodels.\n\n--------------------------------------------------------------------------------\n\nGetting tidymodels configured to use the `keras` engine can take a  little bit of upfront effort.\n\nWe provide [an appendix](https://jjcurtin.github.io/book_iaml/app_keras.html) to guide you through this process\n\nIf you havent already set this up, please do so immediately so that you can reach out to us for support if you need it\n\nOnce you have completed this one-time installation, you can now use the `keras` engine through tidymodels like any other engine.  No need to do anything different from your normal tidymodeling workflow.\n\n--------------------------------------------------------------------------------\n\nYou should also know that Keras is configured to use GPUs rather than CPU (GPUs allow for highly parallel fitting of neural networks).  \n\n- However, it works fine with just a CPU as well.  \n- It will generate some errors to tell you that you aren't set up with a GPU (and then it will tell you to ignore those error messages). \n- This is an instance where you can ignore the messages!\n\n--------------------------------------------------------------------------------\n\n## Setting up our Environment \n\nNow lets start fresh\n\n- We load our normal environment including source files, parallel  processing and cache support if we plan to use it (code not displayed)\n- keras will work with R without loading it or other packages (beyond what we always load).  However, there will be some function conflicts.\n  - So we will load keras and exclude the conflict\n  - We also need to load magrittr and exclude two of its conflicting functions\n  \n```{r}\n#| include: false\n\n# set up environment.  Now hidden from view\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\noptions(conflicts.policy = \"depends.ok\")\n\nlibrary(xfun, include.only = \"cache_rds\")\n\ncl <- parallel::makePSOCKcluster(parallel::detectCores(logical = FALSE))\ndoParallel::registerDoParallel(cl)\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\npath_data <- \"./data\"\n\nrerun_setting <- FALSE \n``` \n\n```{r}\nlibrary(keras, exclude = \"get_weights\")\nlibrary(magrittr, exclude = c(\"set_names\", \"extract\"))\n```\n\n--------------------------------------------------------------------------------\n\n## The MNIST dataset\n\nThe [MNIST database](https://en.wikipedia.org/wiki/MNIST_database) (Modified National Institute of Standards and Technology database) is a large database of handwritten digits that is commonly used for training and testing in the field of machine learning.\n\nIt consists of two sets: \n\n  - There are 60,000 images from 250 people in train\n  - There are 10,000 images from a different 250 people in test (from different people than in train)\n\n--------------------------------------------------------------------------------\n\nEach observation in the datasets represent a single image and its label\n\n- Each image is a 28 X 28 grid of pixels = 784 predictors (x1 - x784)\n- Each label is the actual value (0-9; y).  We will treat it as categorical because we are trying to identify each number \"category\", predicting a label of \"4\" when the image is a \"5\" is just as bad as predicting \"9\"\n\n--------------------------------------------------------------------------------\n\nLet's start by reading train and test sets\n```{r}\ndata_trn <- read_csv(here::here(path_data, \"mnist_train.csv.gz\"),\n                     col_types = cols()) |> \n  mutate(y = factor(y, levels = 0:9, labels = 0:9))\ndata_trn |> dim()\n\ndata_test <- read_csv(here::here(path_data, \"mnist_test.csv\"),\n                      col_types = cols()) |> \n    mutate(y = factor(y, levels = 0:9, labels = 0:9))\ndata_test |> dim()\n```\n\n--------------------------------------------------------------------------------\n\nHere is some very basic info on the outcome distribution \n\n- in train\n```{r}\ndata_trn |> tab(y)\n```\n\n```{r}\n#| out-height: 3in\n\ndata_trn |> plot_bar(\"y\")\n```\n\n--------------------------------------------------------------------------------\n\n- in test\n```{r}\ndata_test|> tab(y)\n```\n\n```{r}\n#| out-height: 3in\n\ndata_test |> plot_bar(\"y\")\n\n```\n\n--------------------------------------------------------------------------------\n\nLet's look at some of the images.  We will need a function to display these images.  We will use `as.cimg()` from the `imager` package\n```{r}\ndisplay_image <- function(data){\n  message(\"Displaying: \", data$y)\n  \n  data |> \n    select(-y) |> \n    unlist(use.names = FALSE) |> \n    imager::as.cimg(x = 28, y = 28) |> \n    plot(axes = FALSE)\n}\n```\n\n--------------------------------------------------------------------------------\n\nObservations 1, 3, 10, and 100 in training set\n```{r}\ndata_trn |> \n  slice(1) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\ndata_trn |> \n  slice(3) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\ndata_trn |> \n  slice(10) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\ndata_trn |> \n  slice(100) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\nAnd here is the first observation in test set\n```{r}\ndata_test |> \n  slice(1) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\nLet's understand the individual predictors a bit more\n\n- Each predictor is a pixel in the 28 X 28 grid for the image\n- Pixel intensity is coded for intensity in the range from 0 (black)\nto 255 (white)\n- First 28 variables are the top row of 28 pixels\n- Next 28 variables are the second row of 28 pixels\n- There are 28 rows of 28 predictors total (784 predictors)\n\n--------------------------------------------------------------------------------\n\n- Lets understand this by changing values for  individual predictors\n- Here is the third image again\n\n[What will happen to the image if I change the value of predictor `x25` to 255]{.red}\n\n```{r}\ndata_trn |> \n  slice(3) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n- Change the `x25` to 255\n\n```{r}\ndata_trn |> \n  slice(3) |>\n  mutate(x25 = 255) |> \n  display_image()\n```\n\n[What will happen to the image if I change the value of predictor `x29` to 255]{.uwred}\n\n--------------------------------------------------------------------------------\n\n- Change the `x29` to 255\n```{r u11-mnist-12}\ndata_trn |> \n  slice(3) |>\n  mutate(x29 = 255) |> \n  display_image()\n```\n\n[What will happen to the image if I change the value of predictor `x784` to 255]{.uwred}\n\n--------------------------------------------------------------------------------\n\n- Change the `x784` to 255\n```{r u11-mnist-13}\ndata_trn |> \n  slice(3) |>\n  mutate(x784 = 255) |> \n  display_image()\n```\n\n--------------------------------------------------------------------------------\n\n## Fitting Neural Networks\n\nLet's train some models to understand some basics about neural networks and the use of\nKeras within tidymodels\n\n- We will fit some configurations in the full training set and evaluate their performance in test\n\n- We are NOT using test to select among configurations (it wouldn't be a true test set then)\nbut only for instructional purposes.\n\n- We will start with an absolute minimal recipe and mostly defaults for the statistical\nalgorithm\n\n- We will build up to more complex (and better) configurations\n\n- We will end with a demonstration of the use of the single validation set approach to select among model configurations\n\n--------------------------------------------------------------------------------\n\nLet's start with a minimal recipe\n\n- 10 level categorical outcome as factor\n- Will be used to establish 10 output neurons\n```{r}\nrec_min <- \n  recipe(y ~ ., data = data_trn)\n```\n\n--------------------------------------------------------------------------------\n\nHere are feature matrices for train and test using this recipe\n\n```{r}\nrec_min_prep <- rec_min |> \n  prep(data_trn)\n\nfeat_trn <- rec_min_prep |> \n  bake(NULL)\n\nfeat_test <-rec_min_prep |> \n  bake(data_test)\n```\n\n--------------------------------------------------------------------------------\n\nAnd let's use a mostly out of the box (defaults) 3 layer (1 hidden layer) using Keras engine\n\nDefaults:\n\n- hidden units = 5\n- penalty = 0\n- dropout = 0\n- activation = \"softmax\" for hidden units layer\n- epochs = 20\n- seeds = sample.int(10^5, size = 3)\n\n--------------------------------------------------------------------------------\n\nThe default activation for the hidden units when using Keras through tidymodels is `softmax` not sigmoid as per the basic models discussed in the book and lectures.\n\n- The activation for the output layer will always be `softmax` for classification problems when using Keras through tidymodels\n  - This is likely a good choice\n  - It provides scores that function like probabilities for each categorical response\n- The activation for the output layer will always be 'linear' for regression problems.  \n  - Also a generally good choice\n- The hidden units can have a variety of different activation functions\n  - `linear`, `softmax`, `relu`, and `elu` through tidymodels\n  - Additional activation functions (and many other \"dials\") are available in Keras directly\n\n--------------------------------------------------------------------------------\n\nWe will adjust `seeds` from the start\n\nThere are a number of points in the fitting process where random numbers needed by Keras\n\n- initializing weights for hidden and output layers\n- selecting units for `dropout`\n- selecting batches within epochs\n\n`tidymodels` lets us provide three seeds to make the first two bullet points more reproducible.  \n\nThere seems to still be some randomness across runs due to batch selection (and possibly other opaque steps)\n\n```{r}\nset.seed(1234567)\nfit_seeds <- sample.int(10^5, size = 3)  # c(87591, 536, 27860)\n```\n\n--------------------------------------------------------------------------------\n\nWe will also set verbose = 0 for now\n\n- This turns off messages and plots about epoch level performance\n- At this point, verbose would only report performance in the training data, which isn't that informative\n- We will turn it on later when we learn how to get performance in a validation set\n- Nonetheless, you might still turn it on if you just want feedback on how long it will take for the fit to complete.\n\n--------------------------------------------------------------------------------\n\nLet's fit this first model configuration in training set\n\n- `verbose = 0`\n- `seeds = fit_seeds`\n```{r}\n#| label: fit_1\n\nfit_1 <-\n    mlp() |>\n    set_mode(\"classification\") |> \n    set_engine(\"keras\", \n               verbose = 0, \n               seeds = fit_seeds) |>\n    fit(y ~ ., data = feat_trn)\n```\n\nNOTE: The first model fit with Keras in each new session will generate those warnings/errors about GPU. You can ignore them.\n\n--------------------------------------------------------------------------------\n\nHere is this model's performance in test\n\nIt's not that great ([What would you expect by chance?]{.red})\n```{r}\naccuracy_vec(feat_test$y, predict(fit_1, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\nTheoretically, the scale of the inputs should not matter\n\nHOWEVER, gradient descent works better with inputs on the same scale\n\nWe will also want inputs with the same variance if we later apply L2 regularization to our models\n\n- There is a lot of discussion about how best to scale inputs\n- Best if the input means are near zero\n- Best if variances are comparable\n\n--------------------------------------------------------------------------------\n\nWe could:\n\n- Use `step_normalize()`  [Bad choice of function names by tidymodel folks; standardize vs. normalize]\n- Use `step_range()`\n- Book range corrected based on known true range (`/ 255`)\n\nWe will use `step_normalize()`\n\n--------------------------------------------------------------------------------\n\n```{r}\nrec_scaled_wrong <- \n  recipe(y ~ ., data = data_trn) |>\n  step_normalize(all_predictors())\n```\n\nThis is wrong! Luckily we glimpsed our feature matrix (not displayed here)\n\n::: {.callout-important}\n# Question: What went wrong and what should we do?\n:::\n\n::: {.fragment .uwred}\nMany of the features have zero variance b/c they are black for ALL of the  images (e.g., top rows of pixels.  We can not scale a predictor with zero variance  b/c when we divide by the SD = 0, we get NaN).  At a minimum, we should remove  zero variance predictors in training from training and test\n:::\n\n--------------------------------------------------------------------------------\n\nFor example\n```{r}\ndata_trn$x1 |> sd()\n```\n\n--------------------------------------------------------------------------------\n\nLet's remove zero variance predictors before we scale\n\n- To be clear, zero variance features are NOT a problem for neural networks (though clearly they won't help either).\n- But they WILL definitely cause problems for some scaling transformations.\n```{r}\nrec_scaled <- \n  recipe(y ~ ., data = data_trn) |>\n  step_zv(all_predictors()) |> \n  step_normalize(all_predictors())\n```\n\n--------------------------------------------------------------------------------\n\nWe now have 717 (+ y) features rather than 28 * 28 = 784 features\n\n```{r}\nrec_scaled_prep <- rec_scaled |> \n  prep(data_trn)\n\nfeat_trn <- rec_scaled_prep |> \n  bake(NULL)\n\ndim(feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\nLet's also make the feature matrix for test.  This will exclude features that were zero variance in **train** and scale them by their mean and sd in **train**\n\n```{r}\nfeat_test <- rec_scaled_prep |> \n  bake(data_test)\n\ndim(feat_test)\n```\n\n--------------------------------------------------------------------------------\n\nLet's fit and evaluate this new feature set with no other changes to the model configuration\n\n```{r}\n#| label: fit_2\n\nfit_2 <-\n  mlp() |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n\n- That helped a LOT\n- Still could be better though (but it always impresses me! ;-)\n```{r}\naccuracy_vec(feat_test$y, predict(fit_2, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\nThere are many other recommendations about feature engineering to improve the inputs\n\nThese include:\n\n- Normalize (and here I mean true normalization; e.g., `step_BoxCox()`, `step_YeoJohnson()`)\n- De-correlate (e.g., `step_pca()` but retain all features?)\n\nYou can see some discussion of these issues [here](https://machinelearningmastery.com/how-to-improve-neural-network-stability-and-modeling-performance-with-data-scaling/#:~:text=Scaling%20input%20and%20output%20variables,is%20presented%20to%20a%20network) and [here](https://stats.stackexchange.com/questions/7757/data-normalization-and-standardization-in-neural-networks) to get you started.  The [paper](http://yann.lecun.com/exdb/publis/pdf/lecun-98b.pdf) linked in the stack overflow response is also a useful starting point.\n\n--------------------------------------------------------------------------------\n\nSome **preliminary** modeling EDA on my part suggested these additional considerations didn't have major impact on the performance of our models with this dataset so we will stick with just scaling the features.\n\n--------------------------------------------------------------------------------\n\nIt is not surprising that a model configuration with only one hidden layer and 5 units isn't sufficient for this complex task\n\nLet's try 30 units (cheating based on the book chapter!! ;-)\n\n```{r}\n#| label: fit_5units\n\nfit_5units <- mlp(hidden_units = 30) |>\n    set_mode(\"classification\") |> \n    set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n    fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n- Bingo!  Much, much better!\n- We could see if even more units works better still but I won't follow that through here for sake of simplicity\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_5units, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\nThe Three Blue 1 Brown videos had a brief discussion of the [relu activation function](https://machinelearningmastery.com/rectified-linear-activation-function-for-deep-learning-neural-networks/).\n\nLet's see how to use other activation functions and if this one helps.\n```{r}\n#| label: fit_relu\n\nfit_relu <- mlp(hidden_units = 30, activation = \"relu\") |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_relu, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n## Dealing with Overfitting\n\nAs you might imagine, given the number of weights to be fit in even a modest neural network\n(our 30 hidden unit network has 21,850 parameters to estimate), it is easy to become overfit\n\n- 21,540 for hidden layer (717 * 30 weight + 30 biases)\n- 310 for output layer (30 * 10 weights, + 10 biases)\n```{r}\nfit_relu\n```\n\nThis will be an even bigger problem if you aren't using \"big\" data\n\n--------------------------------------------------------------------------------\n\nThere are a number of different methods available to reduce potential overfitting\n\n- Simplify the network architecture (fewer units, fewer layers)\n- L2 regularization \n- Dropout\n- Early stopping or monitoring validation error to prevent too many epochs\n\n--------------------------------------------------------------------------------\n\n### Regularization or Weight Decay\n\nL2 regularization is implemented in essentially the same fashion as you have seen \nit previously (e.g., glmnet)\n\nThe cost function is expanded to include a penalty based on the sum of the squared weights multiplied by $\\lambda$.  \n\nIn the tidymodels implementation of Keras:\n\n- $\\lambda$ is called `penalty` and is set and/or (ideally) tuned via the \n`penalty` argument in `mlp()`\n\n- Common values for the L2 `penalty` to tune a neural network are often on a logarithmic scale between 0 and 0.1, such as 0.1, 0.001, 0.0001, etc.\n\n- `penalty = 0` (the default) means no L2 regularization\n\n- Keras implements other penalties (L1, and a mixture) but not currently through tidymodels\n\n- [Here](https://machinelearningmastery.com/how-to-reduce-overfitting-in-deep-learning-with-weight-regularization/) is a starting point for more reading on regularization in neural networks\n\n--------------------------------------------------------------------------------\n\nLet's set `penalty = .0001`.   \n\n```{r}\n#| label: fit_penalty\n\nfit_penalty <- mlp(hidden_units = 30, activation = \"relu\", penalty = .0001) |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n- Looks like there is not much benefit to regularization for this network.  \n- Would likely provide much greater benefit in smaller N contexts or with more complicated model architectures (more hidden units, more hidden unit layers).\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_penalty, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n### Dropout\n\nDropout is a second technique to minimize overfitting.\n\nHere is a clear description of dropout from a blog post on the Machine Learning Mastery: \n\n- Dropout is a technique where randomly selected neurons are ignored during training. They are “dropped-out” randomly. This means that their contribution to the activation of downstream neurons is temporally removed on the forward pass and any weight updates are not applied to the neuron on the backward pass.\n\n- As a neural network learns, neuron weights settle into their context within the network. Weights of neurons are tuned for specific features providing some specialization. Neighboring neurons come to rely on this specialization, which if taken too far can result in a fragile model too specialized to the training data. \n\n- You can imagine that if neurons are randomly dropped out of the network during training, that other neurons will have to step in and handle the representation required to make predictions for the missing neurons. This is believed to result in multiple independent internal representations being learned by the network.\n\n- The effect is that the network becomes less sensitive to the specific weights of neurons. This in turn results in a network that is capable of better generalization and is less likely to overfit the training data.\n\n--------------------------------------------------------------------------------\n\nFor further reading, you might start with the 2014 paper by [Srivastava, et al](https://jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf) that proposed the technique.\n\nIn tidymodels, you can set or tune the amount of dropout via the `dropout` argument in `mlp()`\n\n- Srivastava, et al suggest starting with values around .5.  \n- You might consider a range between .1 and .5\n- `droppout = 0` (the default) means no dropout\n- In tidymodels implementation of Keras, you can use a non-zero `penalty` or `dropout` but not both\n\n--------------------------------------------------------------------------------\n\nLet's try `dropout = .1`.  \n\n```{r}\n#| label: fit_dropout\n\nfit_dropout <- mlp(hidden_units = 30, activation = \"relu\", dropout = .1) |>\n  set_mode(\"classification\") |>  \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n- Looks like there may be a little benefit but not substantial.  \n- Would likely provide much greater benefit in smaller N contexts or with more complicated model architectures (more hidden units, more hidden unit layers).\n```{r}\naccuracy_vec(feat_test$y, predict(fit_dropout, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n### Number of Epochs and Early Stopping\n\nNow that we have a model that is working well, lets return to the issue of number of epochs\n\n- Too many epochs can lead to overfitting\n- Too many epochs also just slow things down (not a bit deal if using GPU or overnight but still.....)\n- Too few epochs can lead to under-fitting (which also produces poor performance)\n- The default of `epochs = 20` is a reasonable starting point for a network with one hidden layer but may not work for all situations\n\n--------------------------------------------------------------------------------\n\nMonitoring training error (loss, accuracy) is not ideal b/c it will tend to always decrease\n\n- This is what you would get if you set `verbose = 1`\n\nValidation error is what you need to monitor\n\n- Validation error will increase when the model becomes overfit to training\n- We can have Keras hold back some portion of the training data for validation\n  - `validation_split = 1/6`\n  - We pass it in as an optional argument in `set_engine()`\n  - We can use this to monitor validation error rather than training error by epoch. \n  - You can fit an exploratory model with `epochs = 50` to review the plot\n  - This can allow us to determine an appropriate value for `epochs`\n \n--------------------------------------------------------------------------------\n\nLet's see this in action in the best model configuration without regularization or dropout\n\nNOTE:\n\n- `epochs = 50`\n- `verbose = 1`\n- `metrics = c(\"accuracy\")`\n- `validation_split = 1/6`\n- You will see message updates and a plot that tracks training and validation loss and accuracy across epochs\n- This is not rendered into my slides but the plot and messages are pretty clear\n- You can use this information to choose appropriate values for `epoch`\n- `val_accuracy` had plateau and `val_loss` had started to creep up by 10 epochs.\n\n```{r}\n#| label: fit_epochs50\n#| message: false\n#| output: false\n\nfit_epochs50 <- mlp(hidden_units = 30, activation = \"relu\", epochs = 50) |>\n  set_mode(\"classification\") |>  \n  set_engine(\"keras\", verbose = 1, seeds = fit_seeds, \n             metrics = c(\"accuracy\"), \n             validation_split = 1/6) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\nIn some instances, it may be that we want to do more than simply look at epoch performance plots during modeling EDA\n\nWe can instead set the number of epochs to be high but use an early stopping callback to end \nthe training early at an optimal time\n\n--------------------------------------------------------------------------------\n\nCallbacks allow us to interrupt training.   \n\n- There are many types of callbacks in Keras\n- We will only discuss `callback_early_stopping()`\n- We set up callbacks in a list\n- We pass them in as an optional argument in `set_engine()` using `callbacks = `\n- Notice the arguments for `callback_early_stopping()`\n- We also must provide validation error.  Here we set `validation_split = 1/6`\n- This is a method to **tune or select** best number of epochs.  \n  - I haven't yet figured out where the epochs at termination are saved so need to watch the feedback.  It was 35 epochs here\n  - As always, we **could** next refit to the full training set after we have determined the optimal number of epochs.  We won't do that here.\n\n--------------------------------------------------------------------------------\n\nThis fit stopped at 15 epochs\n\n```{r}\ncallback_list <- list(keras::callback_early_stopping(monitor = \"val_loss\", \n                                                     min_delta = 0, \n                                                     patience = 10))\n```\n\n```{r}\n#| label: fit_early\n#| message: false\n#| output: false\n\nfit_early <- mlp(hidden_units = 30, activation = \"relu\", epochs = 200) |>\n  set_mode(\"classification\") |> \n  set_engine(\"keras\", verbose = 1,\n             seeds = fit_seeds, \n             metrics = c(\"accuracy\" ), \n             validation_split = 1/6,\n             callbacks = callback_list) |>\n  fit(y ~ ., data = feat_trn)\n```\n\n--------------------------------------------------------------------------------\n\n```{r}\naccuracy_vec(feat_test$y, predict(fit_early, feat_test)$.pred_class)\n```\n\n--------------------------------------------------------------------------------\n\n**Coding sidebar:** You can see many of the optional arguments you can set for Keras in the help [here](https://keras.rstudio.com/reference/fit.html).   \n\nAnd you can see more info about `callback_early_stopping()` [here](https://keras.rstudio.com/reference/callback_early_stopping.html)\n\n--------------------------------------------------------------------------------\n\n## Using Resampling to Select Best Model Configuration\n\nDeveloping a good network artchitecture and considering feature enginnering options involves experimentation\n  \n- This is what Keras is designed to do\n- tidymodels allows this too\n- We need to evaluate configurations with a valid method to evaluate performance\n  - validation split metric\n  - k-fold metric\n  - bootstrap method\n  - Each can be paired with `fit_resamples()` or `tune_grid()`\n- We need to be systematic\n  - `tune_grid()` helps with this too\n  - recipes can be tuned as well (outside the scope of this course)\n\n--------------------------------------------------------------------------------\n\nHere is an example where we can select among many model configurations that differ across multiple network characteristics\n\n- Evaluate with validation split accuracy \n- Sample size is relatively big so we have 10,000 validation set observations.  Should offer a low variance performance estimate\n- K-fold and bootstrap would still be better but big computation costs (too big for this web book but could be done in real life!)\n\n--------------------------------------------------------------------------------\n\nIts really just our normal workflow at this point\n\n- Get splits (validation splits in this example)\n```{r}\nset.seed(102030)\nsplits_validation <-\n  data_trn |> \n  validation_split(prop = 5/6)\n```\n\n--------------------------------------------------------------------------------\n\n- Set up grid of hyperparameter values\n```{r}\ngrid_keras <- expand_grid(hidden_units = c(5, 10, 20, 30, 50, 100), \n                          penalty = c(.00001, .0001, .01, .1))\n```\n\n--------------------------------------------------------------------------------\n\n- Use `tune_grid()` to fit models in training and predict into validation set for each combination of hyperparameter values\n```{r}\n#| label: fits_nn\n\nfits_nn <- cache_rds(\n  expr = {\n    mlp(hidden_units = tune(), penalty = tune(), activation = \"relu\") |>\n    set_mode(\"classification\") |> \n    # setting to verbose = 1 to track progress.  Training error not that useful\n    set_engine(\"keras\", verbose = 1, seeds = fit_seeds) |>  \n    tune_grid(preprocessor = rec_scaled, \n                  grid = grid_keras,\n                  resamples = splits_validation,\n                  metrics = metric_set(accuracy))\n  },\n  rerun = rerun_setting,\n  dir = \"cache/010/\",\n  file = \"fits_nn\")\n```\n\n--------------------------------------------------------------------------------\n\n- Find model configuration with best performance in the held-out validation set\n```{r}\nshow_best(fits_nn)\n```\n\n--------------------------------------------------------------------------------\n\n## Other Details\n\nWe can get a better sense of how tidymodels is interacting with Keras by looking at the function that is called\n\n```{r}\nmlp(hidden_units = 30, activation = \"relu\", dropout = .1) |>\n  set_mode(\"classification\") |>  \n  set_engine(\"keras\", verbose = 0, seeds = fit_seeds) |> \n  translate()\n```\n\n--------------------------------------------------------------------------------\n\n`keras_mlp()` is a wrapper around the calls to Keras.  Lets see what it does\n```{r}\nkeras_mlp\n```\n\nWe can see:\n\n- How the activation functions are setup\n- The choice of cost function: mse or binary_crossentropy\n- The optimizer: Adam\n- How the three seeds are being used\n\n--------------------------------------------------------------------------------\n\nFinally, you might  have noticed that we never set a learning rate anywhere\n\nThe [Adam optimizer](pdfs/kingma_adam_optimizer.pdf) is used instead of classic stochastic gradient descent.  The authors of this optimizer state it is:\n\n- Straightforward to implement.\n- Computationally efficient.\n- Little memory requirements.\n- Invariant to diagonal rescale of the gradients.\n- Well suited for problems that are large in terms of data and/or parameters.\n- Appropriate for non-stationary objectives.\n- Appropriate for problems with very noisy/or sparse gradients.\n- Hyper-parameters have intuitive interpretation and typically require little tuning.\n\n--------------------------------------------------------------------------------\n\nYou can start additional reading about Adam [here](https://machinelearningmastery.com/adam-optimization-algorithm-for-deep-learning/#:~:text=Adam%20is%20a%20replacement%20optimization,sparse%20gradients%20on%20noisy%20problems)\n\nFor now, if you want another optimizer or much more control over your network architecture, you may need to work directly in Keras."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"css":["book.css"],"output-file":"l10_neural_networks.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","bibliography":["refs.bib"],"callout-icon":false,"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}