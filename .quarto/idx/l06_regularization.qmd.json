{"title":"Regularization and Penalized Models","markdown":{"yaml":{"editor_options":{"chunk_output_type":"console"}},"headingText":"Regularization and Penalized Models","containsRefs":false,"markdown":"\n\n::: {.content-visible unless-format=\"revealjs\"}\n:::\n::: {.content-visible when-format=\"revealjs\"}\n# IAML Unit 6: Regularization and Penalized Models\n:::\n\n##  Learning Objectives\n\n- Subsetting approaches: Forward, Backward, Best Subset (covered in reading only)\n- Cost and Loss functions\n  - What are they and how are they used\n  - What are the specific formulas for linear model, logistic regression, and variants of glmnet (ridge, LASSO, full elasticnet)\n- What is regularization\n  - What are its benefits?\n  - What are its costs?\n- How does lambda affect bias-variance trade-off in glmnet\n- What does alpha do?\n- Feature engineering approaches for dimensionality reduction: PCA (covered in reading only)\n- Other algorithms that do feature selection/dimensionality reduction: PCR and PLS (covered in reading only)\n- Contrasts of PCA, PCR, PLS, and glmnet/LASSO for dimensionality reduction (covered in reading only)\n\n-----\n\n## Introduction to Penalized/Regularized Statistical Algorithms\n\n### Overview\n\nComplex (e.g., flexible) models increase the chance of overfitting to the training set.  This leads to:\n\n- Poor prediction\n- Burdensome prediction models for implementation (need to measure lots of predictors)\n- Low power to test hypothesis about predictor effects\n\nComplex models are difficult to interpret\n\n-----\n\nRegularization is technique that:\n\n- Reduces overfitting\n- Allows for p >> n (!!!)\n- May yield more interpretable models (LASSO, Elastic Net)\n- May reduce implementation burden (LASSO, Elastic Net)\n\n-----\n\nRegularization does this by applying a penalty to the parametric model coefficients (parameter estimates)\n\n- This constrains/shrinks these coefficients to yield a simpler/less overfit model\n- Some types of penalties shrink the coefficients to zero (feature selection)\n\nWe will consider three approaches to regularization\n\n- L2 (Ridge)\n- L1 (LASSO)\n- Elastic net\n\nThese approaches are available for both regression and classification problems and for a variety of parametric statistical algorithms\n\n-----\n\n### Cost functions\n\nTo understand regularization, we need to first explicitly consider **loss/cost functions** for the parametric statistical models we have been using.\n\n- A **loss function** quantifies the error between a single predicted and observed outcome within some statistical model.  \n\n- A **cost function** is simply the aggregate of the loss across all observations in the training sample.\n\nOptimization procedures (least squares, maximum likelihood, gradient descent) seek to determine a set of parameter estimates that minimize some specific cost function for the training sample.\n\n-----\n\nThe cost function for the linear model is the mean squared error (squared loss): \n\n- $\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}$\n\n- No constraints or penalties are placed on the parameter estimates ($\\beta_k$)\n\n- They can take on any values with the only goal to minimize the MSE in the training sample\n\n-----\n\nThe cost function for logistic regression is log loss:\n\n- $\\frac{1}{n}\\sum_{i = 1}^{n} -Y_ilog(\\hat{Y_i}) - (1-Y_i)log(1-\\hat{Y_i})$\n\n- where $Y_i$ is coded 0,1 and $\\hat{Y_i}$ is the predicted probability that Y = 1\n\n- Again, no constraints or penalties are placed on the parameter estimates ($\\beta_k$)\n\n- They can take on any values with the only goal to minimize the sum of the log loss in the training sample\n\n![](figs/unit5_log_loss.png){height=5in}\n\n-----\n\n## Intuitions about Penalized Cost Functions and Regularization \n\nThis is an example from a series of wonderfully clear lectures in a [machine learning course](https://www.youtube.com/watch?v=PPLop4L2eGk&list=PLLssT5z_DsK-h9vYZkQkYNWcItqhlRJLN) by Andrew Ng in Coursera.\n\n- [Regularization: The Problem Of Overfitting](https://www.youtube.com/watch?v=u73PU6Qwl1I)\n- [Regularization: Cost Functions](https://www.youtube.com/watch?v=KvtGD37Rm5I)\n\n-----\n\nLets imagine a training set:\n\n- House sale price predicted by house size\n- True DGP is quadratic.  Diminishing increase in sale price as size increases\n- N = 5 in training set\n\n\n![](figs/unit5_ng1.png){height=5in}\n\n-----\n\nIf we fit a linear model with size as the only feature...\n\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size$\n\n- In this training set, we might get the model below (in blue)\n\n- This is a biased model (predicts too high for low and high house sizes; predicts too low for moderate size houses)\n\n- If we took this model to new data from the same quadratic DGP, it would clearly not predict very well\n\n![](figs/unit5_ng2.png){height=5in}\n\n-----\n\nLets consider the other extreme\n\n- If we fit a 4th order polynomial model using size...\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size + \\beta_2 * size^2 + \\beta_3 * size^3 + \\beta_4 * size^4$\n- In this training set, we would get the model below (in blue)\n- This is model is overfit to this training set.  It would not predict well in new data from the same quadratic DGP\n- Also, the model would have high variance (if we estimated the parameters in another N = 5 training set, they would be very different)\n\n![](figs/unit5_ng3.png){height=5in}\n\n-----\n\nThis problem with overfitting and variance isn't limited to polynomial regression.\n\n- We would have the same problem (perfect fit in training with poor fit in new val data) if we predicted housing prices with many features when the training N = 5.  e.g.,\n\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size + \\beta_2 * year\\_built + \\beta_3 * num\\_garages + \\beta_4 * quality$\n\n-----\n\nObviously, the correct model to fit is a second order polynomial model with size\n\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size + \\beta_2 * size^2$\n- But we couldn't know this with real data because we wouldn't know the underlying DGP\n- When we don't know the underlying DGP, we need to be able to consider potentially complex models with many features in some way that diminishes the potential problem with overfitting/model variance\n\n![](figs/unit5_ng4.png){height=5in}\n\n-----\n\nWhat if we still fit a fourth order polynomial but changed the cost function to penalize the absolute value of $\\beta_3$ and $\\beta_4$ parameter estimates?\n\n**Typical cost based on MSE/squared loss:**\n\n- $\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}$\n\n**Our new cost function:**\n\n- $[\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] +  [1000 * \\beta_3 + 1000 * \\beta_4]$\n\n-----\n\n$[\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [1000 * \\beta_3 + 1000 * \\beta_4]$\n\n- The only way to make the value of this new cost function small is to make $\\beta_3$ and $\\beta_4$ small\n\n- If we made the penalty applied to $\\beta_3$ and $\\beta_4$ large (e.g., 1000 as above), we will end up with the  parameter estimates for these two features at approximately 0.\n\n- With a sufficient penalty applied, their parameter estimates will only change from zero to the degree that these changes accounted for a large enough drop in MSE to offset this penalty in the overall aggregate cost function.\n\n-----\n\n$[\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + 1000 * \\beta_3 + 1000 * \\beta_4$\n\n- With this penalty in place, our final model might shift from the blue model to the pink model below.  The pink model is mostly quadratic but with a few extra \"wiggles\" if $\\beta_3$ and $\\beta_4$ are not exactly 0.\n\n![](figs/unit5_ng5.png){height=5in}\n\n-----\n\nOf course, we don't typically know in advance which parameter estimates to penalize. \n\n- Instead, we apply some penalty to all the parameter estimates (except $\\beta_0$)\n- This shrinks the parameter estimates for all the features to some degree\n- However, features that do reduce MSE meaningfully will be \"worth\" including with non-zero parameter estimates\n- You can also control the shrinkage by controlling the size of the penalty\n\n-----\n\nIn general, regularization produces models that: \n\n- Are simpler (e.g. smoother, smaller coefficients/parameter estimates)\n- Are less prone to overfitting\n- Allow for models with p >> n\n- Are sometimes more interpretable (LASSO, Elastic Net)\n\nThese benefits are provided by the introduction of some bias into the parameter estimates\n\nThis allows for a bias-variance trade-off where some bias is introduced for a big reduction in variance of model fit\n\n-----\n\nWe will now consider three regularization approaches that introduce different types of penalties to shrink the parameter estimates\n\n- L2 (Ridge)\n- L1 (LASSO)\n- Elastic net\n\nThese approaches are available for both regression and classification problems and for a variety of parametric statistical algorithms\n\nA fourth common regularized classification model (also sometimes used for regression) is the support vector machine (not covered in class but commonly used as well and easy to understand with this foundation)\n\nEach of these approaches uses a different specific penalty, which has implications for how the model performs in different settings\n\n-----\n\n## Ridge Regression\n\nThe cost function for Ridge Regression is:\n\n- $\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\nIt has two components:\n\n- Inside the left brackets is the SSE from linear regression\n- Inside the right brackets is the **Ridge penalty**.  \n\nThis penalty:\n\n- Includes the sum of the squared parameter estimates (excluding $\\beta_0$).  Squaring removes the sign of these parameter estimates.\n- This sum is multiplied by $\\lambda$, a hyperparameter in Ridge regression.  Lambda allows us to tune the size of the penalty.\n- This is an application of the L2 norm (matrix algebra) to the vector of parameter estimates\n\n-----\n\n$\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\n::: {.callout-important}\n# Question\nWhat will happen to a Ridge regression model's parameter estimates and its performance (i.e., its bias & variance) as lambda increases/decreases?\n:::\n\n::: {.fragment .uwred}\nAs lambda increases, the model becomes less flexible b/c its parameter estimates \nbecome constrained/shrunk.  This will increase bias but decrease variance for model \nperformance.\n:::\n\n-----\n\n$\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\n::: {.callout-important}\n# Question\nWhat is the special case of Ridge regression when lambda = 0?\n:::\n\n::: {.fragment .uwred}\nThe OLS regression is a special case where lambda = 0 (i.e., no penalty is applied).  \n\nThis is the most flexible. It is unbiased but with higher variance than for non-zero values of lambda\n:::\n\n-----\n\nLets compare Ridge regression to OLS (ordinary least squares with squared loss cost function) linear regression\n\n- Ridge parameter estimates are biased but have lower variance (smaller SE) than OLS\n\n- Ridge may predict better in new data\n  - This depends on the value of $\\lambda$ selected and its impact on bias-variance trade-off in Ridge regression vs. OLS\n  - There does exist a value of $\\lambda$ for which Ridge predicts better than OLS in new data\n\n- Ridge regression (but not OLS) allows for p > (or even >>) than n\n\n- Ridge regression (but not OLS) accommodates highly correlated (or even perfectly multi-collinear) features \n\n- OLS (but not Ridge regression) is scale invariant\n  - You should scale (mean and standard deviation correct) features for use with Ridge regression\n\n-----\n\n$\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\n::: {.callout-important}\n# Question\nWhy does the scale of the features matter for Ridge regression?\n:::\n\n::: {.fragment .uwred}\nFeatures with bigger SDs will have smaller parameter estimates.  Therefore they will be less affected by the penalty.\n\nUnless the features are on the same scale to start, you should standardize them for all applications (regression and classification) of Ridge (and also LASSO and elastic net).  You can handle this during feature engineering in the recipe.\n:::\n\n-----\n\n## LASSO Regression\n\nLASSO is an acronym for Least Absolute Shrinkage and Selection Operator\n\nThe cost function for LASSO Regression is:\n\n- $\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} |\\beta_j|\\:])$\n\nIt has two components:\n\n- Inside the left brackets is the SSE from linear regression\n- Inside the right brackets is the **LASSO penalty**.  \n\nThis penalty:\n\n- Includes the sum of the absolute value of the parameter estimates (excluding $\\beta_0$).  The absolute value removes the sign of these parameter estimates.\n\n- This sum is multiplied by $\\lambda$, a hyperparameter in LASSO regression.  Lambda allows us to tune the size of the penalty.\n\n- This is an application of the L1 norm to the vector of parameter estimates\n\n-----\n\n### LASSO vs. Ridge Comparison\n\nWith respect to the parameter estimates: \n\n- LASSO yields sparse solution (some parameter estimates set to **exactly zero**)\n\n- Ridge tends to retain all features (parameter estimates don't get set to exactly zero)\n\n- LASSO selects one feature among correlated group and sets others to zero\n\n- Ridge shrinks all parameter estimates for correlated features \n\nRidge tends to outperform LASSO wrt prediction in new data.  There are cases where LASSO can predict better (most features have zero effect and only a few are non-zero) but even in those cases, Ridge is competitive.  \n\n-----\n\n### Advantages of LASSO\n\n- Does feature selection (sets parameter estimates to exactly 0)\n  - Yields a sparse solution\n  - Sparse model is more interpretable?\n  - Sparse model is easier to implement? (fewer features included so donâ€™t need to measure as many predictors)\n\n- More robust to outliers (similar to LAD vs. OLS)\n\n- Tends to do better when there are a small number of robust features and the others are close to zero or zero\n\n-----\n\n### Advantages of Ridge\n\n- Computationally superior (closed form solution vs. iterative;  Only one solution to minimize the cost function)\n\n- More robust to measurement error in features (remember no measurement error is an assumption for unbiased estimates in OLS regression)\n\n- Tends to do better when there are many features with large (and comparable) effects (i.e., most features are related to the outcome)\n\n-----\n\n## Elastic Net Regression\n\nThe Elastic Net blends the L1 and L2 penalties to obtain the benefits of each of those approaches.\n\nWe will use the implementation of the Elastic Net in [glmnet](https://cran.r-project.org/web/packages/glmnet/glmnet.pdf) in R.  \n\nYou can also read additional [introductory documentation](https://cran.r-project.org/web/packages/glmnet/vignettes/glmnet.pdf) for this package\n\n-----\n\nIn the Gaussian regression context, the Elastic Net cost function is:\n\n- $\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda (\\alpha\\sum_{j = 1}^{p} |\\beta_j| + (1-\\alpha)\\sum_{j = 1}^{p} \\beta_j^{2})\\:])$\n\nThis model has two hyper-parameters\n\n- $\\lambda$ controls the degree of regularization as before\n- $\\alpha$ is a \"mixing\" parameter that blends the degree of L1 and L2 contributions to the aggregate penalty. (Proportion of LASSO penalty)\n  - $\\alpha$ = 1 results in the LASSO model\n  - $\\alpha$ = 0 results in the Ridge model\n  - Intermediate values for $\\alpha$ blend these penalties together proportionally to include more or less LASSO penalty\n\n-----\n\nAs before (e.g., KNN), best values of $\\lambda$ (and $\\alpha$) can be selected using resampling using `tune_grid()`\n\nThe grid needs to have crossed values of both `penalty` ($lambda$) and `mixture` ($alpha$) for glmnet\n\n  - Can use `expand_grid()`\n  - Only penalty is needed in grid if fitting a Ridge or LASSO model.\n\n-----\n\n\n## Empirical Example 1: Many \"good\" but correlated predictors\n\n```{r}\n#| include: false\n\n# set up environment.  Now hidden from view\n\n\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\noptions(conflicts.policy = \"depends.ok\")\n\nlibrary(xfun, include.only = \"cache_rds\")\n\n# parallel processing\nlibrary(future)\nplan(multisession, workers = parallel::detectCores(logical = FALSE))\n\nsource(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\nsource(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\nsource(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\npath_data <- \"./data\"\n\nrerun_setting <- TRUE \n``` \n\nFor the first example, we will simulate data with:\n\n- Many correlated predictors\n- All related to outcome\n- Get a small training sample\n- Get a big test sample (for more precise estimate of model performance)\n\n-----\n\nFirst we set the predictors for our simulation\n```{r}\nn_cases_trn <- 100\nn_cases_test <- 1000\nn_x <- 20\ncovs_x <- 50\nvars_x <- 100\nb_x <- rep(1, n_x) # one unit change in y for 1 unit change in x\ny_error <- 100\n```\n\n-----\n\nThen we draw samples from population\n```{r}\nset.seed(12345)\nmu <- rep(0, n_x)  # means for all variables = 0\nsigma <- matrix(covs_x, nrow = n_x, ncol = n_x)\ndiag(sigma) <- vars_x  \nsigma\n\nx <- MASS::mvrnorm(n = n_cases_trn, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble()\ndata_trn_1 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_trn, 0, y_error)) |>  \n  glimpse()\n\nx <- MASS::mvrnorm(n = n_cases_test, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble() \ndata_test_1 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_test, 0, y_error))\n```\n\n-----\n\nSet up a tibble to track model performance in train and test sets\n\n- We are using test to repeatedly to get rigorous held-out performance separate from model selection process.  \n- Just for our understanding \n- We would not choose a model configuration based on test set error\n\n```{r}\nerror_ex1 <- tibble(model = character(), \n                    rmse_trn = numeric(), \n                    rmse_test = numeric()) |> \n  glimpse()\n```\n\n-----\n\n### Fit a standard (OLS) linear regression\n\nFit the linear model\n\n- No feature engineering needed. Can use raw predictors as features\n- No resampling needed b/c there are no hyperparameters\n\n```{r}\nfit_lm_1 <- \n  linear_reg() |> \n  set_engine(\"lm\") |> \n  fit(y ~ ., data = data_trn_1)\n\nfit_lm_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Overfit to train\n- Much worse in test\n\n```{r}\nrmse_vec(truth = data_trn_1$y, \n         estimate = predict(fit_lm_1, data_trn_1)$.pred)\n```\n\n\n```{r}\nrmse_vec(truth = data_test_1$y, \n         estimate = predict(fit_lm_1, data_test_1)$.pred)\n```\n\n\n```{r}\n#| echo: false\n\nerror_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"linear model\",                       \n                   rmse_trn = rmse_vec(truth = data_trn_1$y, \n                                       estimate = predict(fit_lm_1, data_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = data_test_1$y, \n                                        estimate = predict(fit_lm_1, data_test_1)$.pred)))\n```\n\n-----\n\n### Fit LASSO\n\nLASSO, Ridge, and glmnet all need features on same scale to apply penalty consistently\n\n- Use `step_normalize()`.  This sets mean = 0, sd = 1 (NOTE: Bad name as it does NOT change shape of distribution!)\n- Can use same recipe for LASSO, Ridge, and glmnet\n- Can use same train and test feature matrices as well\n  \n```{r}\nrec_1 <- recipe(y ~ ., data = data_trn_1) |> \n  step_normalize(all_predictors())\n\nrec_prep_1 <- rec_1 |> \n  prep(data_trn_1)\n\nfeat_trn_1 <- rec_prep_1 |> \n  bake(NULL)\n\nfeat_test_1 <- rec_prep_1 |> \n  bake(data_test_1)\n```\n\n-----\n\nSet up splits for resampling for tuning hyperparameters\n\n- Use bootstrap for more precise estimation (even if more biased).  Good for selection\n- Can use same bootstrap splits for LASSO, Ridge, and glmnet\n```{r}\nset.seed(20140102)\nsplits_boot_1 <- data_trn_1 |> \n   bootstraps(times = 100, strata = \"y\")  \n```\n\n-----\n\nNow onto the LASSO....\n\nWe need to tune $\\lambda$ (tidymodels calls this `penalty`)\n\n- $\\alpha$ = 1 (tidymodels calls this `mixture`)\n- Set up grid with exponential values for `penalty`\n- `glmnet` uses warm starts so can fit lots of values for $\\lambda$ quickly\n- Could also use `cv.glmnet()` directly in `glmnet` package to find good values.  See `get_lamdas()` in fun_modeling.R\n\n```{r}\ngrid_lasso <- expand_grid(penalty = exp(seq(-4, 4, length.out = 100)))\n```\n\n```{r}\nfits_lasso_1 <- xfun::cache_rds(\n  expr = {\n  linear_reg(penalty = tune(), \n               mixture = 1) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_1, \n              resamples = splits_boot_1, \n              grid = grid_lasso, \n              metrics = metric_set(rmse))\n\n   },\n   rerun = rerun_setting,\n   dir = \"cache/006/\",\n   file = \"fits_lasso_1\")\n```\n\n-----\n\nEvaluate model performance in validation sets (OOB)\n\nMake sure that you have hit a clear minimum (bottom of U or at least an asymptote)\n\n```{r}\nplot_hyperparameters(fits_lasso_1, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best configuration (i.e., best lambda) to full train set\n\n- Use `select_best()`\n- Don't forget to indicate which column ($penalty$)\n\n```{r}\nfit_lasso_1 <-\n  linear_reg(penalty = select_best(fits_lasso_1)$penalty, \n             mixture = 1) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_1)\n```\n\n-----\n\nWe can now use `tidy()` to look at the LASSO parameter estimates\n\n- `tidy()`  uses `Matrix` package, which has conflicts with `tidyr`.  Load the package without those conflicting functions\n\n```{r}\nlibrary(Matrix, exclude = c(\"expand\", \"pack\", \"unpack\"))\n```\n\n-----\n\nNow call `tidy()`\n\n- Notice that LASSO sets some $\\beta$ to 0 even though none are 0 in DGP\n- LASSO is not great at reproducing the DGP!\n```{r}\nfit_lasso_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Somewhat better in test \n```{r}\n(error_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"LASSO model\",                       \n                   rmse_trn = rmse_vec(truth = feat_trn_1$y, \n                                       estimate = predict(fit_lasso_1,\n                                                          feat_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_1$y, \n                                        estimate = predict(fit_lasso_1,\n                                                           feat_test_1)$.pred))))\n```\n\n-----\n\n### Fit Ridge\n\nFit Ridge algorithm\n\n- Tune $\\lambda$ (`penalty`)\n- May need to experiment to get right range of values for lambda\n- $\\alpha$ = 0 (`mixture`)\n- Evaluate model configurations in OOB validation sets\n\n```{r}\ngrid_ridge <- expand_grid(penalty = exp(seq(-1, 7, length.out = 100)))\n```\n\n```{r}\ngrid_ridge <- expand_grid(penalty = exp(seq(-1, 7, length.out = 100)))\n```\n\n```{r}\nfits_ridge_1 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = 0) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_1, \n              resamples = splits_boot_1, \n              grid = grid_ridge, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_ridge_1\")\n```\n\n-----\n\nReview hyperparameter plot\n```{r}\nplot_hyperparameters(fits_ridge_1, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best model configuration (i.e., best lambda) in full train set\n\n- Notice that no $\\beta$ are exactly 0\n- [Why are parameter estimates not near 1 for LASSO and Ridge?]{.red}\n```{r}\nfit_ridge_1 <-\n  linear_reg(penalty = select_best(fits_ridge_1)$penalty, \n             mixture = 0) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_1)\n\nfit_ridge_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Much less overfit to train\n- Still not bad in test \n```{r}\n(error_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"Ridge model\",   \n                   rmse_trn = rmse_vec(truth = feat_trn_1$y, \n                                       estimate = predict(fit_ridge_1,\n                                                          feat_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_1$y, \n                                        estimate = predict(fit_ridge_1,\n                                                           feat_test_1)$.pred))))\n```\n\n-----\n\n### Fit glmnet\n\nNow we need to tune both\n\n- $\\lambda$ (`penalty`)\n- $\\alpha$ (`mixture`)\n- Typical to only evaluate a small number of $alpha$\n- Warm starts across $\\lambda$\n\n```{r}\ngrid_glmnet <- expand_grid(penalty = exp(seq(-1, 7, length.out = 100)),\n                           mixture = seq(0, 1, length.out = 6))\n```\n\n```{r}\nfits_glmnet_1 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_1, \n              resamples = splits_boot_1, \n              grid = grid_glmnet, \n              metrics = metric_set(rmse))\n  \n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_glmnet_1\")\n```\n\n-----\n\n```{r}\nplot_hyperparameters(fits_glmnet_1, hp1 = \"penalty\", hp2 = \"mixture\", metric = \"rmse\")\n```\n\n-----\n\nFit best configuration in full train set\n\n- Can use `select_best()` for both hyperparameters, separately\n- Ridge was best (but cool that glmnet could determine that empirically!)\n```{r}\nselect_best(fits_glmnet_1)\n\nfit_glmnet_1 <-\n  linear_reg(penalty = select_best(fits_glmnet_1)$penalty, \n             mixture = select_best(fits_glmnet_1)$mixture) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_1)\n```\n\n-----\n\n```{r}\nfit_glmnet_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nA final comparison of training and test error for the four statistical algorithms\n```{r}\n(error_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"glmnet model\",   \n                   rmse_trn = rmse_vec(truth = feat_trn_1$y, \n                                       estimate = predict(fit_glmnet_1,\n                                                          feat_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_1$y, \n                                        estimate = predict(fit_glmnet_1,\n                                                           feat_test_1)$.pred))))\n```\n\n\n-----\n\n## Empirical Example 2: Good and Zero Predictors\n\nFor the second example, we will simulate data with:\n\n- Two sets of correlated predictors\n- First (smaller) set related to outcome (5 predictors)\n- Second (larger) set unrelated to outcome (15 predictors)\n- Get a small training sample\n- Get a big test sample (for more precise estimates of performance of our model configurations)\n\n-----\n\nSet up simulation parameters \n```{r}\nn_cases_trn <- 100\nn_cases_test <- 1000\nn_x <- 20\ncovs_x <- 50 \nvars_x <- 100\nb_x <- c(rep(1,5),rep(0, 15))\ny_error <- 100\n```\n\n-----\n\n```{r}\nmu <- rep(0, n_x)  \n\nsigma <- matrix(0, nrow = n_x, ncol = n_x)\nfor (i in 1:(n_x/2)){\n  for(j in 1:(n_x/2)){\n    sigma[i, j] <- covs_x\n  }\n} \nfor (i in (n_x/2 + 1):n_x){\n  for(j in (n_x/2 + 1):n_x){\n    sigma[i, j] <- covs_x\n  }\n} \n\ndiag(sigma) <- vars_x  \n```\n\n-----\n\nSimulate predictors and Y\n```{r}\nset.seed(2468)\n\nx <- MASS::mvrnorm(n = n_cases_trn, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble()\ndata_trn_2 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_trn, 0, y_error)) |>  \n  glimpse()\n\nx <- MASS::mvrnorm(n = n_cases_test, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble()\ndata_test_2 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_test, 0, y_error)) |>  \n  glimpse()\n```\n\n-----\n\nSet up a tibble to track model performance in train and test\n```{r}\nerror_ex2 <- tibble(model = character(), rmse_trn = numeric(), rmse_test = numeric()) |> \n  glimpse()\n```\n\n-----\n\n### Fit a standard (OLS) linear regression\n\nFit and evaluate the linear model\n```{r}\nfit_lm_2 <- \n  linear_reg() |> \n  set_engine(\"lm\") |> \n  fit(y ~ ., data = data_trn_2)\n\nfit_lm_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Very overfit to train\n- Very poor performance in test \n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"linear model\",                       \n                   rmse_trn = rmse_vec(truth = data_trn_2$y, \n                                       estimate = predict(fit_lm_2,\n                                                          data_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = data_test_2$y, \n                                        estimate = predict(fit_lm_2,\n                                                           data_test_2)$.pred))))\n```\n\n-----\n\n### Fit LASSO\n\nFor all glmnet algorithms, set up:\n\n- Recipe\n- Feature matrices\n- Bootstraps for model configuration selection (tuning)\n```{r}\nrec_2 <- recipe(y ~ ., data = data_trn_2) |> \n  step_normalize(all_predictors())\n\nrec_prep_2 <- rec_2 |> \n  prep(data_trn_2)\n\nfeat_trn_2 <- rec_prep_2 |> \n  bake(NULL)\n\nfeat_test_2 <- rec_prep_2 |> \n  bake(data_test_2)\n\nset.seed(20140102)\nsplits_boot_2 <- data_trn_2 |> \n   bootstraps(times = 100, strata = \"y\") \n```\n\n-----\n\nTune $\\lambda$ for LASSO\n\n- We can use sample penalty grids from earlier example because sample size and number of features hasnt changed so likely still good\n\n```{r}\nfits_lasso_2 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = 1) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_2, \n              resamples = splits_boot_2, \n              grid = grid_lasso, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_lasso_2\")\n```\n\n-----\n\nPlot hyperparameters\n```{r}\nplot_hyperparameters(fits_lasso_2, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best LASSO to full training set\n\n- Notice the many $\\beta$ = 0\n- It did set some of the \"good\" features to 0 as well\n```{r}\nfit_lasso_2 <-\n  linear_reg(penalty = select_best(fits_lasso_2, metric = \"rmse\")$penalty, \n             mixture = 1) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_2)\n\nfit_lasso_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Good in val\n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"LASSO model\",                       \n                   rmse_trn = rmse_vec(truth = feat_trn_2$y, \n                                       estimate = predict(fit_lasso_2,\n                                                          feat_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_2$y, \n                                        estimate = predict(fit_lasso_2,\n                                                           feat_test_2)$.pred))))\n```\n\n-----\n\n### Fit Ridge\n\nTune $\\lambda$ for Ridge\n\n- can use ridge penalty grid from example 1\n\n```{r}\nfits_ridge_2 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = 0) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_2, \n              resamples = splits_boot_2, \n              grid = grid_ridge, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_ridge_2\")\n```\n\n-----\n\nPlot hyperparameters\n```{r}\nplot_hyperparameters(fits_ridge_2, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best Ridge to full training set\n\n- Notice no $\\beta$ = 0\n```{r}\nfit_ridge_2 <-\n  linear_reg(penalty = select_best(fits_ridge_2, metric = \"rmse\")$penalty, \n             mixture = 0) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_2)\n\nfit_ridge_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Still slightly better than LASSO in test (but maybe equivalent?)\n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"Ridge model\",                       \n                   rmse_trn = rmse_vec(truth = feat_trn_2$y, \n                                       estimate = predict(fit_ridge_2,\n                                                          feat_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_2$y, \n                                        estimate = predict(fit_ridge_2,\n                                                           feat_test_2)$.pred))))\n```\n\n-----\n\n### Fit Complete glmnet\n\nTune $\\lambda$ and $\\alpha$ for glmnet\n\n\n```{r}\nfits_glmnet_2 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_2, \n              resamples = splits_boot_2, \n              grid = grid_glmnet, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_glmnet_2\")\n```\n\n-----\n\nPlot hyperparameters\n```{r}\nplot_hyperparameters(fits_glmnet_2, hp1 = \"penalty\", hp2 = \"mixture\", metric = \"rmse\")\n```\n\n-----\n\nFit best glmnet in full train set\n\n- Still Ridge (but won't always be)\n```{r}\nselect_best(fits_glmnet_2, metric = \"rmse\")\n\nfit_glmnet_2 <-\n  linear_reg(penalty = select_best(fits_glmnet_2, metric = \"rmse\")$penalty, \n             mixture = select_best(fits_glmnet_2, metric = \"rmse\")$mixture) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_2)\n\nfit_glmnet_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Still not bad in validate\n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"glmnet model\",   \n                   rmse_trn = rmse_vec(truth = feat_trn_2$y, \n                                       estimate = predict(fit_glmnet_2,\n                                                          feat_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_2$y, \n                                        estimate = predict(fit_glmnet_2,\n                                                           feat_test_2)$.pred))))\n```\n\n-----\n\n## LASSO for Feature (e.g., Covariate) Selection?\n\nLets consider a typical explanatory setting in Psychology\n\n- A focal dichotomous IV (your experimental manipulation)\n- A number of covariates (some good, some bad)\n- A quantitative outcome (y)\n- Covariates are uncorrelated with IV b/c IV is manipulated\n\nLet's pretend the previous 20 `x`s were your covariates\n\n-----\n\nWhat are your options to test `iv` prior to this course?\n\n- You want to use covariates to increase power \n\n- BUT you don't know which covariates to use\n\n  - You might use all of them\n\n  - Or you might use none of them (a clear lost opportunity)\n\n  - Or you might hack it by using those increase your focal IV effect (very bad!)\n  \n-----\n\n\nNOW, We might use the feature selection characteristics for LASSO to select which covariates are included\n\nThere are two possibilities that occur to me\n\n-----\n\n1.  Use LASSO to build best DGP for a covariates only model\n\n- Could be more conservative (fewer covariates) by using within 1 SE of best performance but less flexible (i.e., will set more parameter estimates to 0)\n- Follow up with a linear model (using $lm$), regressing y on $iv$ and covariates from LASSO that are non-zero\n\n```{r}\nfit_lasso_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n- You clearly improved your best guess on covariates to include \n- You will regress y on `iv` and the 7 covariates with non-zero effects\n\n-----\n\n2. Use LASSO to build best DGP including `iv` and covariates but don't penalize `iv`\n\n- Look at `penalty.factor = rep(1, nvars)` argument in `glmnet()`\n- Can fit LASSO with unbiased? estimate of `iv`\n- Need to bootstrap for SE for `iv` (next unit)\n- Only appropriate if IV is manipulated\n\nShould really conduct simulation study of both of these options (vs. all and no covariates).  \n\n- I want to\n- Want to do the study with me?\n\n-----\n\n## Ridge, LASSO, and Elastic net models for other Y distributions\n\nThese penalties can be added to the cost functions of other generalized linear models to yield regularized/penalized versions of those models as well.  For example\n\nL1 penalized (LASSO) logistic regression (w/ labels coded 0,1):\n\n- $\\frac{1}{n}([\\:\\sum_{i = 1}^{n} -Y_ilog(\\hat{Y_i}) - (1-Y_i)log(1-\\hat{Y_i})\\:]\\:+\\:[\\:\\lambda\\sum_{j = 1}^{p} |\\beta_j|\\:]$\n\nFor L2 penalized (Ridge) logistic regression (w/ labels coded 0,1)\n\n- $\\frac{1}{n}([\\:\\sum_{i = 1}^{n} -Y_ilog(\\hat{Y_i}) - (1-Y_i)log(1-\\hat{Y_i})\\:]\\:+\\:[\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:]$\n\n`glmnet` implements: \n\n- `family = c(\"gaussian\", \"binomial\", \"poisson\", \"multinomial\", \"cox\", \"mgaussian\")`\n- Full range of $\\alpha$ to mix two types of penalties","srcMarkdownNoYaml":"\n\n::: {.content-visible unless-format=\"revealjs\"}\n# Regularization and Penalized Models\n:::\n::: {.content-visible when-format=\"revealjs\"}\n# IAML Unit 6: Regularization and Penalized Models\n:::\n\n##  Learning Objectives\n\n- Subsetting approaches: Forward, Backward, Best Subset (covered in reading only)\n- Cost and Loss functions\n  - What are they and how are they used\n  - What are the specific formulas for linear model, logistic regression, and variants of glmnet (ridge, LASSO, full elasticnet)\n- What is regularization\n  - What are its benefits?\n  - What are its costs?\n- How does lambda affect bias-variance trade-off in glmnet\n- What does alpha do?\n- Feature engineering approaches for dimensionality reduction: PCA (covered in reading only)\n- Other algorithms that do feature selection/dimensionality reduction: PCR and PLS (covered in reading only)\n- Contrasts of PCA, PCR, PLS, and glmnet/LASSO for dimensionality reduction (covered in reading only)\n\n-----\n\n## Introduction to Penalized/Regularized Statistical Algorithms\n\n### Overview\n\nComplex (e.g., flexible) models increase the chance of overfitting to the training set.  This leads to:\n\n- Poor prediction\n- Burdensome prediction models for implementation (need to measure lots of predictors)\n- Low power to test hypothesis about predictor effects\n\nComplex models are difficult to interpret\n\n-----\n\nRegularization is technique that:\n\n- Reduces overfitting\n- Allows for p >> n (!!!)\n- May yield more interpretable models (LASSO, Elastic Net)\n- May reduce implementation burden (LASSO, Elastic Net)\n\n-----\n\nRegularization does this by applying a penalty to the parametric model coefficients (parameter estimates)\n\n- This constrains/shrinks these coefficients to yield a simpler/less overfit model\n- Some types of penalties shrink the coefficients to zero (feature selection)\n\nWe will consider three approaches to regularization\n\n- L2 (Ridge)\n- L1 (LASSO)\n- Elastic net\n\nThese approaches are available for both regression and classification problems and for a variety of parametric statistical algorithms\n\n-----\n\n### Cost functions\n\nTo understand regularization, we need to first explicitly consider **loss/cost functions** for the parametric statistical models we have been using.\n\n- A **loss function** quantifies the error between a single predicted and observed outcome within some statistical model.  \n\n- A **cost function** is simply the aggregate of the loss across all observations in the training sample.\n\nOptimization procedures (least squares, maximum likelihood, gradient descent) seek to determine a set of parameter estimates that minimize some specific cost function for the training sample.\n\n-----\n\nThe cost function for the linear model is the mean squared error (squared loss): \n\n- $\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}$\n\n- No constraints or penalties are placed on the parameter estimates ($\\beta_k$)\n\n- They can take on any values with the only goal to minimize the MSE in the training sample\n\n-----\n\nThe cost function for logistic regression is log loss:\n\n- $\\frac{1}{n}\\sum_{i = 1}^{n} -Y_ilog(\\hat{Y_i}) - (1-Y_i)log(1-\\hat{Y_i})$\n\n- where $Y_i$ is coded 0,1 and $\\hat{Y_i}$ is the predicted probability that Y = 1\n\n- Again, no constraints or penalties are placed on the parameter estimates ($\\beta_k$)\n\n- They can take on any values with the only goal to minimize the sum of the log loss in the training sample\n\n![](figs/unit5_log_loss.png){height=5in}\n\n-----\n\n## Intuitions about Penalized Cost Functions and Regularization \n\nThis is an example from a series of wonderfully clear lectures in a [machine learning course](https://www.youtube.com/watch?v=PPLop4L2eGk&list=PLLssT5z_DsK-h9vYZkQkYNWcItqhlRJLN) by Andrew Ng in Coursera.\n\n- [Regularization: The Problem Of Overfitting](https://www.youtube.com/watch?v=u73PU6Qwl1I)\n- [Regularization: Cost Functions](https://www.youtube.com/watch?v=KvtGD37Rm5I)\n\n-----\n\nLets imagine a training set:\n\n- House sale price predicted by house size\n- True DGP is quadratic.  Diminishing increase in sale price as size increases\n- N = 5 in training set\n\n\n![](figs/unit5_ng1.png){height=5in}\n\n-----\n\nIf we fit a linear model with size as the only feature...\n\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size$\n\n- In this training set, we might get the model below (in blue)\n\n- This is a biased model (predicts too high for low and high house sizes; predicts too low for moderate size houses)\n\n- If we took this model to new data from the same quadratic DGP, it would clearly not predict very well\n\n![](figs/unit5_ng2.png){height=5in}\n\n-----\n\nLets consider the other extreme\n\n- If we fit a 4th order polynomial model using size...\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size + \\beta_2 * size^2 + \\beta_3 * size^3 + \\beta_4 * size^4$\n- In this training set, we would get the model below (in blue)\n- This is model is overfit to this training set.  It would not predict well in new data from the same quadratic DGP\n- Also, the model would have high variance (if we estimated the parameters in another N = 5 training set, they would be very different)\n\n![](figs/unit5_ng3.png){height=5in}\n\n-----\n\nThis problem with overfitting and variance isn't limited to polynomial regression.\n\n- We would have the same problem (perfect fit in training with poor fit in new val data) if we predicted housing prices with many features when the training N = 5.  e.g.,\n\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size + \\beta_2 * year\\_built + \\beta_3 * num\\_garages + \\beta_4 * quality$\n\n-----\n\nObviously, the correct model to fit is a second order polynomial model with size\n\n- $\\hat{sale\\_price_i} = \\beta_0 + \\beta_1 * size + \\beta_2 * size^2$\n- But we couldn't know this with real data because we wouldn't know the underlying DGP\n- When we don't know the underlying DGP, we need to be able to consider potentially complex models with many features in some way that diminishes the potential problem with overfitting/model variance\n\n![](figs/unit5_ng4.png){height=5in}\n\n-----\n\nWhat if we still fit a fourth order polynomial but changed the cost function to penalize the absolute value of $\\beta_3$ and $\\beta_4$ parameter estimates?\n\n**Typical cost based on MSE/squared loss:**\n\n- $\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}$\n\n**Our new cost function:**\n\n- $[\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] +  [1000 * \\beta_3 + 1000 * \\beta_4]$\n\n-----\n\n$[\\frac{1}{n}\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [1000 * \\beta_3 + 1000 * \\beta_4]$\n\n- The only way to make the value of this new cost function small is to make $\\beta_3$ and $\\beta_4$ small\n\n- If we made the penalty applied to $\\beta_3$ and $\\beta_4$ large (e.g., 1000 as above), we will end up with the  parameter estimates for these two features at approximately 0.\n\n- With a sufficient penalty applied, their parameter estimates will only change from zero to the degree that these changes accounted for a large enough drop in MSE to offset this penalty in the overall aggregate cost function.\n\n-----\n\n$[\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + 1000 * \\beta_3 + 1000 * \\beta_4$\n\n- With this penalty in place, our final model might shift from the blue model to the pink model below.  The pink model is mostly quadratic but with a few extra \"wiggles\" if $\\beta_3$ and $\\beta_4$ are not exactly 0.\n\n![](figs/unit5_ng5.png){height=5in}\n\n-----\n\nOf course, we don't typically know in advance which parameter estimates to penalize. \n\n- Instead, we apply some penalty to all the parameter estimates (except $\\beta_0$)\n- This shrinks the parameter estimates for all the features to some degree\n- However, features that do reduce MSE meaningfully will be \"worth\" including with non-zero parameter estimates\n- You can also control the shrinkage by controlling the size of the penalty\n\n-----\n\nIn general, regularization produces models that: \n\n- Are simpler (e.g. smoother, smaller coefficients/parameter estimates)\n- Are less prone to overfitting\n- Allow for models with p >> n\n- Are sometimes more interpretable (LASSO, Elastic Net)\n\nThese benefits are provided by the introduction of some bias into the parameter estimates\n\nThis allows for a bias-variance trade-off where some bias is introduced for a big reduction in variance of model fit\n\n-----\n\nWe will now consider three regularization approaches that introduce different types of penalties to shrink the parameter estimates\n\n- L2 (Ridge)\n- L1 (LASSO)\n- Elastic net\n\nThese approaches are available for both regression and classification problems and for a variety of parametric statistical algorithms\n\nA fourth common regularized classification model (also sometimes used for regression) is the support vector machine (not covered in class but commonly used as well and easy to understand with this foundation)\n\nEach of these approaches uses a different specific penalty, which has implications for how the model performs in different settings\n\n-----\n\n## Ridge Regression\n\nThe cost function for Ridge Regression is:\n\n- $\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\nIt has two components:\n\n- Inside the left brackets is the SSE from linear regression\n- Inside the right brackets is the **Ridge penalty**.  \n\nThis penalty:\n\n- Includes the sum of the squared parameter estimates (excluding $\\beta_0$).  Squaring removes the sign of these parameter estimates.\n- This sum is multiplied by $\\lambda$, a hyperparameter in Ridge regression.  Lambda allows us to tune the size of the penalty.\n- This is an application of the L2 norm (matrix algebra) to the vector of parameter estimates\n\n-----\n\n$\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\n::: {.callout-important}\n# Question\nWhat will happen to a Ridge regression model's parameter estimates and its performance (i.e., its bias & variance) as lambda increases/decreases?\n:::\n\n::: {.fragment .uwred}\nAs lambda increases, the model becomes less flexible b/c its parameter estimates \nbecome constrained/shrunk.  This will increase bias but decrease variance for model \nperformance.\n:::\n\n-----\n\n$\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\n::: {.callout-important}\n# Question\nWhat is the special case of Ridge regression when lambda = 0?\n:::\n\n::: {.fragment .uwred}\nThe OLS regression is a special case where lambda = 0 (i.e., no penalty is applied).  \n\nThis is the most flexible. It is unbiased but with higher variance than for non-zero values of lambda\n:::\n\n-----\n\nLets compare Ridge regression to OLS (ordinary least squares with squared loss cost function) linear regression\n\n- Ridge parameter estimates are biased but have lower variance (smaller SE) than OLS\n\n- Ridge may predict better in new data\n  - This depends on the value of $\\lambda$ selected and its impact on bias-variance trade-off in Ridge regression vs. OLS\n  - There does exist a value of $\\lambda$ for which Ridge predicts better than OLS in new data\n\n- Ridge regression (but not OLS) allows for p > (or even >>) than n\n\n- Ridge regression (but not OLS) accommodates highly correlated (or even perfectly multi-collinear) features \n\n- OLS (but not Ridge regression) is scale invariant\n  - You should scale (mean and standard deviation correct) features for use with Ridge regression\n\n-----\n\n$\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:])$\n\n::: {.callout-important}\n# Question\nWhy does the scale of the features matter for Ridge regression?\n:::\n\n::: {.fragment .uwred}\nFeatures with bigger SDs will have smaller parameter estimates.  Therefore they will be less affected by the penalty.\n\nUnless the features are on the same scale to start, you should standardize them for all applications (regression and classification) of Ridge (and also LASSO and elastic net).  You can handle this during feature engineering in the recipe.\n:::\n\n-----\n\n## LASSO Regression\n\nLASSO is an acronym for Least Absolute Shrinkage and Selection Operator\n\nThe cost function for LASSO Regression is:\n\n- $\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda\\sum_{j = 1}^{p} |\\beta_j|\\:])$\n\nIt has two components:\n\n- Inside the left brackets is the SSE from linear regression\n- Inside the right brackets is the **LASSO penalty**.  \n\nThis penalty:\n\n- Includes the sum of the absolute value of the parameter estimates (excluding $\\beta_0$).  The absolute value removes the sign of these parameter estimates.\n\n- This sum is multiplied by $\\lambda$, a hyperparameter in LASSO regression.  Lambda allows us to tune the size of the penalty.\n\n- This is an application of the L1 norm to the vector of parameter estimates\n\n-----\n\n### LASSO vs. Ridge Comparison\n\nWith respect to the parameter estimates: \n\n- LASSO yields sparse solution (some parameter estimates set to **exactly zero**)\n\n- Ridge tends to retain all features (parameter estimates don't get set to exactly zero)\n\n- LASSO selects one feature among correlated group and sets others to zero\n\n- Ridge shrinks all parameter estimates for correlated features \n\nRidge tends to outperform LASSO wrt prediction in new data.  There are cases where LASSO can predict better (most features have zero effect and only a few are non-zero) but even in those cases, Ridge is competitive.  \n\n-----\n\n### Advantages of LASSO\n\n- Does feature selection (sets parameter estimates to exactly 0)\n  - Yields a sparse solution\n  - Sparse model is more interpretable?\n  - Sparse model is easier to implement? (fewer features included so donâ€™t need to measure as many predictors)\n\n- More robust to outliers (similar to LAD vs. OLS)\n\n- Tends to do better when there are a small number of robust features and the others are close to zero or zero\n\n-----\n\n### Advantages of Ridge\n\n- Computationally superior (closed form solution vs. iterative;  Only one solution to minimize the cost function)\n\n- More robust to measurement error in features (remember no measurement error is an assumption for unbiased estimates in OLS regression)\n\n- Tends to do better when there are many features with large (and comparable) effects (i.e., most features are related to the outcome)\n\n-----\n\n## Elastic Net Regression\n\nThe Elastic Net blends the L1 and L2 penalties to obtain the benefits of each of those approaches.\n\nWe will use the implementation of the Elastic Net in [glmnet](https://cran.r-project.org/web/packages/glmnet/glmnet.pdf) in R.  \n\nYou can also read additional [introductory documentation](https://cran.r-project.org/web/packages/glmnet/vignettes/glmnet.pdf) for this package\n\n-----\n\nIn the Gaussian regression context, the Elastic Net cost function is:\n\n- $\\frac{1}{n}([\\sum_{i = 1}^{n} (Y_i - \\hat{Y_i})^{2}] + [\\:\\lambda (\\alpha\\sum_{j = 1}^{p} |\\beta_j| + (1-\\alpha)\\sum_{j = 1}^{p} \\beta_j^{2})\\:])$\n\nThis model has two hyper-parameters\n\n- $\\lambda$ controls the degree of regularization as before\n- $\\alpha$ is a \"mixing\" parameter that blends the degree of L1 and L2 contributions to the aggregate penalty. (Proportion of LASSO penalty)\n  - $\\alpha$ = 1 results in the LASSO model\n  - $\\alpha$ = 0 results in the Ridge model\n  - Intermediate values for $\\alpha$ blend these penalties together proportionally to include more or less LASSO penalty\n\n-----\n\nAs before (e.g., KNN), best values of $\\lambda$ (and $\\alpha$) can be selected using resampling using `tune_grid()`\n\nThe grid needs to have crossed values of both `penalty` ($lambda$) and `mixture` ($alpha$) for glmnet\n\n  - Can use `expand_grid()`\n  - Only penalty is needed in grid if fitting a Ridge or LASSO model.\n\n-----\n\n\n## Empirical Example 1: Many \"good\" but correlated predictors\n\n```{r}\n#| include: false\n\n# set up environment.  Now hidden from view\n\n\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\noptions(conflicts.policy = \"depends.ok\")\n\nlibrary(xfun, include.only = \"cache_rds\")\n\n# parallel processing\nlibrary(future)\nplan(multisession, workers = parallel::detectCores(logical = FALSE))\n\nsource(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\nsource(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\nsource(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\npath_data <- \"./data\"\n\nrerun_setting <- TRUE \n``` \n\nFor the first example, we will simulate data with:\n\n- Many correlated predictors\n- All related to outcome\n- Get a small training sample\n- Get a big test sample (for more precise estimate of model performance)\n\n-----\n\nFirst we set the predictors for our simulation\n```{r}\nn_cases_trn <- 100\nn_cases_test <- 1000\nn_x <- 20\ncovs_x <- 50\nvars_x <- 100\nb_x <- rep(1, n_x) # one unit change in y for 1 unit change in x\ny_error <- 100\n```\n\n-----\n\nThen we draw samples from population\n```{r}\nset.seed(12345)\nmu <- rep(0, n_x)  # means for all variables = 0\nsigma <- matrix(covs_x, nrow = n_x, ncol = n_x)\ndiag(sigma) <- vars_x  \nsigma\n\nx <- MASS::mvrnorm(n = n_cases_trn, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble()\ndata_trn_1 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_trn, 0, y_error)) |>  \n  glimpse()\n\nx <- MASS::mvrnorm(n = n_cases_test, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble() \ndata_test_1 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_test, 0, y_error))\n```\n\n-----\n\nSet up a tibble to track model performance in train and test sets\n\n- We are using test to repeatedly to get rigorous held-out performance separate from model selection process.  \n- Just for our understanding \n- We would not choose a model configuration based on test set error\n\n```{r}\nerror_ex1 <- tibble(model = character(), \n                    rmse_trn = numeric(), \n                    rmse_test = numeric()) |> \n  glimpse()\n```\n\n-----\n\n### Fit a standard (OLS) linear regression\n\nFit the linear model\n\n- No feature engineering needed. Can use raw predictors as features\n- No resampling needed b/c there are no hyperparameters\n\n```{r}\nfit_lm_1 <- \n  linear_reg() |> \n  set_engine(\"lm\") |> \n  fit(y ~ ., data = data_trn_1)\n\nfit_lm_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Overfit to train\n- Much worse in test\n\n```{r}\nrmse_vec(truth = data_trn_1$y, \n         estimate = predict(fit_lm_1, data_trn_1)$.pred)\n```\n\n\n```{r}\nrmse_vec(truth = data_test_1$y, \n         estimate = predict(fit_lm_1, data_test_1)$.pred)\n```\n\n\n```{r}\n#| echo: false\n\nerror_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"linear model\",                       \n                   rmse_trn = rmse_vec(truth = data_trn_1$y, \n                                       estimate = predict(fit_lm_1, data_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = data_test_1$y, \n                                        estimate = predict(fit_lm_1, data_test_1)$.pred)))\n```\n\n-----\n\n### Fit LASSO\n\nLASSO, Ridge, and glmnet all need features on same scale to apply penalty consistently\n\n- Use `step_normalize()`.  This sets mean = 0, sd = 1 (NOTE: Bad name as it does NOT change shape of distribution!)\n- Can use same recipe for LASSO, Ridge, and glmnet\n- Can use same train and test feature matrices as well\n  \n```{r}\nrec_1 <- recipe(y ~ ., data = data_trn_1) |> \n  step_normalize(all_predictors())\n\nrec_prep_1 <- rec_1 |> \n  prep(data_trn_1)\n\nfeat_trn_1 <- rec_prep_1 |> \n  bake(NULL)\n\nfeat_test_1 <- rec_prep_1 |> \n  bake(data_test_1)\n```\n\n-----\n\nSet up splits for resampling for tuning hyperparameters\n\n- Use bootstrap for more precise estimation (even if more biased).  Good for selection\n- Can use same bootstrap splits for LASSO, Ridge, and glmnet\n```{r}\nset.seed(20140102)\nsplits_boot_1 <- data_trn_1 |> \n   bootstraps(times = 100, strata = \"y\")  \n```\n\n-----\n\nNow onto the LASSO....\n\nWe need to tune $\\lambda$ (tidymodels calls this `penalty`)\n\n- $\\alpha$ = 1 (tidymodels calls this `mixture`)\n- Set up grid with exponential values for `penalty`\n- `glmnet` uses warm starts so can fit lots of values for $\\lambda$ quickly\n- Could also use `cv.glmnet()` directly in `glmnet` package to find good values.  See `get_lamdas()` in fun_modeling.R\n\n```{r}\ngrid_lasso <- expand_grid(penalty = exp(seq(-4, 4, length.out = 100)))\n```\n\n```{r}\nfits_lasso_1 <- xfun::cache_rds(\n  expr = {\n  linear_reg(penalty = tune(), \n               mixture = 1) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_1, \n              resamples = splits_boot_1, \n              grid = grid_lasso, \n              metrics = metric_set(rmse))\n\n   },\n   rerun = rerun_setting,\n   dir = \"cache/006/\",\n   file = \"fits_lasso_1\")\n```\n\n-----\n\nEvaluate model performance in validation sets (OOB)\n\nMake sure that you have hit a clear minimum (bottom of U or at least an asymptote)\n\n```{r}\nplot_hyperparameters(fits_lasso_1, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best configuration (i.e., best lambda) to full train set\n\n- Use `select_best()`\n- Don't forget to indicate which column ($penalty$)\n\n```{r}\nfit_lasso_1 <-\n  linear_reg(penalty = select_best(fits_lasso_1)$penalty, \n             mixture = 1) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_1)\n```\n\n-----\n\nWe can now use `tidy()` to look at the LASSO parameter estimates\n\n- `tidy()`  uses `Matrix` package, which has conflicts with `tidyr`.  Load the package without those conflicting functions\n\n```{r}\nlibrary(Matrix, exclude = c(\"expand\", \"pack\", \"unpack\"))\n```\n\n-----\n\nNow call `tidy()`\n\n- Notice that LASSO sets some $\\beta$ to 0 even though none are 0 in DGP\n- LASSO is not great at reproducing the DGP!\n```{r}\nfit_lasso_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Somewhat better in test \n```{r}\n(error_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"LASSO model\",                       \n                   rmse_trn = rmse_vec(truth = feat_trn_1$y, \n                                       estimate = predict(fit_lasso_1,\n                                                          feat_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_1$y, \n                                        estimate = predict(fit_lasso_1,\n                                                           feat_test_1)$.pred))))\n```\n\n-----\n\n### Fit Ridge\n\nFit Ridge algorithm\n\n- Tune $\\lambda$ (`penalty`)\n- May need to experiment to get right range of values for lambda\n- $\\alpha$ = 0 (`mixture`)\n- Evaluate model configurations in OOB validation sets\n\n```{r}\ngrid_ridge <- expand_grid(penalty = exp(seq(-1, 7, length.out = 100)))\n```\n\n```{r}\ngrid_ridge <- expand_grid(penalty = exp(seq(-1, 7, length.out = 100)))\n```\n\n```{r}\nfits_ridge_1 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = 0) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_1, \n              resamples = splits_boot_1, \n              grid = grid_ridge, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_ridge_1\")\n```\n\n-----\n\nReview hyperparameter plot\n```{r}\nplot_hyperparameters(fits_ridge_1, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best model configuration (i.e., best lambda) in full train set\n\n- Notice that no $\\beta$ are exactly 0\n- [Why are parameter estimates not near 1 for LASSO and Ridge?]{.red}\n```{r}\nfit_ridge_1 <-\n  linear_reg(penalty = select_best(fits_ridge_1)$penalty, \n             mixture = 0) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_1)\n\nfit_ridge_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Much less overfit to train\n- Still not bad in test \n```{r}\n(error_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"Ridge model\",   \n                   rmse_trn = rmse_vec(truth = feat_trn_1$y, \n                                       estimate = predict(fit_ridge_1,\n                                                          feat_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_1$y, \n                                        estimate = predict(fit_ridge_1,\n                                                           feat_test_1)$.pred))))\n```\n\n-----\n\n### Fit glmnet\n\nNow we need to tune both\n\n- $\\lambda$ (`penalty`)\n- $\\alpha$ (`mixture`)\n- Typical to only evaluate a small number of $alpha$\n- Warm starts across $\\lambda$\n\n```{r}\ngrid_glmnet <- expand_grid(penalty = exp(seq(-1, 7, length.out = 100)),\n                           mixture = seq(0, 1, length.out = 6))\n```\n\n```{r}\nfits_glmnet_1 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_1, \n              resamples = splits_boot_1, \n              grid = grid_glmnet, \n              metrics = metric_set(rmse))\n  \n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_glmnet_1\")\n```\n\n-----\n\n```{r}\nplot_hyperparameters(fits_glmnet_1, hp1 = \"penalty\", hp2 = \"mixture\", metric = \"rmse\")\n```\n\n-----\n\nFit best configuration in full train set\n\n- Can use `select_best()` for both hyperparameters, separately\n- Ridge was best (but cool that glmnet could determine that empirically!)\n```{r}\nselect_best(fits_glmnet_1)\n\nfit_glmnet_1 <-\n  linear_reg(penalty = select_best(fits_glmnet_1)$penalty, \n             mixture = select_best(fits_glmnet_1)$mixture) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_1)\n```\n\n-----\n\n```{r}\nfit_glmnet_1 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nA final comparison of training and test error for the four statistical algorithms\n```{r}\n(error_ex1 <- error_ex1 |> \n  bind_rows(tibble(model = \"glmnet model\",   \n                   rmse_trn = rmse_vec(truth = feat_trn_1$y, \n                                       estimate = predict(fit_glmnet_1,\n                                                          feat_trn_1)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_1$y, \n                                        estimate = predict(fit_glmnet_1,\n                                                           feat_test_1)$.pred))))\n```\n\n\n-----\n\n## Empirical Example 2: Good and Zero Predictors\n\nFor the second example, we will simulate data with:\n\n- Two sets of correlated predictors\n- First (smaller) set related to outcome (5 predictors)\n- Second (larger) set unrelated to outcome (15 predictors)\n- Get a small training sample\n- Get a big test sample (for more precise estimates of performance of our model configurations)\n\n-----\n\nSet up simulation parameters \n```{r}\nn_cases_trn <- 100\nn_cases_test <- 1000\nn_x <- 20\ncovs_x <- 50 \nvars_x <- 100\nb_x <- c(rep(1,5),rep(0, 15))\ny_error <- 100\n```\n\n-----\n\n```{r}\nmu <- rep(0, n_x)  \n\nsigma <- matrix(0, nrow = n_x, ncol = n_x)\nfor (i in 1:(n_x/2)){\n  for(j in 1:(n_x/2)){\n    sigma[i, j] <- covs_x\n  }\n} \nfor (i in (n_x/2 + 1):n_x){\n  for(j in (n_x/2 + 1):n_x){\n    sigma[i, j] <- covs_x\n  }\n} \n\ndiag(sigma) <- vars_x  \n```\n\n-----\n\nSimulate predictors and Y\n```{r}\nset.seed(2468)\n\nx <- MASS::mvrnorm(n = n_cases_trn, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble()\ndata_trn_2 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_trn, 0, y_error)) |>  \n  glimpse()\n\nx <- MASS::mvrnorm(n = n_cases_test, mu, sigma) |> \n  magrittr::set_colnames(str_c(\"x_\", 1:n_x)) |>\n  as_tibble()\ndata_test_2 <- x |> \n  mutate(y = rowSums(t(t(x)*b_x)) + rnorm(n_cases_test, 0, y_error)) |>  \n  glimpse()\n```\n\n-----\n\nSet up a tibble to track model performance in train and test\n```{r}\nerror_ex2 <- tibble(model = character(), rmse_trn = numeric(), rmse_test = numeric()) |> \n  glimpse()\n```\n\n-----\n\n### Fit a standard (OLS) linear regression\n\nFit and evaluate the linear model\n```{r}\nfit_lm_2 <- \n  linear_reg() |> \n  set_engine(\"lm\") |> \n  fit(y ~ ., data = data_trn_2)\n\nfit_lm_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Very overfit to train\n- Very poor performance in test \n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"linear model\",                       \n                   rmse_trn = rmse_vec(truth = data_trn_2$y, \n                                       estimate = predict(fit_lm_2,\n                                                          data_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = data_test_2$y, \n                                        estimate = predict(fit_lm_2,\n                                                           data_test_2)$.pred))))\n```\n\n-----\n\n### Fit LASSO\n\nFor all glmnet algorithms, set up:\n\n- Recipe\n- Feature matrices\n- Bootstraps for model configuration selection (tuning)\n```{r}\nrec_2 <- recipe(y ~ ., data = data_trn_2) |> \n  step_normalize(all_predictors())\n\nrec_prep_2 <- rec_2 |> \n  prep(data_trn_2)\n\nfeat_trn_2 <- rec_prep_2 |> \n  bake(NULL)\n\nfeat_test_2 <- rec_prep_2 |> \n  bake(data_test_2)\n\nset.seed(20140102)\nsplits_boot_2 <- data_trn_2 |> \n   bootstraps(times = 100, strata = \"y\") \n```\n\n-----\n\nTune $\\lambda$ for LASSO\n\n- We can use sample penalty grids from earlier example because sample size and number of features hasnt changed so likely still good\n\n```{r}\nfits_lasso_2 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = 1) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_2, \n              resamples = splits_boot_2, \n              grid = grid_lasso, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_lasso_2\")\n```\n\n-----\n\nPlot hyperparameters\n```{r}\nplot_hyperparameters(fits_lasso_2, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best LASSO to full training set\n\n- Notice the many $\\beta$ = 0\n- It did set some of the \"good\" features to 0 as well\n```{r}\nfit_lasso_2 <-\n  linear_reg(penalty = select_best(fits_lasso_2, metric = \"rmse\")$penalty, \n             mixture = 1) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_2)\n\nfit_lasso_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Good in val\n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"LASSO model\",                       \n                   rmse_trn = rmse_vec(truth = feat_trn_2$y, \n                                       estimate = predict(fit_lasso_2,\n                                                          feat_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_2$y, \n                                        estimate = predict(fit_lasso_2,\n                                                           feat_test_2)$.pred))))\n```\n\n-----\n\n### Fit Ridge\n\nTune $\\lambda$ for Ridge\n\n- can use ridge penalty grid from example 1\n\n```{r}\nfits_ridge_2 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = 0) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_2, \n              resamples = splits_boot_2, \n              grid = grid_ridge, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_ridge_2\")\n```\n\n-----\n\nPlot hyperparameters\n```{r}\nplot_hyperparameters(fits_ridge_2, hp1 = \"penalty\", metric = \"rmse\")\n```\n\n-----\n\nFit best Ridge to full training set\n\n- Notice no $\\beta$ = 0\n```{r}\nfit_ridge_2 <-\n  linear_reg(penalty = select_best(fits_ridge_2, metric = \"rmse\")$penalty, \n             mixture = 0) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_2)\n\nfit_ridge_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Still slightly better than LASSO in test (but maybe equivalent?)\n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"Ridge model\",                       \n                   rmse_trn = rmse_vec(truth = feat_trn_2$y, \n                                       estimate = predict(fit_ridge_2,\n                                                          feat_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_2$y, \n                                        estimate = predict(fit_ridge_2,\n                                                           feat_test_2)$.pred))))\n```\n\n-----\n\n### Fit Complete glmnet\n\nTune $\\lambda$ and $\\alpha$ for glmnet\n\n\n```{r}\nfits_glmnet_2 <- xfun::cache_rds(\n  expr = {\n    linear_reg(penalty = tune(), \n               mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_2, \n              resamples = splits_boot_2, \n              grid = grid_glmnet, \n              metrics = metric_set(rmse))\n\n  },\n  rerun = rerun_setting,\n  dir = \"cache/006/\",\n  file = \"fits_glmnet_2\")\n```\n\n-----\n\nPlot hyperparameters\n```{r}\nplot_hyperparameters(fits_glmnet_2, hp1 = \"penalty\", hp2 = \"mixture\", metric = \"rmse\")\n```\n\n-----\n\nFit best glmnet in full train set\n\n- Still Ridge (but won't always be)\n```{r}\nselect_best(fits_glmnet_2, metric = \"rmse\")\n\nfit_glmnet_2 <-\n  linear_reg(penalty = select_best(fits_glmnet_2, metric = \"rmse\")$penalty, \n             mixture = select_best(fits_glmnet_2, metric = \"rmse\")$mixture) |>\n  set_engine(\"glmnet\") |> \n  fit(y ~ ., data = feat_trn_2)\n\nfit_glmnet_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n-----\n\nIrreducible error was set by `y_error` (`r y_error`)\n\n- Somewhat overfit to train\n- Still not bad in validate\n```{r}\n(error_ex2 <- error_ex2 |> \n  bind_rows(tibble(model = \"glmnet model\",   \n                   rmse_trn = rmse_vec(truth = feat_trn_2$y, \n                                       estimate = predict(fit_glmnet_2,\n                                                          feat_trn_2)$.pred),\n                   rmse_test = rmse_vec(truth = feat_test_2$y, \n                                        estimate = predict(fit_glmnet_2,\n                                                           feat_test_2)$.pred))))\n```\n\n-----\n\n## LASSO for Feature (e.g., Covariate) Selection?\n\nLets consider a typical explanatory setting in Psychology\n\n- A focal dichotomous IV (your experimental manipulation)\n- A number of covariates (some good, some bad)\n- A quantitative outcome (y)\n- Covariates are uncorrelated with IV b/c IV is manipulated\n\nLet's pretend the previous 20 `x`s were your covariates\n\n-----\n\nWhat are your options to test `iv` prior to this course?\n\n- You want to use covariates to increase power \n\n- BUT you don't know which covariates to use\n\n  - You might use all of them\n\n  - Or you might use none of them (a clear lost opportunity)\n\n  - Or you might hack it by using those increase your focal IV effect (very bad!)\n  \n-----\n\n\nNOW, We might use the feature selection characteristics for LASSO to select which covariates are included\n\nThere are two possibilities that occur to me\n\n-----\n\n1.  Use LASSO to build best DGP for a covariates only model\n\n- Could be more conservative (fewer covariates) by using within 1 SE of best performance but less flexible (i.e., will set more parameter estimates to 0)\n- Follow up with a linear model (using $lm$), regressing y on $iv$ and covariates from LASSO that are non-zero\n\n```{r}\nfit_lasso_2 |> \n  tidy() |> \n  print(n = 21)\n```\n\n- You clearly improved your best guess on covariates to include \n- You will regress y on `iv` and the 7 covariates with non-zero effects\n\n-----\n\n2. Use LASSO to build best DGP including `iv` and covariates but don't penalize `iv`\n\n- Look at `penalty.factor = rep(1, nvars)` argument in `glmnet()`\n- Can fit LASSO with unbiased? estimate of `iv`\n- Need to bootstrap for SE for `iv` (next unit)\n- Only appropriate if IV is manipulated\n\nShould really conduct simulation study of both of these options (vs. all and no covariates).  \n\n- I want to\n- Want to do the study with me?\n\n-----\n\n## Ridge, LASSO, and Elastic net models for other Y distributions\n\nThese penalties can be added to the cost functions of other generalized linear models to yield regularized/penalized versions of those models as well.  For example\n\nL1 penalized (LASSO) logistic regression (w/ labels coded 0,1):\n\n- $\\frac{1}{n}([\\:\\sum_{i = 1}^{n} -Y_ilog(\\hat{Y_i}) - (1-Y_i)log(1-\\hat{Y_i})\\:]\\:+\\:[\\:\\lambda\\sum_{j = 1}^{p} |\\beta_j|\\:]$\n\nFor L2 penalized (Ridge) logistic regression (w/ labels coded 0,1)\n\n- $\\frac{1}{n}([\\:\\sum_{i = 1}^{n} -Y_ilog(\\hat{Y_i}) - (1-Y_i)log(1-\\hat{Y_i})\\:]\\:+\\:[\\:\\lambda\\sum_{j = 1}^{p} \\beta_j^{2}\\:]$\n\n`glmnet` implements: \n\n- `family = c(\"gaussian\", \"binomial\", \"poisson\", \"multinomial\", \"cox\", \"mgaussian\")`\n- Full range of $\\alpha$ to mix two types of penalties"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"css":["book.css"],"output-file":"l06_regularization.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","bibliography":["refs.bib"],"callout-icon":false,"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}