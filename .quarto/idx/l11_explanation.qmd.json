{"title":"Explanatory Approaches","markdown":{"yaml":{"editor_options":{"chunk_output_type":"console"}},"headingText":"Explanatory Approaches","containsRefs":false,"markdown":"\n\n::: {.content-visible unless-format=\"revealjs\"}\n:::\n::: {.content-visible when-format=\"revealjs\"}\n# IAML Unit 11: Explanatory Approaches \n:::\n\n\n## Learning Objectives\n\n- Use of feature ablation to statisticall compare model configurations\n  - Frequentist correlated t-test using CV\n  - Bayesian estimation for model comparisons\n    - ROPE\n\n- Feature importance metrics for explanation\n  - Model specific vs. model agnostic approaches\n  - Permutation feature importance\n  - Shapley values (SHAP)\n    - local importance\n    - global importance\n\n- Visual approaches for explanation\n  - Partial Dependence plots\n  - Accumulated Local Effects (ALE) plots\n \n--------------------------------------------------------------------------------\n\n## Model Comparisons & Feature Ablation\n\nIn 610/710, you learned to think about the tests of specific parameter estimates as model comparisons of models that did vs. did not include the specific feature(s) in the model\n\nModel comparisons can be used in a similar way for explanatory goals with machine learning\n\n--------------------------------------------------------------------------------\n\nThis can be done for a single feature (e.g., $x_3$)\n\n  - compact model:  $y = b_0 + b_1*x_1 + b_2*x_2$\n  - full (augmented) model: $y = b_0 + b_1*x_1 + b_2*x_2 + b_3*x_3$\n  - The comparison of these two models is equivalent to the test of $H_0: b_3 = 0$\n\nThis can also involve sets of features if you hypothesis involves the effect of a set of features\n\n  - All features that represent a categorical predictor\n  - Set of features that represent some broad construct (e.g., psychiatric illness represented by symptoms counts for all of the major psychiatric diagnoses)\n  \nThis technique of comparing two nested models (i.e. feature set for the compact model is a subset of the feature set for the full/augmented model) is often called **feature ablation** in the machine learning world\n\n--------------------------------------------------------------------------------\n\nModel comparisons can also be done between model configurations that differ by characteristics other than their features (e.g., statistical algorithm)\n\nModel comparisons can be useful to determine the best available model configuration to use for a prediction goal\n\n- In some instances, it is OK to simply choose the descriptively better performing model configuration (e.g., better validation set or resampled performance estimate)\n- However, if the descriptively better performing model has other disadvantages (e.g., more costly to implement) you might want to only use it if you had rigorously demonstrated that it likely better for all new data.\n\n--------------------------------------------------------------------------------\n\nIn this unit, we will learn two approaches to statistically compare models\n\n- Traditional frequentist (NHST) approach using a variant of the t-test to accommodate correlated observations\n- A Bayesian alternative to the t-test\n\nWe will compare model nested model configurations formed by feature ablation (i.e., full and compact models will differ by features included)\n\nHowever, nothing would be different when implementing these comparison methods if these model configurations different by other characteristics such as statistical algorithm\n\n---\n\n## An Empirical Example of Feature Ablation\n\nThe context for our example will be the Cleveland heart disease dataset\n\nWe will imagine we have developed a new diagnostic screener for heart disease based on an exercise test protocol\n\nWe want to demonstrate the incremental improvement in our screening for heart disease using features from this test vs. other readily available characteristics about the patients\n\n--------------------------------------------------------------------------------\n\nOur exercise test protocol yields four scores ($exer\\_*$) that we use in combination to predict the probability of heart disease in the patient\n\n- Max heart rate during the exercise test\n- Experience of angina during the test\n- Slope of the peak exercise ST segment (don't ask me what that is!  ;-)\n- ST depression induced by exercise test relative to rest\n\nWe also have many other demographic and physical characteristics that we want to \"control\" for when evaluating the performance of our test\n\n- I use control in both its senses.  It likely helps to have these covariates b/c they reduce error in the outcome\n- I also want to demonstrate that our test has incremental predictive validity above these other characteristics which are already available for screening without my complicated test\n\n--------------------------------------------------------------------------------\n\n```{r}\n#| include: false\n\n# set up environment.  Now hidden from view\n\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\noptions(conflicts.policy = \"depends.ok\")\n\nlibrary(xfun, include.only = \"cache_rds\")\n\ncl <- parallel::makePSOCKcluster(parallel::detectCores(logical = FALSE))\ndoParallel::registerDoParallel(cl)\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\npath_data <- \"./data\"\n\nrerun_setting <- FALSE \n``` \n\nLet's open the data set and do some basic cleaning\n\n- Note there were some complex issues to deal with\n- Good examples of code to resolve those issues\n```{r}\ndata_all <- read_csv(here::here(path_data, \"cleveland.csv\"), col_names = FALSE, \n                     na = \"?\", col_types = cols()) |> \n  rename(age = X1,\n         sex = X2,\n         cp = X3,\n         rest_bp = X4,\n         chol = X5,\n         fbs = X6,\n         rest_ecg = X7,\n         exer_max_hr = X8,\n         exer_ang = X9,\n         exer_st_depress = X10,\n         exer_st_slope = X11,\n         ca = X12,\n         thal = X13,\n         disease = X14) |> \n  mutate(disease = fct(if_else(disease == 0, \"no\", \"yes\"),\n                       levels = c(\"yes\", \"no\")), # pos event first\n         sex = fct(if_else(sex == 0, \"female\", \"male\"), \n                   levels = c(\"female\", \"male\")),\n         fbs = fct(if_else(fbs == 0, \"normal\", \"elevated\"),\n                   levels = c(\"normal\", \"elevated\")),\n         exer_ang = fct(if_else(exer_ang == 0, \"no\", \"yes\"),\n                           levels = c(\"no\", \"yes\")),\n         exer_st_slope = fct_recode(as.character(exer_st_slope), \n                                       upslope = \"1\", \n                                       flat = \"2\",\n                                       downslope = \"3\"),\n         cp = fct_recode(as.character(cp), \n                            typ_ang = \"1\", \n                            atyp_ang = \"2\", \n                            non_anginal = \"3\", \n                            non_anginal = \"4\"),\n         rest_ecg = fct_recode(as.character(rest_ecg), \n                                  normal = \"0\", \n                                  wave_abn = \"1\", \n                                  ventric_hypertrophy = \"2\"),\n         thal = fct_recode(as.character(thal), \n                              normal = \"3\", \n                              fixeddefect = \"6\", \n                              reversabledefect = \"7\"))  \n```\n\n--------------------------------------------------------------------------------\n\nSkim it to make sure we didnt break anything during our cleaning!\n\n```{r}\ndata_all |> skim_some()\n```\n\n--------------------------------------------------------------------------------\n\nThe dataset is not that large and we have a decent number of features so we will build models using regularized logistic regression (glmnet)\n\nIt would be better to actually do some exploration to build the best compact model first but we will skip that part of the analysis here\n\n-------------------------------------------------------------------------------- \n\nWe are using glmnet so we need to find the optimal set of hyperparameter values for this model configuration\n\nLet's select/tune hyperparameters using 10 repeats of 10-fold CV (more on why this many in a few moments) \n\n```{r}\nset.seed(123456)\nsplits <- data_all |> \n  vfold_cv(v = 10, repeats = 10, strata = \"disease\")\n```\n\nAnd here is a grid of hyperparameters to tune\n```{r}\ngrid_glmnet <- expand_grid(penalty = exp(seq(-8, 2, length.out = 300)),\n                           mixture = c(0, .025, .05, .1, .2, .4, .6, .8, 1))\n```\n\n--------------------------------------------------------------------------------\n\nHere is a feature engineering recipe for the full model with all features that is appropriate for glmnet\n\n```{r}\nrec_full <- recipe(disease ~ ., data = data_all) |> \n  step_impute_median(all_numeric_predictors()) |> \n  step_impute_mode(all_nominal_predictors()) |>   \n  step_dummy(all_nominal_predictors()) |> \n  step_normalize(all_predictors())\n```\n\n--------------------------------------------------------------------------------\n\nNow we tune the model configuration\n```{r}\nfits_full <- cache_rds(\n  expr = {\n    logistic_reg(penalty = tune(),\n                 mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_full,\n              resamples = splits,\n              grid = grid_glmnet,\n              metrics = metric_set(accuracy))\n  },\n  rerun = rerun_setting,\n  dir = \"cache/011/\",\n  file = \"fits_full\")\n```\n\n--------------------------------------------------------------------------------\n\nLet's check how the models perform (k-fold resampled accuracy) with various values for the hyperparameters\n\nHere is accuracy by log penalty (lambda) and mixture (alpha)\n\n```{r}\nfits_full |> \n  plot_hyperparameters(hp1 = \"penalty\", hp2 = \"mixture\", \n                       metric = \"accuracy\", log_hp1 = TRUE)\n```\n\n--------------------------------------------------------------------------------\n\n::: {.callout-important}\n# Question: Does the glmnet (regularized logistic regresssion) outperform a simple logistic regression?  How would these two algorithms compare?\n:::\n\n::: {.fragment .uwred}\nRemember that the linear model is a special case of glmnet where the penalty = 0.  \n\nHere we are looking log penalty down to exp(-8) = 0.0003354626.  That is pretty close to 0 so an approximation of how the standard logistic regression would perform.  glmnet is slightly more accurate with its optimal hyperparameter values\n:::\n\n--------------------------------------------------------------------------------\n\nHere we show the mean performance of the top 10 configurations\n\nWe use these performance estimates to select the top optimal values for the hyperparameters\n\nWe will choose the hyperparameter values from the configuration displayed in the first row of this table\n```{r}\ncollect_metrics(fits_full) |> \n  arrange(desc(mean)) |> \n  print(n = 10)\n```\n\n--------------------------------------------------------------------------------\n\nHere we are storing that best configuration in an object so that we could later fit that configuration to the full dataset\n\n```{r}\n(hp_best_full <- select_best(fits_full))\n```\n\n--------------------------------------------------------------------------------\n\n::: {.callout-important}\n# Question: Tell me about bias if we use this mean performance from the 100 held-out folds as an estimate of how well that model fit to the full N will perform \n:::\n\n::: {.fragment .uwred}\nThere is some optimization bias in this performance estimate because we already used these 100 held-out folds to select the best configuration.  This will be a second use of those folds.  This will lead us to over-estimate the models true performance in new data.  We would need a test set to remove this bias.\n\nThere is also some bias because we are using less that the full sample (k-1 folds) to estimate performance of a model that will eventually have N unique observations across all k folds.  This will lead  us to underestimate the true performance of our model in new data. \n:::\n\n--------------------------------------------------------------------------------\n\nWhen we (eventually) compare the full and compact models, the presence of some bias may not be as important (and there will always be some bias anyway, because of the latter concern from the last slide).\n\nWe are focused on a relative comparison in performance across the two models so what is most important is that the bias is comparable for our assessments of the two models.\n\nIf we use validation data (e.g., our 100 held-out folds), there will be comparable optimization bias for both models so this may not be too problematic.  We don't need test data.\n\n--------------------------------------------------------------------------------\n\nBut before we go further, we need to have a compact model to compare to our full model\n\nHere is a recipe to feature engineer features associated with this compact model\n\n- We can start with the full recipe and add one more step to remove (i.e., ablate) the features we want to evaluate\n- `step_rm(contains(\"exer_\")`\n- All previous recipe steps remain the same\n\n```{r}\nrec_compact <- rec_full |> \n  step_rm(contains(\"exer_\"))\n```\n\n--------------------------------------------------------------------------------\n\nWe need to select/tune hyperparameters for this new model\n\nIt has different complexity than the full model so it might need different (less?) regularization for optimal performance\n\n```{r}\nfits_compact <- cache_rds(\n  expr = {\n    logistic_reg(penalty = tune(),\n                 mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_compact,   # use recipe for compact model\n              resamples = splits,\n              grid = grid_glmnet,\n              metrics = metric_set(accuracy))\n  },\n  rerun = rerun_setting,\n  dir = \"cache/011/\",\n  file = \"fits_compact\")\n```\n\n--------------------------------------------------------------------------------\n\nConfirm that we found a good set of hyperparameters\n```{r}\nfits_compact |> \n  plot_hyperparameters(hp1 = \"penalty\", hp2 = \"mixture\", metric = \"accuracy\", \n                       log_hp1 = TRUE)\n```\n\n--------------------------------------------------------------------------------\n\nAnd here is our best configuration, for when we want to train the compact model on all the data at a later stage\n```{r}\n(hp_best_compact <- select_best(fits_compact))\n```\n\n--------------------------------------------------------------------------------\n\nNow, here are accuracies for these two models assessed by 10 repeats of 10-fold\n\n- This is the mean performance for the best configuration\n- These means are based on 100 individual held-out folds\n```{r}\ncollect_metrics(fits_full) |> \n  arrange(desc(mean)) |> \n  slice(1)\n\ncollect_metrics(fits_compact) |> \n  arrange(desc(mean)) |> \n  slice(1)\n```\n\n--------------------------------------------------------------------------------\n\nThe compact model is less accurate but.....\n\n- A simple descriptive comparison is not sufficient to justify the use of a costly test\n- We need to be more confident that the test really improves screening in all possible held out samples from our dataset\n- And by how much?\n- How can we compare these two models?\n\n--------------------------------------------------------------------------------\n\n## Nadeau and Bengio (2003) Correlated t-test\n\nWe have 100 held-out accuracies for each model.\n\nCould we compare these?\n\nWell, we have the same 100 held-out samples (we used the same splits) for both compact and full models so these two sets of accuracies (for each of the two models) should be considered paired/repeated.   \n\n  - Not a problem, we could use paired samples t-test\n  - Easiest to think about this paired test as testing if the differences in accuracy for each of the 100 held out sets == 0.  That removes the lack of independence from using the sample 100 held-out sets twice\n  \n--------------------------------------------------------------------------------\n  \nBUT these 100 differences are still not independent\n\n- Each have been estimated using models that were fit with overlapping observations (the held in sets were fit with many of the same observations for each of the k-1 held in folds)\n- If we ignore this violation and simply do a paired-samples t-test, we will have inflation of alpha\n\n--------------------------------------------------------------------------------\n\n@Nadeau2003 ([see pdf](pdfs/nadeauC2003.pdf)) and @Bouckaert2003 ([see pdf](pdfs/bouckaertR2003.pdf)) have explored the degree of dependence among performance estimates using resampling.   \n\nThis was originally done for repeated random train/test splits (e.g., 90/10 splits) but is now also used when doing repeated k-fold.\n\nThe classic paired t-test has the following formula\n\n$t = \\frac{\\overline{x} - 0}{\\sqrt{\\hat{\\sigma^2}*\\frac{1}{n}}}$\n\nThe standard error for the difference (denominator of the t-statistic formula) is too small\n\n--------------------------------------------------------------------------------\n\nNadeau and Benigo adjusted it by $\\frac{\\rho}{1-\\rho}$ where $\\rho = \\frac{n_{test}}{n_{total}}$ or equivalent $\\frac{1}{k}$\n\nThis adjustment yields:\n\n$t = \\frac{\\overline{x} - 0}{\\sqrt{\\hat{\\sigma^2}*(\\frac{1}{n} + \\frac{\\rho}{1-\\rho})}}$\n\n--------------------------------------------------------------------------------\n\nLet's perform this correlated t-test to compare our compact and full models\n\nWe first need to extract the 100 held-out folds from `fits_full` and `fits_compact`\n\nWhen we have used `collect_metrics()` in the past, we always used the default for summarize (which is TRUE).  This gave us average performance for each model configuration across all the held-out folds.  But the individual folds for each configuration are in that object too\n\n----\n\nOur best model configuration for the full model was\n```{r}\nhp_best_full\n\nhp_best_full$.config\n```\n\nWe can see that label assigned to that specific configuration in the `.config` column.  We can use that to pull out the 100 folds for that configuration\n\n```{r}\ncv_full <- collect_metrics(fits_full, summarize = FALSE) |> \n  filter(.config == hp_best_full$.config) |> \n  pull(.estimate)\n\ncv_full |> print()\n```\n\n--------------------------------------------------------------------------------\n\nAnd lets get the 100 folds for the compact model\n\n```{r}\nhp_best_compact\n\nhp_best_compact$.config\n```\n\n```{r}\ncv_compact <- collect_metrics(fits_compact, summarize = FALSE) |> \n  filter(.config == hp_best_compact$.config) |> \n  pull(.estimate)\n\ncv_full |> print()\n```\n\nNOTE: It is important that these are the SAME splits for both model configurations\n\n--------------------------------------------------------------------------------\n\nNow we can compare these 100 folds across the two models using the correlated t-test\n\nDefine a function for Nadeau and Bengio (2003) correlated t-test\n```{r}\n# included in fun_ml.R\nnb_correlated_t_test <- function(cv_full, cv_compact, k = 10){\n\n    diffs <- cv_full - cv_compact\n    n <- length(diffs)\n    mean_diff <- mean(diffs)\n    var_diffs <- var(diffs)\n    proportion_test <- 1 / k\n    proportion_train <- 1 - proportion_test\n    correction <- (1 / n) + (proportion_test / proportion_train)\n    se = sqrt(correction * var_diffs)\n\n    t = abs(mean_diff/se)\n    p_value <- 2 * pt(t, n - 1, lower.tail = FALSE)\n    tibble(mean_diff = mean_diff, se = se, t = t, df = n - 1, p_value = p_value)\n}\n```\n\n-------------------------------------------------------------------------------- \n\nCalculate the t-test.  \n\nIn this instance we likely want a one-tailed test (though of course, that should have been planned in advanced and ideally pre-registered!).   \n\nMy function returns a two-tailed p-value so we should cut it in half.\n```{r}\nnb_correlated_t_test(cv_full, \n                     cv_compact, \n                     k = 10)\n```\n\nThe improvement in prediction accuracy associated with the use of our exercise test protocol is not significant (p = 0.11, one-tailed).\n\n--------------------------------------------------------------------------------\n\n## Bayesian estimation for model comparisons\n\n@Benavoli2017 critique the many shortcomings wrt the frequentist approach, and I must admit, I am mostly convinced\n\n- NHST does not provide the probabilities of the null and alternative hypotheses.   \n  - That is what we want\n  - NHST gives us the probability of our data given the null\n- NHST focuses on a point-wise comparison (no difference) that is almost never true.\n- NHST yields no information about the null hypothesis (i.e., when we fail to reject)\n- The inference depends on the sampling and testing intention (think about Bonferonni correction)\n\n--------------------------------------------------------------------------------\n\nThey suggest to use Bayesian parameter estimation as alternative to the t-test.  Bayesian estimation has now been included in tidymodels in the `tidyposterior` package using the `perf_mod()` function.  \n\nYou can (and should!) read more about this implementation of Bayesian Estimation in the associated [vignette](https://tidyposterior.tidymodels.org/articles/Getting_Started.html) AND by reading the help materials on `perf_mod()`\n\n--------------------------------------------------------------------------------  \n\nUsing this approach, we will estimate the posterior probability for values associated with specific parameters of interest.  For our goals, we will care about estimates of three parameters\n\n- The accuracy of the full model\n- The accuracy of the compact model\n- The difference in accuracies between these two models.\n\n--------------------------------------------------------------------------------\n\nWe want to determine the posterior probabilities associated with ranges of values for each of these three model performance parameters estimates.   We can then use these posterior probability distributions to determine that probability that the accuracy of the full model is greater than the accuracy of the compact model.  \n\nIn addition, we can also determine if the increased accuracy of the full model is meaningful (i.e., practically important).\n\nTo accomplish this latter goal, we will: \n\n- Specify a Region of Practical Equivalence (a better alternative to the point-wise null in NHST)\n  - I will define classifiers whose performance are within +-1% as equivalent (not meaningfully different from each other) for our example   \n  - Not worth the effort if my test doesn't improve screening accuracy by at least this\n\n-------------------------------------------------------------------------------- \n\nTo estimate posterior probabilities for these three parameter estimates, we need to \n\n- set prior probabilities for these parameter estimates.  These should be broad/uninformative in most instances unless you have substantial prior information about credible values.  \n- Collect data on these estimates.  This will be the same as before - the 100 estimates of accuracy using 10x10 fold CV for both the full and compact models.\n\nUsing these priors and these data, we can derive the posterior probabilities for our three performance estimates\n\n-------------------------------------------------------------------------------- \n\nLets do this step by step.  We will use the `tidyposterior` package.  It in not included when we load `tidymodels` so we will load it now\n\n```{r}\nlibrary(tidyposterior)\n```\n\n--------------------------------------------------------------------------------\n\nWe need to make a dataframe of our 100 performance estimates for the full and compact models.  Here is the code to do this using our previous resamples of our models\n\n- Make dataframes of the accuracies from the full model and the compact model\n```{r}\naccuracy_full <- collect_metrics(fits_full, summarize = FALSE) |> \n  filter(.config == hp_best_full$.config) |>   # as before - the best config\n  select(id, id2, full = .estimate) |> \n  print()\n```\n\n```{r}\naccuracy_compact <- collect_metrics(fits_compact, summarize = FALSE) |> \n  filter(.config == hp_best_compact$.config) |>   # as before - the best config\n  select(id, id2, compact = .estimate) |> \n  print()\n```\n\n--------------------------------------------------------------------------------\n\nNow we need to join these dataframes, matching on repeat and fold ids\n\n```{r}\nresamples <- accuracy_full |> \n  full_join(accuracy_compact, by = c(\"id\", \"id2\")) |> \n  print()\n```\n\n--------------------------------------------------------------------------------\n\nNow we can use `perf_mod()` to derive the posterior probabilites for the accuracy of each of these two models\n\n- We need to specify a model with parameters in formula.  Here we indicate that we have a multi-level model with repeated observation of accuracy across folds (id2) nested within repeats (id).  This handles dependence associated with repeated observations of accuracy using similar models in k-fold cv.\n\n- We are interested in the intercept from this model listed in formula.  The intercept value will represent the accuracy estimate for each model.\n\n- The default for `perf_mod()` will be to constrain the variances of the intercept parameter estimate to be the same across models.  This may be fine for some performance metrics (e.g., rmse) but for binary accuracy the variance is dependent on the mean.  Therefore we allow these variances to be different using `hetero_var = TRUE`\n\n- In some instances (e..g., rmse), we may want to allow the errors in our model to be something other than Gaussian (though this is often a reasonable assumption by the central limit theorem).  You can change the `family` for the errors if needed.  See vignette and help on `perf_mod()`.  Here, we use the default Gaussian distribution.\n\n- This is an iterative process using a Markov chain Monte Carlo method (Hamilton Monte Carlo) so we need to set a seed (for reproducibility), and the number of iterations and chains (beyond the scope of this course to dive into this method).  I provide default values for `iter` and `chains` because you may need to increase these in some instances for the method to converge on valid values.  You can often address converge and other warnings by increasing `iter`, `chains` or `adapt_delta`.  You can read more about these warnings and issues [here](https://mc-stan.org/misc/warnings.html), [here](https://mc-stan.org/rstanarm/reference/adapt_delta.html#:~:text=For%20the%20No%2DU%2DTurn,not%20set%20to%20%22sampling%22%20.), [here](https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup), and [here](http://singmann.org/hierarchical-mpt-in-stan-i-dealing-with-convergent-transitions-via-control-arguments/) to start.\n\n--------------------------------------------------------------------------------\n\nHere is the code\n```{r}\nset.seed(101)\npp <- cache_rds(\n  expr = {\n    perf_mod(resamples, \n            formula = statistic ~ model + (1 | id2/id),\n            # defaults but may require increases\n            iter = 2000, chains = 4,  \n            # for more Gaussian distribution of accuracy\n            transform = tidyposterior::logit_trans,\n            hetero_var = TRUE, # for accuracy\n            family = gaussian, # default but could change depending on DV\n            # increase adapt_delta (e.g., .99, .999) to \n            # fix divergent transitions\n            adapt_delta = .99)  \n  },\nrerun = rerun_setting,\ndir = \"cache/011/\",\nfile = \"pp\")\n```\n\n--------------------------------------------------------------------------------\n\nIn contrast to the NHST approach, we now have what we really want - posterior probabilities. Lets look at them\n\nWe can view the posterior probability distributions using an autoplot method for perf_mod objects. \n\n- These density plots tell how probable various values are for the accuracy of each model\n\n- The probabilities associated with any region of the curve is equal to the area under that curve for that region.  This will tell you the probability associated with that range of values for accuracy.\n\n- You can easily see in this instance that the probable values for accuracy are higher generally for full model than the compact model\n\n```{r}\npp |> autoplot()\n```\n\n--------------------------------------------------------------------------------\n\nYou will likely want to publish a figure showing these posterior probability distributions so you may want to fine tune the plots.  Here are some code options using ggplot\n\nHere is the same density plots using ggplot so you can now edit to adjust as you like\n```{r}\npp |> \n  tidy(seed = 123) |> \n  mutate(model = fct_inorder(model)) |>\n  ggplot() + \n  geom_density(aes(x = posterior, color = model) )\n```\n\n--------------------------------------------------------------------------------\n\nWe are actually sampling from the posterior distribution so it might make more sense to display these as histograms rather than density plots\n\n```{r}\npp |> \n  tidy(seed = 123) |> \n  mutate(model = fct_inorder(model)) |>\n  ggplot() + \n  geom_histogram(aes(x = posterior, fill = model), color = \"white\", alpha = 0.4,\n                 bins = 50, position = \"identity\") \n```\n\n--------------------------------------------------------------------------------\n\nOr maybe you want to facet the histograms if the overlap is difficulty to view\n```{r}\npp |> \n  tidy(seed = 123) |> \n  mutate(model = fct_inorder(model)) |>\n  ggplot(aes(x = posterior)) + \n  geom_histogram(color = \"white\", fill = \"blue\", bins = 30) + \n  facet_wrap(~ model, ncol = 1)\n```\n\n--------------------------------------------------------------------------------\n\nWe can also calculate the 95% Higher Density Intervals (aka, 95% Credible Intervals; the Bayesian alternative to the 95% Confidence Intervals) for the accuracy of each model.  This is the range of parameter estimate values that include 95% of the credible values.  Kruschke described this in the [assigned reading](pdfs/pkruschke2018a.pdf.pdf).\n```{r}\npp |> tidy(seed = 123) |> summary()\n```\n\n--------------------------------------------------------------------------------\n\nBut what we really want is derive the posterior probability for the difference in accuracy between the two models.  This will let us determine credible values for the magnitude of the difference and determine if this difference is meaningful.\n\nWe said early that we would define a ROPE of +-.01 around zero.  The models are only meaningful different if their accuracies differ by at least 1%\n\nLets visualize the posterior probability distribution for the difference along with this ROPE using the built in autoplot function\n\n\n```{r}\npp |> contrast_models(seed = 4) |> autoplot(size = .01)\n```\n\n--------------------------------------------------------------------------------\n\nWe could make more pretty plots directly in ggplot\n\n```{r}\npp |> \n  contrast_models(seed = 4) |> \n  ggplot() +\n  geom_density(aes(x = difference), color = \"blue\")+\n  geom_vline(aes(xintercept = -.01), linetype = \"dashed\") + \n  geom_vline(aes(xintercept = .01), linetype = \"dashed\")\n```\n\nor my preferred histogram\n```{r}\npp |> \n  contrast_models(seed = 4) |> \n  ggplot(aes(x = difference)) + \n  geom_histogram(bins = 50, color = \"white\", fill = \"blue\")+\n  geom_vline(aes(xintercept = -.01), linetype = \"dashed\") + \n  geom_vline(aes(xintercept = .01), linetype = \"dashed\")\n```\n\n--------------------------------------------------------------------------------\n\nBut perhaps most important, lets calculate the probability that the full model is more accurate than the compact model\n\n- The mean increase in accuracy is in the `mean`column\n- The 95% HDI is given by lower and  upper \n- The probability that the full model is meaningfully higher than the compact model (i.e., what proportion of the credible values are above the ROPE) is in the `prac_pos` column.\n\n```{r}\npp |> contrast_models(seed = 4) |> summary(size = .01)\n```\n\nAlternatively, using the approach proposed by Kruschke (2018), you can conclude that the full model is meaningfully better than the compact model if the 95% HDI is fully above the ROPE. This is also true!\n\n--------------------------------------------------------------------------------\n\nFinally, in some instances, you may not want to use the ROPE.   \n\n- Instead, you may simply want the posterior probability that the full model performs better than the compact model.   \n- This is probability is provided in the `probability` column of the table.\n- You can also set the size of the ROPE to 0 (though  not necessary)\n\n\n```{r}\npp |> contrast_models(seed = 4) |> summary(size = 0)\n```\n\n--------------------------------------------------------------------------------\n\n## Feature Importance\n\nThere as been increasing focus on improving the interpretability of machine learning models that we are using.  \n\nThere are numerous reasons to want to better understand why our models make the predictions that they do.  \n\n- The growing set of tools to interpret our models can help address our **explanatory questions**\n- But they can also help us **find errors** in our models\n- And they can **detect possible bias** (we will focus explicitly on algorithmic bias in later units)\n\n--------------------------------------------------------------------------------\n\nFeature importance metrics are an important tool to better understand how our models work.\n\nThese metrics help us understand which features in our models contribute most to the predictions that the model makes.  \n\nFor some models, interpretation and identification of important features is easy.  \n\nFor example, if we standardize the features in a glm or glmnet model, we can interpret the absolute magnitude of the parameter estimates (i.e., the coefficients) as an index of the global (i.e., across all observations) importance of each feature.  \n\n- You can use the [vip]() package to extract these **model-specific** feature importance metrics, but you can often just get them directly from the model as well\n- More info on the use of vip package is available [elsewhere](https://cran.r-project.org/web/packages/vip/vignettes/vip.html)\n\n--------------------------------------------------------------------------------\n\nBut for other models, we need different approaches.  \n\nThere are many **model-agnostic** (i.e., can be used across all statistical algorithms) approaches to quantify the importance of a feature, but we will focus on two:  \n\n- Permutation Feature Importance\n- Shapley Values\n\n--------------------------------------------------------------------------------\n\nWe follow [recommendations from the tidymodels folks](https://www.tmwr.org/explain) and use the DALEX and DALEXtra packages for model agnostic approaches to feature importance.\n\n```{r}\nlibrary(DALEX, exclude= \"explain\")\nlibrary(DALEXtra)\n```\n\n--------------------------------------------------------------------------------\n\nLets first get some coding issues accomplished before we dig into the details of the two feature importance metrics\n\nTo calculate these importance metrics, we will need access to the raw features and outcome.\n\n```{r}\nrec_full_prep <- rec_full |> \n  prep(data_all)\n\nfeat_full <-  rec_full_prep |> \n  bake(data_all)\n```\n\n--------------------------------------------------------------------------------\n\nAnd we now will need to fit the full model trained on all the data\n\n```{r}\nfit_full <- \n  logistic_reg(penalty = hp_best_full$penalty,\n               mixture = hp_best_full$mixture) |> \n  set_engine(\"glmnet\") |> \n  fit(disease ~ ., data = feat_full)\n```\n\n--------------------------------------------------------------------------------\n\nWe will need to have a df for the features (without the outcome) and a separate vector for the outcome\n\n- features are easy.  Just select out the outcome\n\n```{r}\nx <- feat_full |> select(-disease)\n```\n\n- For outcome, we need to convert to 0/1 (if classification), and then pull the vector out of the dataframe\n\n```{r}\ny <- feat_full |> \n  mutate(disease = if_else(disease == \"yes\", 1, 0)) |> \n  pull(disease)\n```\n\n--------------------------------------------------------------------------------\n\nWe also need a specific predictor function that will work with the DALEX package\n\nWe will write a custom function that \"wraps\" around our tidymodels `predict()` function\n\nDALEX needs:\n\n- the prediction function to have two parameters named `model` and `newdata` \n- the prediction function must return a vector of probabilites for the positive class for classification problems (for regression, it simply returns a vector of the predicted values for $y$)\n\n```{r}\npredict_wrapper <- function(model, newdata) {\n  predict(model, newdata, type = \"prob\") |> \n    pull(.pred_yes)\n}\n```\n\n--------------------------------------------------------------------------------\n\nWe will also need an `explainer` object based on our model and data\n\nThe `explain_tidymodels()` function in DALEXtra will create (and check) this object for us.\n\n```{r}\nexplain_full <- explain_tidymodels(fit_full, # our model object \n                                   data = x, # df with features without outcome\n                                   y = y, # outcome vector\n                                   # our custom predictor function\n                                   predict_function = predict_wrapper)\n```\n\n--------------------------------------------------------------------------------\n\nFinally, we need to define a custom function for our performance metric as well\n\n- It needs to have two parameters: `observed` and `predicted`\n- We can create a wrapper function around `accuracy_vec()` to fit these needs\n- For accuracy, we need to transform the predicted probabilites from our prediction function to class predictions (e.g.. yes/no)\n- And because we converted our labels to 0/1 in the outcome vector, we need to transform `observed` back to yes/no as well \n\n```{r}\naccuracy_wrapper <- function(observed, predicted) {\n  observed <- fct(if_else(observed == 1, \"yes\", \"no\"),\n                  levels = c(\"yes\", \"no\"))\n  predicted <- fct(if_else(predicted > .5, \"yes\", \"no\"), levels  = c(\"yes\", \"no\"))\n  accuracy_vec(observed, predicted)\n}\n```\n\nWe are now ready to calculate feature importance metrics\n\n--------------------------------------------------------------------------------\n\n### Permutation Feature Importance\n\nThe first model agnostic approach to calculating feature important is called Permutation Feature Importance\n\nThis approach is very straight forward.  This approach says - if we want to calculate the importance of any specific feature, we can compare our performance metric using the original features to the performance metric we get if we permute (i.e., shuffle) the values for the feature we are evaluating.  \n\nBy randomly shuffling the values for the feature, we break the relationship between that feature and the outcome so it no longer contributes to the predictions.   If performance doesn't change much, then that feature is not important.  If performance goes down a lot, the feature is important.  \n\n- The function can provide `raw` performance (will give us performance for the non-permuted model and then performance for the model with each feature permuted, one at a time) \n- `difference` performance measure, which is the difference between the permuted model and the non-permuted mode, separately for each feature\n- `ratio` performance measure, which is ($\\frac{permuted}{original}$), separately for each feature\n\n--------------------------------------------------------------------------------\n\nTo calculate accuracy after permuting each feature, we use `model_parts()`.  We pass in \n\n- our explainer object\n- set the type (`raw` in this example)\n- indicate our custom accuracy function\n- set B to indicate number of permutations to perform\n```{r}\nset.seed(123456)\nimp_permute <- model_parts(explain_full, \n                               type = \"raw\", \n                               loss_function = accuracy_wrapper,\n                               B = 100)\n```\n\n--------------------------------------------------------------------------------\n\nLets look at what this function returns\n\n- the first row contains the accuracy for the full model (with no features permuted)\n- last row is a baseline models (performance with all features permuted)\n- Other row show the accuracy of the model when that specific feature is permuted\n\n```{r}\nimp_permute\n```\n\n--------------------------------------------------------------------------------\n\nWe can use the built in plot function from DALEX to display this\n\n```{r}\nplot(imp_permute)\n```\n\n--------------------------------------------------------------------------------\n\nOr we can plot it directly.  Here is an example from the [tidymodels folks](https://www.tmwr.org/explain)    \n```{r}\n#| fig-height: 4\n\nfull_model <- imp_permute |>  \n    filter(variable == \"_full_model_\")\n  \nimp_permute |> \n  filter(variable != \"_full_model_\",\n         variable != \"_baseline_\") |> \n  mutate(variable = fct_reorder(variable, dropout_loss)) |> \n  ggplot(aes(dropout_loss, variable)) +\n  geom_vline(data = full_model, aes(xintercept = dropout_loss),\n             linewidth = 1.4, lty = 2, alpha = 0.7) +\n  geom_boxplot(fill = \"#91CBD765\", alpha = 0.4) +\n  theme(legend.position = \"none\") +\n  labs(x = \"accuracy\", \n       y = NULL,  fill = NULL,  color = NULL)\n```\n\n--------------------------------------------------------------------------------\n\nWe can also permute a set of features to quantify the contribution of the full set\n\nThis is what we would want for our example, were we want to know the contribution of the four features that represent our exercise test.\n\nTo do this, we pass in a list of vectors of the groups.  Here we provide just one group that we name `exer_test`\n```{r}\nset.seed(123456)\nimp_permute_group <- model_parts(explain_full, \n                               type = \"raw\", \n                               loss_function = accuracy_wrapper,\n                               B = 100,\n                               variable_groups = list(exer_test = \n                                                        c(\"exer_ang_yes\",\n                                                          \"exer_max_hr\",\n                                                          \"exer_st_depress\", \n                                                          \"exer_st_slope_downslope\")))\n```\n\n--------------------------------------------------------------------------------\n\nThe results show that permuting these four features as a set drops accuracy from 0.838 to 0.713\n```{r}\nimp_permute_group\n```\n\n--------------------------------------------------------------------------------\n\n### Shapley Values\n\nShapley values provide insight on the importance of any feature to the prediction for a single observation - often called **local importance** (vs. global importance as per the permutation feature importance measure above).\n\nShapley values can also be used to index global importance by averaging the local shapley values for a feature across all (or a random sample) of the observations.\n\n--------------------------------------------------------------------------------\n\nShapley values are derived from Coalition Game Theory.  \n\nThey provide the average marginal contribution to prediction (for a single observation) of a feature value across all possible coalitions of features (combinations of sets of features from the null set to all other features).\n\n@IML provides a [detailed account](https://christophm.github.io/interpretable-ml-book/shapley.html#shapley) of the theory behind these values and how they are calculated which I will not reproduce here.\n\n--------------------------------------------------------------------------------\n\nLets calculate Shapley Values for the first observation in our dataset\n\nTheir features values were\n```{r }\nobs_num <- 1\nx1 <- x |> \n  slice(obs_num) |> \n  glimpse()\n```\n\n--------------------------------------------------------------------------------\n\nAnd we can get Shapley values using `predict_parts()`\n```{r}\nsv <- predict_parts(explain_full, \n                    new_observation = x1,\n                    type = \"shap\",\n                    B = 25)\n```\n\n--------------------------------------------------------------------------------\n\nThere is a built in plot function for shap values\n\nFor this first observation\n\n- The values for each feature are listed in the left margin\n- Bars to the right (e.g., sex_male) indicate that their feature value increases their probability of disease\n- Bars to the left indicate that their feature value decreases their probability of disease  \n```{r}\nplot(sv)\n```\n\n--------------------------------------------------------------------------------\n\nWe can use these Shapley values for the local importance of the features for each observation to calculate the global importance of these features.  \n\nFeatures that have big absolute Shapley values on average across observation are more important.   Let's calculate this.\n\nFirst we need a function to get shapley values for each observation (along with the feature values for a nicer plot)\n\n```{r}\nget_shaps <- function(df1){\n  predict_parts(explain_full, \n                new_observation = df1,\n                type = \"shap\",\n                B = 25) |> \n    filter(B == 0) |> \n    select(variable_name, variable_value, contribution) |> \n    as_tibble()\n}\n```\n\n--------------------------------------------------------------------------------\n\nAnd then we can map this function over observations to get the Shapley values for each observation\n\n```{r}\n#| label: calc_global_shaps\n\nlocal_shaps <- cache_rds(\n  expr = {\n    x |>\n      slice_sample(prop = 1/5) |> # take random sample to reduce computation time\n      mutate(id = row_number()) |>\n      nest(.by = id, .key = \"dfs\") |>   # nest a dataframe for each observation\n      mutate(shaps = map(dfs, \\(df1) get_shaps(df1))) |> \n      select(-dfs) |>\n      unnest(shaps)\n  },\n  rerun = rerun_setting,\n  dir = \"cache/011/\",\n  file = \"local_shaps\")\n```\n\n--------------------------------------------------------------------------------\n\nHere is what we get from applying the function over observations\n\n```{r}\nlocal_shaps |> head()\n```\n\n**Programming note**:  This code demonstrates another nice R programming technique using `nest()` and `unnest()` in combination with `map()` and list-columns. For more info, see [this chapter](https://r4ds.had.co.nz/many-models.html) in @RDS and the vignette on nesting (`vignette(\"nest\")`).\n\n--------------------------------------------------------------------------------\n\nNow that we have Shapley values for all observations, we can calculate the mean absolute Shapley value across observations and plot it.\n\n- Across all observations, `ca` contributes to an average change of .06 from the mean predicted probability of disease.\n- One of the features from our exercise test, `exer_ang_yes`, contributes about .05 change from mean predicted probability of disease.\n- The other `exer_` features are not far behind.\n\n```{r}\n#| fig-height: 4\n\nlocal_shaps |>\n  mutate(contribution = abs(contribution)) |>\n  group_by(variable_name) |>\n  summarize(mean_shap = mean(contribution)) |>\n  arrange(desc(mean_shap)) |>\n  mutate(variable_name = factor(variable_name),\n         variable_name = fct_reorder(variable_name, mean_shap)) |>\n  ggplot(aes(x = variable_name, y = mean_shap)) +\n  geom_point() +\n  coord_flip()\n```\n\n--------------------------------------------------------------------------------\n\nFor a more advanced plot (a sina plot; not displayed here) we could superimpose the individual local Shapley values and color them based on the feature score.   \nThis would allow us to show the direction of the relationship between the Shapley values and feature values.  \n\nSee FIGURE 9.26 in @IML for an example of this type of plot.\n\n--------------------------------------------------------------------------------\n\nShapley values are attractive relative to other approaches because\n\n- They have a solid theoretical basis\n- Sound statistical properties (Efficiency, Symmetry, Dummy and Additivity - see @IML)\n- Can provided a unified perspective across both local and global importance.\n\n--------------------------------------------------------------------------------\n\nHowever, they can be VERY time consuming to calculate (particularly if you want to use them for global importance such that you need them for all/many observations).  \n\nThere are computational shortcuts available but even those can be very time consuming in some instances (though XGBoost has a very fast implementation that we use regularly).\n\n(Note that for decision tree based algorithms SHAP provides a more computationally efficient way to estimate Shapley values - see [section 9.6](https://christophm.github.io/interpretable-ml-book/shap.html) in @IML for more detail.)\n\n--------------------------------------------------------------------------------\n\n## Visual Approaches to Understand our Models\n\nWe can also learn about how our features are used to make predictions in our models using visual approaches.   \n\nThere are two key plots that we can use:\n\n- Partial Dependence (PD) Plots\n- Accumulated Local Effects (ALE) Plots\n\n--------------------------------------------------------------------------------\n\n### Partial Dependence (PD) Plots\n\nThe Partial dependence (PD) plot displays the marginal effect of a target feature or combination of features on the predictions from a model.  \n\nIn essence, the prediction for any value of a target feature is the average prediction across cases if we set all cases to have that value for the target feature but their observed values for all other features.\n\nWe can use PD plots to understand whether the relationship between a target feature and the outcome is linear, monotonic, or more complex.  It may also help us visualize and understand if interactions between features exist (if we make a PD plot for two target features).  \n\n--------------------------------------------------------------------------------\n\nThe PD Plot is attractive because \n\n- it is easy to understand (prediction for each feature value averaged across observed values for all other features)\n- if the target feature is uncorrelated with all other features, its interpretation is clear, it is how the average prediction changes as the target features changes values.\n- it is computationally easy to implement\n- it has a causal (for the model, not the real world!) interpretation. This is what happens to the predciction if we manipulate the values of the target feature but hold all other features constant at their observed values.\n\n--------------------------------------------------------------------------------\n\nHowever:\n\n- The assumption that the target feature is not correlated with the other features is likely unrealistic in many/most instances\n- This plot (but also other plot methods) are limited to 1 - 2 features in combination.\n- It may hide effects when interactions exist\n\n--------------------------------------------------------------------------------\n\n### Accumulated Local Effects (ALE) Plots\n\nIf the features are correlated, the partial dependence plot should not be used because the plots will otherwise be based on combinations of the target feature and other features that may never occur (given the feature correlations).\n\nMolnar describes how this problem of correlated features and unrealistic combinations of features can be solved by M-Plots that plot the average effect of a target feature using the conditional values on other features (i.e., only using realistic values for the other features based on their correlations with the target feature).  Unfortunately, this too is sub-optimal because it will confound the effect of the target feature with the effects of the other features that are correlated with it.\n\n--------------------------------------------------------------------------------\n\nAccumulated Local Effects (ALE) plots also use conditional values of other features to solve the correlated features problem.  However, ALE plots solve the confounding problem by calculating **differences** in predictions associated with changes in the target feature rather than average predictions for each value of that target feature. These differences hold the other features values (mostly) constant to remove their effects.  \n\nALE plots are the preferred plot in situations where  you expect your target feature to be correlated with other features (which is likely most situations.)\n\n--------------------------------------------------------------------------------\n\nWe will use the `DALEX` package again to make these PD and ALE plots.\n\nIt will require the explainer object we created earlier for feature importance\n\nOtherwise, the code is very straight-forward.  Here we get the predicted values for an ALE plot to examine the effect of one of the features from our exercise test (`exer_max_hr`) on disease probabilities. \n\nIf we wanted a PD plot, we could simply substitute `partial` for `accumulated`\n\n```{r}\nale <- model_profile(explainer = explain_full,\n                     type = \"accumulated\",\n                     variables = \"exer_max_hr\",\n                     N = NULL)  # to use full sample (default is 100)\n```\n\n--------------------------------------------------------------------------------\n\nThere is a default plot function for these plot object (or you could use the data in the object to make your own ggplot)\n\nThe probability of disease decreases as max hr increases in the exercise test\n```{r}\nale |> plot()\n```\n\n--------------------------------------------------------------------------------\n\n## Summary and Closing Thoughts\n\nWhen pursuing purely explanatory goals with machine learning methods, we can: \n\n- Use resampling with the full dataset to determine appropriate model configuration\n  - Best statistical algorithm\n  - Which covariates\n  - Other \"researcher degrees of freedom\" such as handling of outliers, transformations of predictors\n\n- Use model comparisons (Frequentist or Bayesian) in combination with feature ablation to test effect of feature or set of features\n\n- We can use feature importance measures (permutation or Shapley) to understand the contributions that various features make to prediction for an observation (local) or across observations (global)\n","srcMarkdownNoYaml":"\n\n::: {.content-visible unless-format=\"revealjs\"}\n# Explanatory Approaches \n:::\n::: {.content-visible when-format=\"revealjs\"}\n# IAML Unit 11: Explanatory Approaches \n:::\n\n\n## Learning Objectives\n\n- Use of feature ablation to statisticall compare model configurations\n  - Frequentist correlated t-test using CV\n  - Bayesian estimation for model comparisons\n    - ROPE\n\n- Feature importance metrics for explanation\n  - Model specific vs. model agnostic approaches\n  - Permutation feature importance\n  - Shapley values (SHAP)\n    - local importance\n    - global importance\n\n- Visual approaches for explanation\n  - Partial Dependence plots\n  - Accumulated Local Effects (ALE) plots\n \n--------------------------------------------------------------------------------\n\n## Model Comparisons & Feature Ablation\n\nIn 610/710, you learned to think about the tests of specific parameter estimates as model comparisons of models that did vs. did not include the specific feature(s) in the model\n\nModel comparisons can be used in a similar way for explanatory goals with machine learning\n\n--------------------------------------------------------------------------------\n\nThis can be done for a single feature (e.g., $x_3$)\n\n  - compact model:  $y = b_0 + b_1*x_1 + b_2*x_2$\n  - full (augmented) model: $y = b_0 + b_1*x_1 + b_2*x_2 + b_3*x_3$\n  - The comparison of these two models is equivalent to the test of $H_0: b_3 = 0$\n\nThis can also involve sets of features if you hypothesis involves the effect of a set of features\n\n  - All features that represent a categorical predictor\n  - Set of features that represent some broad construct (e.g., psychiatric illness represented by symptoms counts for all of the major psychiatric diagnoses)\n  \nThis technique of comparing two nested models (i.e. feature set for the compact model is a subset of the feature set for the full/augmented model) is often called **feature ablation** in the machine learning world\n\n--------------------------------------------------------------------------------\n\nModel comparisons can also be done between model configurations that differ by characteristics other than their features (e.g., statistical algorithm)\n\nModel comparisons can be useful to determine the best available model configuration to use for a prediction goal\n\n- In some instances, it is OK to simply choose the descriptively better performing model configuration (e.g., better validation set or resampled performance estimate)\n- However, if the descriptively better performing model has other disadvantages (e.g., more costly to implement) you might want to only use it if you had rigorously demonstrated that it likely better for all new data.\n\n--------------------------------------------------------------------------------\n\nIn this unit, we will learn two approaches to statistically compare models\n\n- Traditional frequentist (NHST) approach using a variant of the t-test to accommodate correlated observations\n- A Bayesian alternative to the t-test\n\nWe will compare model nested model configurations formed by feature ablation (i.e., full and compact models will differ by features included)\n\nHowever, nothing would be different when implementing these comparison methods if these model configurations different by other characteristics such as statistical algorithm\n\n---\n\n## An Empirical Example of Feature Ablation\n\nThe context for our example will be the Cleveland heart disease dataset\n\nWe will imagine we have developed a new diagnostic screener for heart disease based on an exercise test protocol\n\nWe want to demonstrate the incremental improvement in our screening for heart disease using features from this test vs. other readily available characteristics about the patients\n\n--------------------------------------------------------------------------------\n\nOur exercise test protocol yields four scores ($exer\\_*$) that we use in combination to predict the probability of heart disease in the patient\n\n- Max heart rate during the exercise test\n- Experience of angina during the test\n- Slope of the peak exercise ST segment (don't ask me what that is!  ;-)\n- ST depression induced by exercise test relative to rest\n\nWe also have many other demographic and physical characteristics that we want to \"control\" for when evaluating the performance of our test\n\n- I use control in both its senses.  It likely helps to have these covariates b/c they reduce error in the outcome\n- I also want to demonstrate that our test has incremental predictive validity above these other characteristics which are already available for screening without my complicated test\n\n--------------------------------------------------------------------------------\n\n```{r}\n#| include: false\n\n# set up environment.  Now hidden from view\n\nlibrary(tidyverse) # for general data wrangling\nlibrary(tidymodels) # for modeling\noptions(conflicts.policy = \"depends.ok\")\n\nlibrary(xfun, include.only = \"cache_rds\")\n\ncl <- parallel::makePSOCKcluster(parallel::detectCores(logical = FALSE))\ndoParallel::registerDoParallel(cl)\n\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\n\ntheme_set(theme_classic())\noptions(tibble.width = Inf)\npath_data <- \"./data\"\n\nrerun_setting <- FALSE \n``` \n\nLet's open the data set and do some basic cleaning\n\n- Note there were some complex issues to deal with\n- Good examples of code to resolve those issues\n```{r}\ndata_all <- read_csv(here::here(path_data, \"cleveland.csv\"), col_names = FALSE, \n                     na = \"?\", col_types = cols()) |> \n  rename(age = X1,\n         sex = X2,\n         cp = X3,\n         rest_bp = X4,\n         chol = X5,\n         fbs = X6,\n         rest_ecg = X7,\n         exer_max_hr = X8,\n         exer_ang = X9,\n         exer_st_depress = X10,\n         exer_st_slope = X11,\n         ca = X12,\n         thal = X13,\n         disease = X14) |> \n  mutate(disease = fct(if_else(disease == 0, \"no\", \"yes\"),\n                       levels = c(\"yes\", \"no\")), # pos event first\n         sex = fct(if_else(sex == 0, \"female\", \"male\"), \n                   levels = c(\"female\", \"male\")),\n         fbs = fct(if_else(fbs == 0, \"normal\", \"elevated\"),\n                   levels = c(\"normal\", \"elevated\")),\n         exer_ang = fct(if_else(exer_ang == 0, \"no\", \"yes\"),\n                           levels = c(\"no\", \"yes\")),\n         exer_st_slope = fct_recode(as.character(exer_st_slope), \n                                       upslope = \"1\", \n                                       flat = \"2\",\n                                       downslope = \"3\"),\n         cp = fct_recode(as.character(cp), \n                            typ_ang = \"1\", \n                            atyp_ang = \"2\", \n                            non_anginal = \"3\", \n                            non_anginal = \"4\"),\n         rest_ecg = fct_recode(as.character(rest_ecg), \n                                  normal = \"0\", \n                                  wave_abn = \"1\", \n                                  ventric_hypertrophy = \"2\"),\n         thal = fct_recode(as.character(thal), \n                              normal = \"3\", \n                              fixeddefect = \"6\", \n                              reversabledefect = \"7\"))  \n```\n\n--------------------------------------------------------------------------------\n\nSkim it to make sure we didnt break anything during our cleaning!\n\n```{r}\ndata_all |> skim_some()\n```\n\n--------------------------------------------------------------------------------\n\nThe dataset is not that large and we have a decent number of features so we will build models using regularized logistic regression (glmnet)\n\nIt would be better to actually do some exploration to build the best compact model first but we will skip that part of the analysis here\n\n-------------------------------------------------------------------------------- \n\nWe are using glmnet so we need to find the optimal set of hyperparameter values for this model configuration\n\nLet's select/tune hyperparameters using 10 repeats of 10-fold CV (more on why this many in a few moments) \n\n```{r}\nset.seed(123456)\nsplits <- data_all |> \n  vfold_cv(v = 10, repeats = 10, strata = \"disease\")\n```\n\nAnd here is a grid of hyperparameters to tune\n```{r}\ngrid_glmnet <- expand_grid(penalty = exp(seq(-8, 2, length.out = 300)),\n                           mixture = c(0, .025, .05, .1, .2, .4, .6, .8, 1))\n```\n\n--------------------------------------------------------------------------------\n\nHere is a feature engineering recipe for the full model with all features that is appropriate for glmnet\n\n```{r}\nrec_full <- recipe(disease ~ ., data = data_all) |> \n  step_impute_median(all_numeric_predictors()) |> \n  step_impute_mode(all_nominal_predictors()) |>   \n  step_dummy(all_nominal_predictors()) |> \n  step_normalize(all_predictors())\n```\n\n--------------------------------------------------------------------------------\n\nNow we tune the model configuration\n```{r}\nfits_full <- cache_rds(\n  expr = {\n    logistic_reg(penalty = tune(),\n                 mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_full,\n              resamples = splits,\n              grid = grid_glmnet,\n              metrics = metric_set(accuracy))\n  },\n  rerun = rerun_setting,\n  dir = \"cache/011/\",\n  file = \"fits_full\")\n```\n\n--------------------------------------------------------------------------------\n\nLet's check how the models perform (k-fold resampled accuracy) with various values for the hyperparameters\n\nHere is accuracy by log penalty (lambda) and mixture (alpha)\n\n```{r}\nfits_full |> \n  plot_hyperparameters(hp1 = \"penalty\", hp2 = \"mixture\", \n                       metric = \"accuracy\", log_hp1 = TRUE)\n```\n\n--------------------------------------------------------------------------------\n\n::: {.callout-important}\n# Question: Does the glmnet (regularized logistic regresssion) outperform a simple logistic regression?  How would these two algorithms compare?\n:::\n\n::: {.fragment .uwred}\nRemember that the linear model is a special case of glmnet where the penalty = 0.  \n\nHere we are looking log penalty down to exp(-8) = 0.0003354626.  That is pretty close to 0 so an approximation of how the standard logistic regression would perform.  glmnet is slightly more accurate with its optimal hyperparameter values\n:::\n\n--------------------------------------------------------------------------------\n\nHere we show the mean performance of the top 10 configurations\n\nWe use these performance estimates to select the top optimal values for the hyperparameters\n\nWe will choose the hyperparameter values from the configuration displayed in the first row of this table\n```{r}\ncollect_metrics(fits_full) |> \n  arrange(desc(mean)) |> \n  print(n = 10)\n```\n\n--------------------------------------------------------------------------------\n\nHere we are storing that best configuration in an object so that we could later fit that configuration to the full dataset\n\n```{r}\n(hp_best_full <- select_best(fits_full))\n```\n\n--------------------------------------------------------------------------------\n\n::: {.callout-important}\n# Question: Tell me about bias if we use this mean performance from the 100 held-out folds as an estimate of how well that model fit to the full N will perform \n:::\n\n::: {.fragment .uwred}\nThere is some optimization bias in this performance estimate because we already used these 100 held-out folds to select the best configuration.  This will be a second use of those folds.  This will lead us to over-estimate the models true performance in new data.  We would need a test set to remove this bias.\n\nThere is also some bias because we are using less that the full sample (k-1 folds) to estimate performance of a model that will eventually have N unique observations across all k folds.  This will lead  us to underestimate the true performance of our model in new data. \n:::\n\n--------------------------------------------------------------------------------\n\nWhen we (eventually) compare the full and compact models, the presence of some bias may not be as important (and there will always be some bias anyway, because of the latter concern from the last slide).\n\nWe are focused on a relative comparison in performance across the two models so what is most important is that the bias is comparable for our assessments of the two models.\n\nIf we use validation data (e.g., our 100 held-out folds), there will be comparable optimization bias for both models so this may not be too problematic.  We don't need test data.\n\n--------------------------------------------------------------------------------\n\nBut before we go further, we need to have a compact model to compare to our full model\n\nHere is a recipe to feature engineer features associated with this compact model\n\n- We can start with the full recipe and add one more step to remove (i.e., ablate) the features we want to evaluate\n- `step_rm(contains(\"exer_\")`\n- All previous recipe steps remain the same\n\n```{r}\nrec_compact <- rec_full |> \n  step_rm(contains(\"exer_\"))\n```\n\n--------------------------------------------------------------------------------\n\nWe need to select/tune hyperparameters for this new model\n\nIt has different complexity than the full model so it might need different (less?) regularization for optimal performance\n\n```{r}\nfits_compact <- cache_rds(\n  expr = {\n    logistic_reg(penalty = tune(),\n                 mixture = tune()) |> \n    set_engine(\"glmnet\") |> \n    tune_grid(preprocessor = rec_compact,   # use recipe for compact model\n              resamples = splits,\n              grid = grid_glmnet,\n              metrics = metric_set(accuracy))\n  },\n  rerun = rerun_setting,\n  dir = \"cache/011/\",\n  file = \"fits_compact\")\n```\n\n--------------------------------------------------------------------------------\n\nConfirm that we found a good set of hyperparameters\n```{r}\nfits_compact |> \n  plot_hyperparameters(hp1 = \"penalty\", hp2 = \"mixture\", metric = \"accuracy\", \n                       log_hp1 = TRUE)\n```\n\n--------------------------------------------------------------------------------\n\nAnd here is our best configuration, for when we want to train the compact model on all the data at a later stage\n```{r}\n(hp_best_compact <- select_best(fits_compact))\n```\n\n--------------------------------------------------------------------------------\n\nNow, here are accuracies for these two models assessed by 10 repeats of 10-fold\n\n- This is the mean performance for the best configuration\n- These means are based on 100 individual held-out folds\n```{r}\ncollect_metrics(fits_full) |> \n  arrange(desc(mean)) |> \n  slice(1)\n\ncollect_metrics(fits_compact) |> \n  arrange(desc(mean)) |> \n  slice(1)\n```\n\n--------------------------------------------------------------------------------\n\nThe compact model is less accurate but.....\n\n- A simple descriptive comparison is not sufficient to justify the use of a costly test\n- We need to be more confident that the test really improves screening in all possible held out samples from our dataset\n- And by how much?\n- How can we compare these two models?\n\n--------------------------------------------------------------------------------\n\n## Nadeau and Bengio (2003) Correlated t-test\n\nWe have 100 held-out accuracies for each model.\n\nCould we compare these?\n\nWell, we have the same 100 held-out samples (we used the same splits) for both compact and full models so these two sets of accuracies (for each of the two models) should be considered paired/repeated.   \n\n  - Not a problem, we could use paired samples t-test\n  - Easiest to think about this paired test as testing if the differences in accuracy for each of the 100 held out sets == 0.  That removes the lack of independence from using the sample 100 held-out sets twice\n  \n--------------------------------------------------------------------------------\n  \nBUT these 100 differences are still not independent\n\n- Each have been estimated using models that were fit with overlapping observations (the held in sets were fit with many of the same observations for each of the k-1 held in folds)\n- If we ignore this violation and simply do a paired-samples t-test, we will have inflation of alpha\n\n--------------------------------------------------------------------------------\n\n@Nadeau2003 ([see pdf](pdfs/nadeauC2003.pdf)) and @Bouckaert2003 ([see pdf](pdfs/bouckaertR2003.pdf)) have explored the degree of dependence among performance estimates using resampling.   \n\nThis was originally done for repeated random train/test splits (e.g., 90/10 splits) but is now also used when doing repeated k-fold.\n\nThe classic paired t-test has the following formula\n\n$t = \\frac{\\overline{x} - 0}{\\sqrt{\\hat{\\sigma^2}*\\frac{1}{n}}}$\n\nThe standard error for the difference (denominator of the t-statistic formula) is too small\n\n--------------------------------------------------------------------------------\n\nNadeau and Benigo adjusted it by $\\frac{\\rho}{1-\\rho}$ where $\\rho = \\frac{n_{test}}{n_{total}}$ or equivalent $\\frac{1}{k}$\n\nThis adjustment yields:\n\n$t = \\frac{\\overline{x} - 0}{\\sqrt{\\hat{\\sigma^2}*(\\frac{1}{n} + \\frac{\\rho}{1-\\rho})}}$\n\n--------------------------------------------------------------------------------\n\nLet's perform this correlated t-test to compare our compact and full models\n\nWe first need to extract the 100 held-out folds from `fits_full` and `fits_compact`\n\nWhen we have used `collect_metrics()` in the past, we always used the default for summarize (which is TRUE).  This gave us average performance for each model configuration across all the held-out folds.  But the individual folds for each configuration are in that object too\n\n----\n\nOur best model configuration for the full model was\n```{r}\nhp_best_full\n\nhp_best_full$.config\n```\n\nWe can see that label assigned to that specific configuration in the `.config` column.  We can use that to pull out the 100 folds for that configuration\n\n```{r}\ncv_full <- collect_metrics(fits_full, summarize = FALSE) |> \n  filter(.config == hp_best_full$.config) |> \n  pull(.estimate)\n\ncv_full |> print()\n```\n\n--------------------------------------------------------------------------------\n\nAnd lets get the 100 folds for the compact model\n\n```{r}\nhp_best_compact\n\nhp_best_compact$.config\n```\n\n```{r}\ncv_compact <- collect_metrics(fits_compact, summarize = FALSE) |> \n  filter(.config == hp_best_compact$.config) |> \n  pull(.estimate)\n\ncv_full |> print()\n```\n\nNOTE: It is important that these are the SAME splits for both model configurations\n\n--------------------------------------------------------------------------------\n\nNow we can compare these 100 folds across the two models using the correlated t-test\n\nDefine a function for Nadeau and Bengio (2003) correlated t-test\n```{r}\n# included in fun_ml.R\nnb_correlated_t_test <- function(cv_full, cv_compact, k = 10){\n\n    diffs <- cv_full - cv_compact\n    n <- length(diffs)\n    mean_diff <- mean(diffs)\n    var_diffs <- var(diffs)\n    proportion_test <- 1 / k\n    proportion_train <- 1 - proportion_test\n    correction <- (1 / n) + (proportion_test / proportion_train)\n    se = sqrt(correction * var_diffs)\n\n    t = abs(mean_diff/se)\n    p_value <- 2 * pt(t, n - 1, lower.tail = FALSE)\n    tibble(mean_diff = mean_diff, se = se, t = t, df = n - 1, p_value = p_value)\n}\n```\n\n-------------------------------------------------------------------------------- \n\nCalculate the t-test.  \n\nIn this instance we likely want a one-tailed test (though of course, that should have been planned in advanced and ideally pre-registered!).   \n\nMy function returns a two-tailed p-value so we should cut it in half.\n```{r}\nnb_correlated_t_test(cv_full, \n                     cv_compact, \n                     k = 10)\n```\n\nThe improvement in prediction accuracy associated with the use of our exercise test protocol is not significant (p = 0.11, one-tailed).\n\n--------------------------------------------------------------------------------\n\n## Bayesian estimation for model comparisons\n\n@Benavoli2017 critique the many shortcomings wrt the frequentist approach, and I must admit, I am mostly convinced\n\n- NHST does not provide the probabilities of the null and alternative hypotheses.   \n  - That is what we want\n  - NHST gives us the probability of our data given the null\n- NHST focuses on a point-wise comparison (no difference) that is almost never true.\n- NHST yields no information about the null hypothesis (i.e., when we fail to reject)\n- The inference depends on the sampling and testing intention (think about Bonferonni correction)\n\n--------------------------------------------------------------------------------\n\nThey suggest to use Bayesian parameter estimation as alternative to the t-test.  Bayesian estimation has now been included in tidymodels in the `tidyposterior` package using the `perf_mod()` function.  \n\nYou can (and should!) read more about this implementation of Bayesian Estimation in the associated [vignette](https://tidyposterior.tidymodels.org/articles/Getting_Started.html) AND by reading the help materials on `perf_mod()`\n\n--------------------------------------------------------------------------------  \n\nUsing this approach, we will estimate the posterior probability for values associated with specific parameters of interest.  For our goals, we will care about estimates of three parameters\n\n- The accuracy of the full model\n- The accuracy of the compact model\n- The difference in accuracies between these two models.\n\n--------------------------------------------------------------------------------\n\nWe want to determine the posterior probabilities associated with ranges of values for each of these three model performance parameters estimates.   We can then use these posterior probability distributions to determine that probability that the accuracy of the full model is greater than the accuracy of the compact model.  \n\nIn addition, we can also determine if the increased accuracy of the full model is meaningful (i.e., practically important).\n\nTo accomplish this latter goal, we will: \n\n- Specify a Region of Practical Equivalence (a better alternative to the point-wise null in NHST)\n  - I will define classifiers whose performance are within +-1% as equivalent (not meaningfully different from each other) for our example   \n  - Not worth the effort if my test doesn't improve screening accuracy by at least this\n\n-------------------------------------------------------------------------------- \n\nTo estimate posterior probabilities for these three parameter estimates, we need to \n\n- set prior probabilities for these parameter estimates.  These should be broad/uninformative in most instances unless you have substantial prior information about credible values.  \n- Collect data on these estimates.  This will be the same as before - the 100 estimates of accuracy using 10x10 fold CV for both the full and compact models.\n\nUsing these priors and these data, we can derive the posterior probabilities for our three performance estimates\n\n-------------------------------------------------------------------------------- \n\nLets do this step by step.  We will use the `tidyposterior` package.  It in not included when we load `tidymodels` so we will load it now\n\n```{r}\nlibrary(tidyposterior)\n```\n\n--------------------------------------------------------------------------------\n\nWe need to make a dataframe of our 100 performance estimates for the full and compact models.  Here is the code to do this using our previous resamples of our models\n\n- Make dataframes of the accuracies from the full model and the compact model\n```{r}\naccuracy_full <- collect_metrics(fits_full, summarize = FALSE) |> \n  filter(.config == hp_best_full$.config) |>   # as before - the best config\n  select(id, id2, full = .estimate) |> \n  print()\n```\n\n```{r}\naccuracy_compact <- collect_metrics(fits_compact, summarize = FALSE) |> \n  filter(.config == hp_best_compact$.config) |>   # as before - the best config\n  select(id, id2, compact = .estimate) |> \n  print()\n```\n\n--------------------------------------------------------------------------------\n\nNow we need to join these dataframes, matching on repeat and fold ids\n\n```{r}\nresamples <- accuracy_full |> \n  full_join(accuracy_compact, by = c(\"id\", \"id2\")) |> \n  print()\n```\n\n--------------------------------------------------------------------------------\n\nNow we can use `perf_mod()` to derive the posterior probabilites for the accuracy of each of these two models\n\n- We need to specify a model with parameters in formula.  Here we indicate that we have a multi-level model with repeated observation of accuracy across folds (id2) nested within repeats (id).  This handles dependence associated with repeated observations of accuracy using similar models in k-fold cv.\n\n- We are interested in the intercept from this model listed in formula.  The intercept value will represent the accuracy estimate for each model.\n\n- The default for `perf_mod()` will be to constrain the variances of the intercept parameter estimate to be the same across models.  This may be fine for some performance metrics (e.g., rmse) but for binary accuracy the variance is dependent on the mean.  Therefore we allow these variances to be different using `hetero_var = TRUE`\n\n- In some instances (e..g., rmse), we may want to allow the errors in our model to be something other than Gaussian (though this is often a reasonable assumption by the central limit theorem).  You can change the `family` for the errors if needed.  See vignette and help on `perf_mod()`.  Here, we use the default Gaussian distribution.\n\n- This is an iterative process using a Markov chain Monte Carlo method (Hamilton Monte Carlo) so we need to set a seed (for reproducibility), and the number of iterations and chains (beyond the scope of this course to dive into this method).  I provide default values for `iter` and `chains` because you may need to increase these in some instances for the method to converge on valid values.  You can often address converge and other warnings by increasing `iter`, `chains` or `adapt_delta`.  You can read more about these warnings and issues [here](https://mc-stan.org/misc/warnings.html), [here](https://mc-stan.org/rstanarm/reference/adapt_delta.html#:~:text=For%20the%20No%2DU%2DTurn,not%20set%20to%20%22sampling%22%20.), [here](https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup), and [here](http://singmann.org/hierarchical-mpt-in-stan-i-dealing-with-convergent-transitions-via-control-arguments/) to start.\n\n--------------------------------------------------------------------------------\n\nHere is the code\n```{r}\nset.seed(101)\npp <- cache_rds(\n  expr = {\n    perf_mod(resamples, \n            formula = statistic ~ model + (1 | id2/id),\n            # defaults but may require increases\n            iter = 2000, chains = 4,  \n            # for more Gaussian distribution of accuracy\n            transform = tidyposterior::logit_trans,\n            hetero_var = TRUE, # for accuracy\n            family = gaussian, # default but could change depending on DV\n            # increase adapt_delta (e.g., .99, .999) to \n            # fix divergent transitions\n            adapt_delta = .99)  \n  },\nrerun = rerun_setting,\ndir = \"cache/011/\",\nfile = \"pp\")\n```\n\n--------------------------------------------------------------------------------\n\nIn contrast to the NHST approach, we now have what we really want - posterior probabilities. Lets look at them\n\nWe can view the posterior probability distributions using an autoplot method for perf_mod objects. \n\n- These density plots tell how probable various values are for the accuracy of each model\n\n- The probabilities associated with any region of the curve is equal to the area under that curve for that region.  This will tell you the probability associated with that range of values for accuracy.\n\n- You can easily see in this instance that the probable values for accuracy are higher generally for full model than the compact model\n\n```{r}\npp |> autoplot()\n```\n\n--------------------------------------------------------------------------------\n\nYou will likely want to publish a figure showing these posterior probability distributions so you may want to fine tune the plots.  Here are some code options using ggplot\n\nHere is the same density plots using ggplot so you can now edit to adjust as you like\n```{r}\npp |> \n  tidy(seed = 123) |> \n  mutate(model = fct_inorder(model)) |>\n  ggplot() + \n  geom_density(aes(x = posterior, color = model) )\n```\n\n--------------------------------------------------------------------------------\n\nWe are actually sampling from the posterior distribution so it might make more sense to display these as histograms rather than density plots\n\n```{r}\npp |> \n  tidy(seed = 123) |> \n  mutate(model = fct_inorder(model)) |>\n  ggplot() + \n  geom_histogram(aes(x = posterior, fill = model), color = \"white\", alpha = 0.4,\n                 bins = 50, position = \"identity\") \n```\n\n--------------------------------------------------------------------------------\n\nOr maybe you want to facet the histograms if the overlap is difficulty to view\n```{r}\npp |> \n  tidy(seed = 123) |> \n  mutate(model = fct_inorder(model)) |>\n  ggplot(aes(x = posterior)) + \n  geom_histogram(color = \"white\", fill = \"blue\", bins = 30) + \n  facet_wrap(~ model, ncol = 1)\n```\n\n--------------------------------------------------------------------------------\n\nWe can also calculate the 95% Higher Density Intervals (aka, 95% Credible Intervals; the Bayesian alternative to the 95% Confidence Intervals) for the accuracy of each model.  This is the range of parameter estimate values that include 95% of the credible values.  Kruschke described this in the [assigned reading](pdfs/pkruschke2018a.pdf.pdf).\n```{r}\npp |> tidy(seed = 123) |> summary()\n```\n\n--------------------------------------------------------------------------------\n\nBut what we really want is derive the posterior probability for the difference in accuracy between the two models.  This will let us determine credible values for the magnitude of the difference and determine if this difference is meaningful.\n\nWe said early that we would define a ROPE of +-.01 around zero.  The models are only meaningful different if their accuracies differ by at least 1%\n\nLets visualize the posterior probability distribution for the difference along with this ROPE using the built in autoplot function\n\n\n```{r}\npp |> contrast_models(seed = 4) |> autoplot(size = .01)\n```\n\n--------------------------------------------------------------------------------\n\nWe could make more pretty plots directly in ggplot\n\n```{r}\npp |> \n  contrast_models(seed = 4) |> \n  ggplot() +\n  geom_density(aes(x = difference), color = \"blue\")+\n  geom_vline(aes(xintercept = -.01), linetype = \"dashed\") + \n  geom_vline(aes(xintercept = .01), linetype = \"dashed\")\n```\n\nor my preferred histogram\n```{r}\npp |> \n  contrast_models(seed = 4) |> \n  ggplot(aes(x = difference)) + \n  geom_histogram(bins = 50, color = \"white\", fill = \"blue\")+\n  geom_vline(aes(xintercept = -.01), linetype = \"dashed\") + \n  geom_vline(aes(xintercept = .01), linetype = \"dashed\")\n```\n\n--------------------------------------------------------------------------------\n\nBut perhaps most important, lets calculate the probability that the full model is more accurate than the compact model\n\n- The mean increase in accuracy is in the `mean`column\n- The 95% HDI is given by lower and  upper \n- The probability that the full model is meaningfully higher than the compact model (i.e., what proportion of the credible values are above the ROPE) is in the `prac_pos` column.\n\n```{r}\npp |> contrast_models(seed = 4) |> summary(size = .01)\n```\n\nAlternatively, using the approach proposed by Kruschke (2018), you can conclude that the full model is meaningfully better than the compact model if the 95% HDI is fully above the ROPE. This is also true!\n\n--------------------------------------------------------------------------------\n\nFinally, in some instances, you may not want to use the ROPE.   \n\n- Instead, you may simply want the posterior probability that the full model performs better than the compact model.   \n- This is probability is provided in the `probability` column of the table.\n- You can also set the size of the ROPE to 0 (though  not necessary)\n\n\n```{r}\npp |> contrast_models(seed = 4) |> summary(size = 0)\n```\n\n--------------------------------------------------------------------------------\n\n## Feature Importance\n\nThere as been increasing focus on improving the interpretability of machine learning models that we are using.  \n\nThere are numerous reasons to want to better understand why our models make the predictions that they do.  \n\n- The growing set of tools to interpret our models can help address our **explanatory questions**\n- But they can also help us **find errors** in our models\n- And they can **detect possible bias** (we will focus explicitly on algorithmic bias in later units)\n\n--------------------------------------------------------------------------------\n\nFeature importance metrics are an important tool to better understand how our models work.\n\nThese metrics help us understand which features in our models contribute most to the predictions that the model makes.  \n\nFor some models, interpretation and identification of important features is easy.  \n\nFor example, if we standardize the features in a glm or glmnet model, we can interpret the absolute magnitude of the parameter estimates (i.e., the coefficients) as an index of the global (i.e., across all observations) importance of each feature.  \n\n- You can use the [vip]() package to extract these **model-specific** feature importance metrics, but you can often just get them directly from the model as well\n- More info on the use of vip package is available [elsewhere](https://cran.r-project.org/web/packages/vip/vignettes/vip.html)\n\n--------------------------------------------------------------------------------\n\nBut for other models, we need different approaches.  \n\nThere are many **model-agnostic** (i.e., can be used across all statistical algorithms) approaches to quantify the importance of a feature, but we will focus on two:  \n\n- Permutation Feature Importance\n- Shapley Values\n\n--------------------------------------------------------------------------------\n\nWe follow [recommendations from the tidymodels folks](https://www.tmwr.org/explain) and use the DALEX and DALEXtra packages for model agnostic approaches to feature importance.\n\n```{r}\nlibrary(DALEX, exclude= \"explain\")\nlibrary(DALEXtra)\n```\n\n--------------------------------------------------------------------------------\n\nLets first get some coding issues accomplished before we dig into the details of the two feature importance metrics\n\nTo calculate these importance metrics, we will need access to the raw features and outcome.\n\n```{r}\nrec_full_prep <- rec_full |> \n  prep(data_all)\n\nfeat_full <-  rec_full_prep |> \n  bake(data_all)\n```\n\n--------------------------------------------------------------------------------\n\nAnd we now will need to fit the full model trained on all the data\n\n```{r}\nfit_full <- \n  logistic_reg(penalty = hp_best_full$penalty,\n               mixture = hp_best_full$mixture) |> \n  set_engine(\"glmnet\") |> \n  fit(disease ~ ., data = feat_full)\n```\n\n--------------------------------------------------------------------------------\n\nWe will need to have a df for the features (without the outcome) and a separate vector for the outcome\n\n- features are easy.  Just select out the outcome\n\n```{r}\nx <- feat_full |> select(-disease)\n```\n\n- For outcome, we need to convert to 0/1 (if classification), and then pull the vector out of the dataframe\n\n```{r}\ny <- feat_full |> \n  mutate(disease = if_else(disease == \"yes\", 1, 0)) |> \n  pull(disease)\n```\n\n--------------------------------------------------------------------------------\n\nWe also need a specific predictor function that will work with the DALEX package\n\nWe will write a custom function that \"wraps\" around our tidymodels `predict()` function\n\nDALEX needs:\n\n- the prediction function to have two parameters named `model` and `newdata` \n- the prediction function must return a vector of probabilites for the positive class for classification problems (for regression, it simply returns a vector of the predicted values for $y$)\n\n```{r}\npredict_wrapper <- function(model, newdata) {\n  predict(model, newdata, type = \"prob\") |> \n    pull(.pred_yes)\n}\n```\n\n--------------------------------------------------------------------------------\n\nWe will also need an `explainer` object based on our model and data\n\nThe `explain_tidymodels()` function in DALEXtra will create (and check) this object for us.\n\n```{r}\nexplain_full <- explain_tidymodels(fit_full, # our model object \n                                   data = x, # df with features without outcome\n                                   y = y, # outcome vector\n                                   # our custom predictor function\n                                   predict_function = predict_wrapper)\n```\n\n--------------------------------------------------------------------------------\n\nFinally, we need to define a custom function for our performance metric as well\n\n- It needs to have two parameters: `observed` and `predicted`\n- We can create a wrapper function around `accuracy_vec()` to fit these needs\n- For accuracy, we need to transform the predicted probabilites from our prediction function to class predictions (e.g.. yes/no)\n- And because we converted our labels to 0/1 in the outcome vector, we need to transform `observed` back to yes/no as well \n\n```{r}\naccuracy_wrapper <- function(observed, predicted) {\n  observed <- fct(if_else(observed == 1, \"yes\", \"no\"),\n                  levels = c(\"yes\", \"no\"))\n  predicted <- fct(if_else(predicted > .5, \"yes\", \"no\"), levels  = c(\"yes\", \"no\"))\n  accuracy_vec(observed, predicted)\n}\n```\n\nWe are now ready to calculate feature importance metrics\n\n--------------------------------------------------------------------------------\n\n### Permutation Feature Importance\n\nThe first model agnostic approach to calculating feature important is called Permutation Feature Importance\n\nThis approach is very straight forward.  This approach says - if we want to calculate the importance of any specific feature, we can compare our performance metric using the original features to the performance metric we get if we permute (i.e., shuffle) the values for the feature we are evaluating.  \n\nBy randomly shuffling the values for the feature, we break the relationship between that feature and the outcome so it no longer contributes to the predictions.   If performance doesn't change much, then that feature is not important.  If performance goes down a lot, the feature is important.  \n\n- The function can provide `raw` performance (will give us performance for the non-permuted model and then performance for the model with each feature permuted, one at a time) \n- `difference` performance measure, which is the difference between the permuted model and the non-permuted mode, separately for each feature\n- `ratio` performance measure, which is ($\\frac{permuted}{original}$), separately for each feature\n\n--------------------------------------------------------------------------------\n\nTo calculate accuracy after permuting each feature, we use `model_parts()`.  We pass in \n\n- our explainer object\n- set the type (`raw` in this example)\n- indicate our custom accuracy function\n- set B to indicate number of permutations to perform\n```{r}\nset.seed(123456)\nimp_permute <- model_parts(explain_full, \n                               type = \"raw\", \n                               loss_function = accuracy_wrapper,\n                               B = 100)\n```\n\n--------------------------------------------------------------------------------\n\nLets look at what this function returns\n\n- the first row contains the accuracy for the full model (with no features permuted)\n- last row is a baseline models (performance with all features permuted)\n- Other row show the accuracy of the model when that specific feature is permuted\n\n```{r}\nimp_permute\n```\n\n--------------------------------------------------------------------------------\n\nWe can use the built in plot function from DALEX to display this\n\n```{r}\nplot(imp_permute)\n```\n\n--------------------------------------------------------------------------------\n\nOr we can plot it directly.  Here is an example from the [tidymodels folks](https://www.tmwr.org/explain)    \n```{r}\n#| fig-height: 4\n\nfull_model <- imp_permute |>  \n    filter(variable == \"_full_model_\")\n  \nimp_permute |> \n  filter(variable != \"_full_model_\",\n         variable != \"_baseline_\") |> \n  mutate(variable = fct_reorder(variable, dropout_loss)) |> \n  ggplot(aes(dropout_loss, variable)) +\n  geom_vline(data = full_model, aes(xintercept = dropout_loss),\n             linewidth = 1.4, lty = 2, alpha = 0.7) +\n  geom_boxplot(fill = \"#91CBD765\", alpha = 0.4) +\n  theme(legend.position = \"none\") +\n  labs(x = \"accuracy\", \n       y = NULL,  fill = NULL,  color = NULL)\n```\n\n--------------------------------------------------------------------------------\n\nWe can also permute a set of features to quantify the contribution of the full set\n\nThis is what we would want for our example, were we want to know the contribution of the four features that represent our exercise test.\n\nTo do this, we pass in a list of vectors of the groups.  Here we provide just one group that we name `exer_test`\n```{r}\nset.seed(123456)\nimp_permute_group <- model_parts(explain_full, \n                               type = \"raw\", \n                               loss_function = accuracy_wrapper,\n                               B = 100,\n                               variable_groups = list(exer_test = \n                                                        c(\"exer_ang_yes\",\n                                                          \"exer_max_hr\",\n                                                          \"exer_st_depress\", \n                                                          \"exer_st_slope_downslope\")))\n```\n\n--------------------------------------------------------------------------------\n\nThe results show that permuting these four features as a set drops accuracy from 0.838 to 0.713\n```{r}\nimp_permute_group\n```\n\n--------------------------------------------------------------------------------\n\n### Shapley Values\n\nShapley values provide insight on the importance of any feature to the prediction for a single observation - often called **local importance** (vs. global importance as per the permutation feature importance measure above).\n\nShapley values can also be used to index global importance by averaging the local shapley values for a feature across all (or a random sample) of the observations.\n\n--------------------------------------------------------------------------------\n\nShapley values are derived from Coalition Game Theory.  \n\nThey provide the average marginal contribution to prediction (for a single observation) of a feature value across all possible coalitions of features (combinations of sets of features from the null set to all other features).\n\n@IML provides a [detailed account](https://christophm.github.io/interpretable-ml-book/shapley.html#shapley) of the theory behind these values and how they are calculated which I will not reproduce here.\n\n--------------------------------------------------------------------------------\n\nLets calculate Shapley Values for the first observation in our dataset\n\nTheir features values were\n```{r }\nobs_num <- 1\nx1 <- x |> \n  slice(obs_num) |> \n  glimpse()\n```\n\n--------------------------------------------------------------------------------\n\nAnd we can get Shapley values using `predict_parts()`\n```{r}\nsv <- predict_parts(explain_full, \n                    new_observation = x1,\n                    type = \"shap\",\n                    B = 25)\n```\n\n--------------------------------------------------------------------------------\n\nThere is a built in plot function for shap values\n\nFor this first observation\n\n- The values for each feature are listed in the left margin\n- Bars to the right (e.g., sex_male) indicate that their feature value increases their probability of disease\n- Bars to the left indicate that their feature value decreases their probability of disease  \n```{r}\nplot(sv)\n```\n\n--------------------------------------------------------------------------------\n\nWe can use these Shapley values for the local importance of the features for each observation to calculate the global importance of these features.  \n\nFeatures that have big absolute Shapley values on average across observation are more important.   Let's calculate this.\n\nFirst we need a function to get shapley values for each observation (along with the feature values for a nicer plot)\n\n```{r}\nget_shaps <- function(df1){\n  predict_parts(explain_full, \n                new_observation = df1,\n                type = \"shap\",\n                B = 25) |> \n    filter(B == 0) |> \n    select(variable_name, variable_value, contribution) |> \n    as_tibble()\n}\n```\n\n--------------------------------------------------------------------------------\n\nAnd then we can map this function over observations to get the Shapley values for each observation\n\n```{r}\n#| label: calc_global_shaps\n\nlocal_shaps <- cache_rds(\n  expr = {\n    x |>\n      slice_sample(prop = 1/5) |> # take random sample to reduce computation time\n      mutate(id = row_number()) |>\n      nest(.by = id, .key = \"dfs\") |>   # nest a dataframe for each observation\n      mutate(shaps = map(dfs, \\(df1) get_shaps(df1))) |> \n      select(-dfs) |>\n      unnest(shaps)\n  },\n  rerun = rerun_setting,\n  dir = \"cache/011/\",\n  file = \"local_shaps\")\n```\n\n--------------------------------------------------------------------------------\n\nHere is what we get from applying the function over observations\n\n```{r}\nlocal_shaps |> head()\n```\n\n**Programming note**:  This code demonstrates another nice R programming technique using `nest()` and `unnest()` in combination with `map()` and list-columns. For more info, see [this chapter](https://r4ds.had.co.nz/many-models.html) in @RDS and the vignette on nesting (`vignette(\"nest\")`).\n\n--------------------------------------------------------------------------------\n\nNow that we have Shapley values for all observations, we can calculate the mean absolute Shapley value across observations and plot it.\n\n- Across all observations, `ca` contributes to an average change of .06 from the mean predicted probability of disease.\n- One of the features from our exercise test, `exer_ang_yes`, contributes about .05 change from mean predicted probability of disease.\n- The other `exer_` features are not far behind.\n\n```{r}\n#| fig-height: 4\n\nlocal_shaps |>\n  mutate(contribution = abs(contribution)) |>\n  group_by(variable_name) |>\n  summarize(mean_shap = mean(contribution)) |>\n  arrange(desc(mean_shap)) |>\n  mutate(variable_name = factor(variable_name),\n         variable_name = fct_reorder(variable_name, mean_shap)) |>\n  ggplot(aes(x = variable_name, y = mean_shap)) +\n  geom_point() +\n  coord_flip()\n```\n\n--------------------------------------------------------------------------------\n\nFor a more advanced plot (a sina plot; not displayed here) we could superimpose the individual local Shapley values and color them based on the feature score.   \nThis would allow us to show the direction of the relationship between the Shapley values and feature values.  \n\nSee FIGURE 9.26 in @IML for an example of this type of plot.\n\n--------------------------------------------------------------------------------\n\nShapley values are attractive relative to other approaches because\n\n- They have a solid theoretical basis\n- Sound statistical properties (Efficiency, Symmetry, Dummy and Additivity - see @IML)\n- Can provided a unified perspective across both local and global importance.\n\n--------------------------------------------------------------------------------\n\nHowever, they can be VERY time consuming to calculate (particularly if you want to use them for global importance such that you need them for all/many observations).  \n\nThere are computational shortcuts available but even those can be very time consuming in some instances (though XGBoost has a very fast implementation that we use regularly).\n\n(Note that for decision tree based algorithms SHAP provides a more computationally efficient way to estimate Shapley values - see [section 9.6](https://christophm.github.io/interpretable-ml-book/shap.html) in @IML for more detail.)\n\n--------------------------------------------------------------------------------\n\n## Visual Approaches to Understand our Models\n\nWe can also learn about how our features are used to make predictions in our models using visual approaches.   \n\nThere are two key plots that we can use:\n\n- Partial Dependence (PD) Plots\n- Accumulated Local Effects (ALE) Plots\n\n--------------------------------------------------------------------------------\n\n### Partial Dependence (PD) Plots\n\nThe Partial dependence (PD) plot displays the marginal effect of a target feature or combination of features on the predictions from a model.  \n\nIn essence, the prediction for any value of a target feature is the average prediction across cases if we set all cases to have that value for the target feature but their observed values for all other features.\n\nWe can use PD plots to understand whether the relationship between a target feature and the outcome is linear, monotonic, or more complex.  It may also help us visualize and understand if interactions between features exist (if we make a PD plot for two target features).  \n\n--------------------------------------------------------------------------------\n\nThe PD Plot is attractive because \n\n- it is easy to understand (prediction for each feature value averaged across observed values for all other features)\n- if the target feature is uncorrelated with all other features, its interpretation is clear, it is how the average prediction changes as the target features changes values.\n- it is computationally easy to implement\n- it has a causal (for the model, not the real world!) interpretation. This is what happens to the predciction if we manipulate the values of the target feature but hold all other features constant at their observed values.\n\n--------------------------------------------------------------------------------\n\nHowever:\n\n- The assumption that the target feature is not correlated with the other features is likely unrealistic in many/most instances\n- This plot (but also other plot methods) are limited to 1 - 2 features in combination.\n- It may hide effects when interactions exist\n\n--------------------------------------------------------------------------------\n\n### Accumulated Local Effects (ALE) Plots\n\nIf the features are correlated, the partial dependence plot should not be used because the plots will otherwise be based on combinations of the target feature and other features that may never occur (given the feature correlations).\n\nMolnar describes how this problem of correlated features and unrealistic combinations of features can be solved by M-Plots that plot the average effect of a target feature using the conditional values on other features (i.e., only using realistic values for the other features based on their correlations with the target feature).  Unfortunately, this too is sub-optimal because it will confound the effect of the target feature with the effects of the other features that are correlated with it.\n\n--------------------------------------------------------------------------------\n\nAccumulated Local Effects (ALE) plots also use conditional values of other features to solve the correlated features problem.  However, ALE plots solve the confounding problem by calculating **differences** in predictions associated with changes in the target feature rather than average predictions for each value of that target feature. These differences hold the other features values (mostly) constant to remove their effects.  \n\nALE plots are the preferred plot in situations where  you expect your target feature to be correlated with other features (which is likely most situations.)\n\n--------------------------------------------------------------------------------\n\nWe will use the `DALEX` package again to make these PD and ALE plots.\n\nIt will require the explainer object we created earlier for feature importance\n\nOtherwise, the code is very straight-forward.  Here we get the predicted values for an ALE plot to examine the effect of one of the features from our exercise test (`exer_max_hr`) on disease probabilities. \n\nIf we wanted a PD plot, we could simply substitute `partial` for `accumulated`\n\n```{r}\nale <- model_profile(explainer = explain_full,\n                     type = \"accumulated\",\n                     variables = \"exer_max_hr\",\n                     N = NULL)  # to use full sample (default is 100)\n```\n\n--------------------------------------------------------------------------------\n\nThere is a default plot function for these plot object (or you could use the data in the object to make your own ggplot)\n\nThe probability of disease decreases as max hr increases in the exercise test\n```{r}\nale |> plot()\n```\n\n--------------------------------------------------------------------------------\n\n## Summary and Closing Thoughts\n\nWhen pursuing purely explanatory goals with machine learning methods, we can: \n\n- Use resampling with the full dataset to determine appropriate model configuration\n  - Best statistical algorithm\n  - Which covariates\n  - Other \"researcher degrees of freedom\" such as handling of outliers, transformations of predictors\n\n- Use model comparisons (Frequentist or Bayesian) in combination with feature ablation to test effect of feature or set of features\n\n- We can use feature importance measures (permutation or Shapley) to understand the contributions that various features make to prediction for an observation (local) or across observations (global)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"css":["book.css"],"output-file":"l11_explanation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","bibliography":["refs.bib"],"callout-icon":false,"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}