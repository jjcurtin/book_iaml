{"title":"Novel Levels in Held-Out Set(s)","markdown":{"yaml":{"output":"html_document","editor_options":{"chunk_output_type":"console"}},"headingText":"Novel Levels in Held-Out Set(s)","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\n\nWhen you have nominal/ordinal predictors that have levels that are infrequent, you will occasionally find that an infrequent level appears in your held out set (i.e., validation or test) but not in your training set.  This can cause problems when you try to make predictions for these new values.  Specifically, the feature values for this level will be set to NA and therefore, you will get predictions of NA for these observations. \n\nIn this appendix, we demonstrate this problem and our preferred solution given our workflow of classing all nominal/ordinal predictors as factors in our dataframes.\n\n```{r}\n#| include: false\noptions(conflicts.policy = \"depends.ok\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\ntidymodels_conflictRules()\n```\n\n```{r}\n#| message: false\nlibrary(tidyverse) \nlibrary(tidymodels) \ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\n```\n\nMake simple data sets with an outcome (`y`) and one nominal predictor (`x`).  Note that `x` will have a novel value (`foo`) in the test set that wasnt present in the training set.\n```{r}\nn <- 6\ndata_trn <- tibble(y = rnorm(n), \n                   x = rep (c(\"a\", \"b\", \"c\"), n/3)) |>\n  mutate(x = factor(x, levels = c(\"a\", \"b\", \"c\"))) |> \n  print()\n\ndata_test <- tibble(y = c(rnorm(n), rnorm(1)),\n                    x = c(rep (c(\"a\", \"b\", \"c\"), n/3), \"foo\")) |> \n  mutate(x = factor(x, levels = c(\"a\", \"b\", \"c\", \"foo\"))) |> \n  print()\n```\n\nMake a recipe\n```{r}\nrec <- recipe(y ~ x, data = data_trn) %>% \n  step_dummy(x)\n```\n\nPrep the recipe with training data\n```{r}\nrec_prep <- rec |> \n  prep(data_trn)\n```\n\nFeatures for training set.  No problems \n```{r}\nfeat_trn <- rec_prep |> \n  bake(NULL)\n\nfeat_trn |> skim_all()\n```\n\nFeatures for test set.  \n\n- Now we see the problem indicated by the warning about new level in test.\n- We see that one observation is missing for `x` in test.  If we looked closer, we would see this is the observation for `foo`\n```{r}\nfeat_test <- rec_prep |> \n  bake(data_test)\n\nfeat_test |> skim_all()\n```\n\nWe handle this problem of potential new levels in held-out data by inserting `step_novel()` prior to `step_dummy()` in our recipe.\nThis assigns all potential novel (unseen in training) levels to a new category called `new` by default\n\n```{r}\nrec_novel <- recipe(y ~ x, data = data_trn) |>  \n  step_novel(x) |> \n  step_dummy(x)\n```\n\nWhen we now prep this recipe using training data that does not contain `foo` (our novel level we will find in test), everything is fine\n```{r}\nrec_novel_prep <- rec_novel |> \n  prep(data_trn)\n```\n\nWhen we bake features for training data, we see what `step_novel()` did.  It added a new level and therefore a new feature to code the contrast of that level with the reference level.  However, given that this new level was not present in our training data, all observations are assigned a zero for this new feature.\n```{r}\nfeat_trn_novel <- rec_novel_prep |> \n  bake(NULL)\n\nfeat_trn_novel |> bind_cols(data_trn |> select(x)) |> print()\n```\n\nBut now when we bake the test data, this new feature is set to 1 for observations associated with this new level `foo`\n```{r}\nfeat_test_novel <- rec_novel_prep |> \n  bake(data_test)\n\nfeat_test_novel |> bind_cols(data_test |> select(x)) |> print()\n```\n\nAll looks normal when we fit this model to our training features\n```{r}\nfit_novel <-\n  linear_reg() %>% \n  set_engine(\"lm\") %>% \n  fit(y ~ ., data = feat_trn_novel)\n```\n\nHowever, if we look at the parameter estimates, we see that the algorithm was unable to estimate a parameter for `x_foo` because it was a constant in train.  Of course, this makes sense because there were no observations of `foo` in training so the model coouldnt learn how that new level differed from the reference level.\n\n```{r}\nfit_novel %>% tidy()\n```\n\n\nThis model will now generate a warning (*\"prediction from a rank-deficient fit has doubtful cases\"*) when you use this model to make predictions for values it didnt see in the training set.\n\n- The consequence is that the model will predict a `y` value associated with the reference level (coded 0 for all  other dummy features) for all `foo` observations.  This is probably the best we can do for these new (previously unseen) values for x.\n```{r}\npredict(fit_novel, feat_test_novel) |>  \n  bind_cols(feat_test_novel)\n```\n\nYou do not need to use `step_novel()` always.  Just put it into a recipe if you find that there are novel levels in your held-out data (and re-prep the recipe after you add that step of course~)","srcMarkdownNoYaml":"\n\n# Novel Levels in Held-Out Set(s) { .unnumbered}\nWhen you have nominal/ordinal predictors that have levels that are infrequent, you will occasionally find that an infrequent level appears in your held out set (i.e., validation or test) but not in your training set.  This can cause problems when you try to make predictions for these new values.  Specifically, the feature values for this level will be set to NA and therefore, you will get predictions of NA for these observations. \n\nIn this appendix, we demonstrate this problem and our preferred solution given our workflow of classing all nominal/ordinal predictors as factors in our dataframes.\n\n```{r}\n#| include: false\noptions(conflicts.policy = \"depends.ok\")\ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true\")\ntidymodels_conflictRules()\n```\n\n```{r}\n#| message: false\nlibrary(tidyverse) \nlibrary(tidymodels) \ndevtools::source_url(\"https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true\")\n```\n\nMake simple data sets with an outcome (`y`) and one nominal predictor (`x`).  Note that `x` will have a novel value (`foo`) in the test set that wasnt present in the training set.\n```{r}\nn <- 6\ndata_trn <- tibble(y = rnorm(n), \n                   x = rep (c(\"a\", \"b\", \"c\"), n/3)) |>\n  mutate(x = factor(x, levels = c(\"a\", \"b\", \"c\"))) |> \n  print()\n\ndata_test <- tibble(y = c(rnorm(n), rnorm(1)),\n                    x = c(rep (c(\"a\", \"b\", \"c\"), n/3), \"foo\")) |> \n  mutate(x = factor(x, levels = c(\"a\", \"b\", \"c\", \"foo\"))) |> \n  print()\n```\n\nMake a recipe\n```{r}\nrec <- recipe(y ~ x, data = data_trn) %>% \n  step_dummy(x)\n```\n\nPrep the recipe with training data\n```{r}\nrec_prep <- rec |> \n  prep(data_trn)\n```\n\nFeatures for training set.  No problems \n```{r}\nfeat_trn <- rec_prep |> \n  bake(NULL)\n\nfeat_trn |> skim_all()\n```\n\nFeatures for test set.  \n\n- Now we see the problem indicated by the warning about new level in test.\n- We see that one observation is missing for `x` in test.  If we looked closer, we would see this is the observation for `foo`\n```{r}\nfeat_test <- rec_prep |> \n  bake(data_test)\n\nfeat_test |> skim_all()\n```\n\nWe handle this problem of potential new levels in held-out data by inserting `step_novel()` prior to `step_dummy()` in our recipe.\nThis assigns all potential novel (unseen in training) levels to a new category called `new` by default\n\n```{r}\nrec_novel <- recipe(y ~ x, data = data_trn) |>  \n  step_novel(x) |> \n  step_dummy(x)\n```\n\nWhen we now prep this recipe using training data that does not contain `foo` (our novel level we will find in test), everything is fine\n```{r}\nrec_novel_prep <- rec_novel |> \n  prep(data_trn)\n```\n\nWhen we bake features for training data, we see what `step_novel()` did.  It added a new level and therefore a new feature to code the contrast of that level with the reference level.  However, given that this new level was not present in our training data, all observations are assigned a zero for this new feature.\n```{r}\nfeat_trn_novel <- rec_novel_prep |> \n  bake(NULL)\n\nfeat_trn_novel |> bind_cols(data_trn |> select(x)) |> print()\n```\n\nBut now when we bake the test data, this new feature is set to 1 for observations associated with this new level `foo`\n```{r}\nfeat_test_novel <- rec_novel_prep |> \n  bake(data_test)\n\nfeat_test_novel |> bind_cols(data_test |> select(x)) |> print()\n```\n\nAll looks normal when we fit this model to our training features\n```{r}\nfit_novel <-\n  linear_reg() %>% \n  set_engine(\"lm\") %>% \n  fit(y ~ ., data = feat_trn_novel)\n```\n\nHowever, if we look at the parameter estimates, we see that the algorithm was unable to estimate a parameter for `x_foo` because it was a constant in train.  Of course, this makes sense because there were no observations of `foo` in training so the model coouldnt learn how that new level differed from the reference level.\n\n```{r}\nfit_novel %>% tidy()\n```\n\n\nThis model will now generate a warning (*\"prediction from a rank-deficient fit has doubtful cases\"*) when you use this model to make predictions for values it didnt see in the training set.\n\n- The consequence is that the model will predict a `y` value associated with the reference level (coded 0 for all  other dummy features) for all `foo` observations.  This is probably the best we can do for these new (previously unseen) values for x.\n```{r}\npredict(fit_novel, feat_test_novel) |>  \n  bind_cols(feat_test_novel)\n```\n\nYou do not need to use `step_novel()` always.  Just put it into a recipe if you find that there are novel levels in your held-out data (and re-prep the recipe after you add that step of course~)"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":"html_document","warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"css":["book.css"],"output-file":"app_dummy_coding.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","bibliography":["refs.bib"],"callout-icon":false,"editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}