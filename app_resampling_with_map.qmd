---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Map across resamples { .unnumbered}

`fit_resamples()` and `tune_grid()` are tidymodels functions that we use in combination with objects generated from a resampling function (e.g., `vfold_cv()`, `bootstraps()`, etc from the `rsample` package) to get held-out performance estimates for our models.  

- `fit_resamples()` and `tune_grid()` use looping under the hood to accomplish their goals.  `fit_resamples()` loops over the splits generated by our resampling function to get held-out performance estiamtes for a single model configuration.  

- `tune_grid()` also loops over these splits but includes an additional inner loop that loops over the values of our hyper-parameters in a hyper-parameter grid that we create.  

--------------------------------------------------------------------------------

In this appendix, we are going to re-create the functionality of `fit_resamples()` and `tune_grid()` using the `map()` function from the `purrr` package.  This will help us understand how these functions work under the hood and give us a better understanding of how to use them.  It will also give us an alternative way to do resampling if we need it.

Specifically, with respect to using resampling to get held-out performance estimates, we will

- Gain a better understanding of the resampling object that is returns from `bootstraps()` and `vfold_cv()`
- Make more transparent how these functions incorporate loops as part of their computations
- Be able to reproduce these computations, manually for when we can't use these functions directly.
  - This might be if we want to loop over model configurations that are not defined by differece in hyperparameters but instead by other characteristics (e.g., different recipes, different statistical algorithms).  
  - We want to use an algorigthm that is not supported by tidymodels (e.g., we are developing deep neural networks outside of tidymodels by directly using the keras package)
- We want to do nested resampling (e.g., using `bootstraps()` to both select a best model configuration and evaluate that best configuration with the variance benefits that are offered by nested cv relative to using a single held out test set.

--------------------------------------------------------------------------------

More generally, we will also gain a better understanding (and some code examples) of the use of list columns with iteration via `map()`.  

- This has many other uses than just resampling.  
- Wickham has writting about this in more detail [elsewhere](https://r4ds.had.co.nz/many-models.html).

--------------------------------------------------------------------------------

In this appendix, we will work through four separate examples that build in complexity

- First, we will reproduce `fit_resamples()` computations by using `map()` to loop over the splits and fit a single model to each split.  We use separate independent `maps()` for each step
- Next, we will do this again but by wrapping all the steps into one function and using a single call to `map()` to loop that function over the splits.
- The third example, will reproduce `tune_grid()` by using two nested `map()`s to loop over the splits and the hyper-parameter grid.  
- The final example will demonstrate how to do nested resampling using `map()`  Nested resampling includes both an outer and inner loop across different out and inner splits.  There is also an innermost loop across values in a hyper-parameter grid (or any other grid that defines different model configurations) 

--------------------------------------------------------------------------------

## Set up

Lets start all of these examples by....


Loading libraries
```{r}
#| message: false
#| warning: false

library(tidyverse)
library(tidymodels)
```

--------------------------------------------------------------------------------

Creating a simple data set that has 300 observationns and two predictors (`x1` and `x2`) and one outcome (`y`).  The outcome is a linear combination of the two predictors with some noise added. 
```{r}
set.seed(123456)
n_obs <- 300
d <- tibble(x1 = rnorm(n_obs), x2 = rnorm(n_obs), y = 2*x1 + 3*x2 + rnorm(n_obs))
```  

--------------------------------------------------------------------------------

Getting bootstrap resamples of d.  

```{r}
n_boots <- 50
resamples <- bootstraps(d, times = n_boots)
```

`bootstraps()` 

  - Returns an object that two columns and `n_boots` (in this case 50) rows.  Each row is a bootstrap sample of the data.  The columns are:
  - `splits` - contains a bootstrap sample of the data that includes held-in raw data and OOB held-out raw data subsamples
  - `id` - name of the resample
  
```{r}
resamples
```

This resamples object is a tibble (as typical in the tidy framework).  

- However, it uses "list columns" to hold the splits.  
- In a typical tibble, the individual cells in any column contain numeric or character data.  However, this is not required.  A column in a tibble is just a list and therefore, the cells can contain any type of object.  
-  The cells for the `splits` column in this tibble contain splits, a special object created by functions in the `rsample` package that hold resampled datasets.

We can extract the contents of one of these cells using the base R `[[]]` notation

- The first resample used the full 300 observations from d (the last value)
- It make a bootstrap resample of 300 observations from d (the first value) that we can use as held-in data for training models
- There are 115 OOB observations for this split that we can use as held-out data

```{r}
resamples$splits[[1]]
```

--------------------------------------------------------------------------------

We will also need a recipe to create features from our raw data.  Here is a simple recipe that indicate that y will be models on all the other columns (`x1` and `x2`).  We will not do any other feature engineering to keep this example simple.

```{r}
rec <- recipe(y ~ ., data = d)
```

We are now ready to start the first example

## Using map() to replace fit_resamples() - step x step

In this first example, we will combine `map()` with the use of list columns to save all the intermediate products that are produced when fitting and evaluating a single model configuration for a simple linear regression across many (in this case 50) held-out sets created by bootstrapping.


To do this, we will need a function to fit linear models to held-in training data.  We can use the typical tidymodels code here.
```{r}  
fit_lm <- function(held_in) {
  linear_reg() |> 
    set_engine("lm") |> 
    fit(y ~ ., data = held_in)
}
```

--------------------------------------------------------------------------------

Then we use `map()` and list columns to save the individual steps for evaluating the model in each split/resample.  The following steps are done for EACH resample using `map()` or `map2()`

- Prep the recipe with held-in data (in `prep_recs` column)
- Bake the recipe using `new_data = NULL` to get held-in features (in `held_ins`)
- Bake the recipe using `new_data = assessment(split)` to get held-out features (in `held_outs`)
- Fit the model using the held-in features (in `models`)
- Get predictions using the model with the held-out features (in `predictions`)
- Calculate the rmse of the model (in `rmses`)

```{r}
resamples_ex1 <- resamples |> 
  mutate(prep_recs = map(splits, 
                         \(split) prep(rec, training = analysis(split))),
         held_ins = map2(resamples$splits, prep_recs, 
                         \(split, prep_rec) bake(prep_rec, new_data = NULL)),
         held_outs = map2(resamples$splits, prep_recs, 
                          \(split, prep_rec) bake(prep_rec, 
                                                  new_data = assessment(split))),
         models = map(held_ins, 
                      \(held_in) fit_lm(held_in)),
         predictions = map2(models, held_outs, 
                            \(model, held_out) predict(model, held_out)$.pred),
         rmses = map2_dbl(predictions, held_outs, 
                           \(pred, held_out) rmse_vec(held_out$y, pred)))
```

--------------------------------------------------------------------------------

The pipline above creates a tibble with columns for each of the intermediate products and the rmse/error of the model in each resample.  

- All but the last columns are list columns that can hold objects of any time (e.g., prepped recipes, data frames, model objects).  
- The final column is a double column that holds the numeric rmse of the model in each resample.  That is why we used `map_dbl()` to create the rmses column.
```{r}
resamples_ex1 |> glimpse()
```

--------------------------------------------------------------------------------

We can now look at rmses across the 50 bootstraps.  For example, we can make a histogram using ggplot from the errors column in the fits tibble
```{r}
resamples_ex1 |> 
  ggplot(aes(rmses)) +
  geom_histogram(binwidth = 0.05)
```

And we can summarize the min, max, mean, median and stdev of the error column in the fits tibble
```{r}
resamples_ex1 |> 
  summarize(n = n(),
            min = min(rmses), 
            max = max(rmses), 
            mean = mean(rmses), 
            median = median(rmses),
            std_dev = sd(rmses))
```

--------------------------------------------------------------------------------

Easy peasy!  

- This first example has demonstrated the use of `map()` and list columns, which has many uses.
- This first example also makes clear what `fit_resamples()` is doing.
- It also gives you an alternative workflow in case you can't use `fit_resamples()`. 
  - This might occur if you are training deep neural networks with keras directly. 
  - In that instance, you might use the `fit()` function from keras to fit the model and then use `predict()` to get predictions.  But you could still use the functions from the `rsample` package to get a resampled object (e.g., using `bootstraps()`) and you could use performance metrics (e.g., `rmse_vec()`) from the yardstick package.

But remember, if you can (and in most instances, you can), it is easier to still using `fit_resamples()` to get your held-out performance estimates.
```{r}
resamples_tidy_ex1 <-
  linear_reg() |> 
    set_engine("lm") |> 
    fit_resamples(preprocessor = rec, 
                  resamples = resamples, 
                  metrics = metric_set(rmse))

resamples_tidy_ex1 |> 
  collect_metrics()

resamples_tidy_ex1 |> 
  collect_metrics(summarize = FALSE)
```

## Using map() to replace fit_resamples() - one function

If we wanted to generate the held-out error using resampling but didnt need/want the intermediate products, we could wrap all the steps in one function and just map that single function.  

- We might do this if we are working with big datasets and saving all the intermediate products requires too much memory.
- Of course, we could also blend the this example with the previous example to save some but not all the intermediate products.

--------------------------------------------------------------------------------

Here is a function that takes a split and a recipe and returns the rmse of the model fit to the held-in data and evaluated on the held-out data.  It does all the steps we did in the previous example but in one function.  We will use this function to replace all the intermediate steps in the previous example.

```{r}
fit_and_eval <- function(split, rec) {
  # prep the recipe with held-in data
  prep_rec <- prep(rec, training = analysis(split))
  
  # bake the recipe using new_data = NULL to pull out the held-in features
  held_in <- bake(prep_rec, new_data = NULL)
  
  # bake the recipe using new_data = assessment(split) to get held-out features
  held_out <- bake(prep_rec, new_data = assessment(split))
  
  # fit the model using the held-in features
  model <- 
    linear_reg() |> 
    set_engine("lm") |> 
    fit(y ~ ., data = held_in)
  
  # get predictions using the model with the held-out features
  pred <- predict(model, held_out)$.pred
  
  # calculate the accuracy of the model
  rmse_vec(held_out$y, pred)
}
```

--------------------------------------------------------------------------------

Now map this function over the splits to get a vector of rmse.  Same results, but not saving intermediate steps by using one function.
```{r}
resamples_ex2 <- resamples |> 
  mutate(errors = map_dbl(splits, \(split) fit_and_eval(split, rec)))
```

Here is what the resamples_ex2 tibble now looks like
```{r}
resamples_ex2
```

--------------------------------------------------------------------------------

And here we demo getting overall held-out performance details across the 50 bootstraps.

```{r}
resamples_ex2 |> 
  summarize(n = n(),
            min = min(errors), 
            max = max(errors), 
            mean = mean(errors), 
            median = median(errors),
            std_dev = sd(errors))
```


## Using two map()s to replace tune_grid()

Now we can make this a bit more complicated by adding a grid of hyperparameters to tune.  

- Lets keep it simple and tune only k in a knn model.  
- To tune k, we would normally use `tune_grid()` but we can do it again with two loops using `map()`.  
- We use an outer `map()` to loop over the resamples (as we did in the last two examples) and an inner `map()` to loop over the values of k 

Lets start by setting up a grid of values of k to tune over.
```{r}
grid_k = tibble(neighbors = c(3, 6, 9, 12, 15, 18))
```

---------------------------------------------------------------------------------

We will use a single function to repeatedly fit and eval over our grid of parameters.
```{r}
eval_grid <- function(split, rec, grid_k) {
 
  # get held-in and held-out features for split 
  # we calculate features inside the function where we fit all models across the grid 
  # because we want to make sure we only need to prep and bake the recipe once
  # per split.  Otherwise, we would waste a lot of computational time.
  prep_rec <- prep(rec, training = analysis(split))
  held_in <- bake(prep_rec, new_data = NULL)
  held_out <- bake(prep_rec, new_data = assessment(split))

  # function to fit and eval model for a specific k using held-in/held-out
  # for this split
  fit_eval <- function(k, held_in, held_out) {
    model <- 
      nearest_neighbor(neighbors = k) |>   
        set_engine("kknn") |>   
        set_mode("regression") |>  
        fit(y ~ ., data = held_in)
    
    pred <- predict(model, held_out)$.pred
   
    # lets put k and rmse in a tibble and return that for each split 
    tibble(k = k, 
           rmse = rmse_vec(held_out$y, pred))
  }
  
  # loop through grid_k and fit/eval model for each k 
  # this is the inner loop from tune_grid()
  # use list_rbind() to bind the separate rows for each tibble into one larger tibble
  grid_k$neighbors |> 
    map(\(k) fit_eval(k, held_in, held_out)) |> 
    list_rbind()
}
```

-------------------------------------------------------------------------------

Now we map this function over the 50 bootstrap splits. 

- This is the outer loop from `tune_grid()`.  
- `eval_grid()` will return a tibble with rows for each value of k.  We will save one tibble for each split in a list column called `rmses``. 

```{r}
resamples_ex3 <- resamples |> 
  mutate(rmses = map(splits, 
              \(split) eval_grid(split, rec, grid_k)))
```

--------------------------------------------------------------------------------

The `rmses` column contains the rmse for each value of k for each split/resample in a tibble.  Each tibble has 6 rows (one for each k) and 2 columns (k and rmse).
```{r}
resamples_ex3
```

Lets take a look at one of these tibbles to make this structure clearer.  The same tibble format is saved for all fifty bootstrap splits (with different values for `rmse` of course!)

```{r}
resamples_ex3$rmses[[1]]
```

-----------------------------------------------------------------------------

We can `unnest()` the `rmses` column to get a tibble with one row for each k value in each resample.  

- `unnest()` is used frequently when a list column contains tibbles and you want to combine those tibbles into more traditional tibble without the list column.  
- No need to display the original splits column so we will select it out. 
```{r}
resamples_ex3 |> 
  unnest(rmses) |> 
  select(-splits) |>
  print(n = 30)
```

--------------------------------------------------------------------------------

We can pipe this unnested tibble into a `group_by()` and `summarize()` to get the median (or mean) across resamples and then arrange to find the best k 

```{r}
resamples_ex3 |> 
  unnest(rmses) |> 
  select(-splits) |>
  group_by(k) |> 
  summarize(n = n(),
            mean_rmse = mean(rmse)) |> 
  arrange(mean_rmse)
```

-------------------------------------------------------------------------------

The example makes it clear that using resampling to tune a grid of hyperparameters is just a matter of looping over the resamples in an outer loop and looping over a grid of hyperparameters in an inner loop. 

You might use this approach

- if you wanted to select among model configurations that different by something other than hyper-parameters (e.g., different recipes, different statistical algorithms).  
- Or if you wanted to fit models not supported by tidymodels.

--------------------------------------------------------------------------------

But of course, when you can use it, using `tune_grid()` is easier because it takes care of the nested looping internally.
```{r}
resamples_tidy_ex3 <- 
  nearest_neighbor(neighbors = tune()) |>   
    set_engine("kknn") |>   
    set_mode("regression") |>  
    tune_grid(preprocessor = rec, 
              resamples = resamples, 
              grid = grid_k, 
              metrics = metric_set(rmse))

resamples_tidy_ex3 |> 
  collect_metrics() |> 
  arrange(mean)
```

## Using map()s to do nested cv

Now lets do the most complicated version of this.   Nested resampling involves looping over outer splits where the held out data are test sets used to evaluate best model configurations for each outer split and the inner loop makes validation sets that are used to select the best model configuration for each outer fold.  However, if we are tuning a grid of hyperparameters, there is even a further nested loop inside the inner resampling loop to get performance metrics for each value of the hyperparameter in the validation sets.

`rsample` supports creating a nested resampling object.  

- You can specify different resampling for the inner and outer loops.  
- k-fold for the outer loop and bootstraps for the inner loop is a common choice.
- However, neither `fit_resamples()` or `tune_grid()` support nested resampling.  So we will always need to use nested `map()` to do this ourselves.

--------------------------------------------------------------------------------

First, lets make the nested resampling object and explore it a bit

- We will use 5-fold cv for the outer loop
- We will use 10 bootstraps for the inner loop
- These numbers were selected only to make the computations faster.  You may need more splits.
```{r}
resamples_nested <- d |> 
  nested_cv(outside = vfold_cv(v = 5), inside = bootstraps(times = 10))
```

Lets take a look at it.  

- It has five rows for each of the five outer splits.  The outer splits are the k-folds.
- The inner_resamples column contains the inner splits associated with each outer k-fold split.  Each inner split is a bootstrap resample with 10 bootstraps.

```{r}
resamples_nested
```

Lets look a little more carefully at this structure because its critical to understanding nested cv. 

- Below we pull out and look at the first outer k-fold split. 
- The total sample size is 300 and the outer k-fold split has 60 observations held-out to eventually use as a test set and 240 held-in that will eventually be used as training data when we train models in the outer loop to get our final performance metrics for best values of k.  We will also use these held-in data in the inner loop.
```{r}
resamples_nested$splits[[1]]

# I prefer to work with this resampled objects using base R notation
# however you could do the same using piped tidy code
# resamples_nested |> 
#   slice(1) |> 
#   pull(splits)
```

Now look below at the inner resamples for the first outer k-fold split.

- For each outer k-fold split, we take the held-in data (240 observations in this case) and split it further, using the inner resampling method (10 bootstraps here).
- Notice that each of the 10 bootstraps associated with the first outer k-fold split have 240 observation (because we used the held-in data from that outer k-fold split).  These bootstrap resamples will be used as training data for the inner loop of nested.  We will train models with various values of k with these data
- Notice also that each of these 10 boostraps have held-out (OOB) observations that will be used as validation sets for the inner loop of nested.  We will use these held-out validation sets to calculate performance metrics for the models with different value of k.  This will let us select the best value of k for each outer split.

```{r}
resamples_nested$inner_resamples[[1]]
```

-------------------------------------------------------------------------------

Now that we have a resamples object to use for nested cv, lets get some functions together to calculate rmses for inner validation sets and outer test sets

We will need a function again that takes a split, uses the recipe to get held-in/held-out features, and then fits and evaluates a model for each value of k in the grid.  This is the exact same function as we used earlier (because we are using knn again).   We include it below again for your review.

- We will use this function twice.
- In the inner loop of our nested cv, we will map this function over all 10 of our bootstraps associated with an outer split. 
- In the outer loop of our nested cv, we will map this function over all 5 of our outer splits using the best value of k that was identified for each outer split using its respective 10 bootstraps.
```{r}
#| eval: false

eval_grid <- function(split, rec, grid_k) {
 
  # get held-in and held-out features for split 
  prep_rec <- prep(rec, training = analysis(split))
  held_in <- bake(prep_rec, new_data = NULL)
  held_out <- bake(prep_rec, new_data = assessment(split))

  # function fit fit and eval model for a specific lambda and resample
  fit_eval <- function(k, held_in, held_out) {
    model <- 
      nearest_neighbor(neighbors = k) |>   
        set_engine("kknn") |>   
        set_mode("regression") |>  
        fit(y ~ ., data = held_in)
    
    pred <- predict(model, held_out)$.pred
    
    # lets put k and rmse in a tibble and return that for each split 
    tibble(k = k, 
           rmse = rmse_vec(held_out$y, pred))
  }
  
  # loop through grid_k and fit/eval model for each k 
  # this is the inner loop
  # use list_rbind() to bind the separate rows for each tibble into one larger tibble
  grid_k$neighbors |> 
    map(\(k) fit_eval(k, held_in, held_out)) |> 
    list_rbind()
}
```

--------------------------------------------------------------------------------

To loop eval_grid over the 10 bootstraps in the nested cv inner loop, we will need another simple function that applies our `eval_grid()` over each bootstrap within a set of 10 and binds the results into a single tibble.  
```{r}
bind_bootstraps <- function(bootstraps, rec, grid_k) {
 
  bootstraps$splits |>  
    map(\(bootstrap_split) eval_grid(bootstrap_split, rec, grid_k)) |> 
    list_rbind()
}
```

--------------------------------------------------------------------------------  

Now we are ready to get performance metrics for each k in `grid_k` for each of the inner 10 bootstraps in each of the five outer k-folds splits. Remember that `bind_bootstraps()` just calls `eval_grid()` for each of the 10 bootstraps in the inner loop and binds the results.  

```{r}
resamples_nested_ex4 <- resamples_nested |> 
  mutate(inner_rmses = map(inner_resamples, 
                          \(inner_resample) bind_bootstraps(inner_resample, 
                                                            rec, 
                                                            grid_k)))
```

Lets look at what we just added to our resamples object

- We now have a tibble with 60 rows and 2 columns associated with each set of 10 inner bootstrap splits.
```{r}
resamples_nested_ex4 
```

If we look at one of them, we see

- The 60 rows are because we have 10 boostraps for each of the 6 values of k in the grid.  So 10 * 6 = 60 rmses
- we have columns for k and rmse
```{r}
resamples_nested_ex4$inner_rmses[[1]]
```

--------------------------------------------------------------------------------

We now need to calculate the best k for each of the sets of 10 boostraps (associated with one outer k-fold split). To do this, we average the 10 rmses together for each value of k and then choose the k with the lowest rmse.  We will write a function to do this because we can then map that function over each of the sets of 10 bootstraps associated with each outer split. 

```{r}
get_best_k <- function(rmses) {
  rmses |>  
    group_by(k) |> 
    summarize(mean_rmse = mean(rmse)) |> 
    arrange(mean_rmse) |> 
    slice(1) |> 
    pull(k)
}
```

And then map it across the sets of rmses for each outer k-fold splilt.

```{r}
resamples_nested_ex4 <- resamples_nested_ex4 |> 
  mutate(best_k = map_dbl(inner_rmses, \(rmses) get_best_k(rmses)))
```

Now we have determined the best value of k for each of the 5 outer folds.  
```{r}
resamples_nested_ex4
```

--------------------------------------------------------------------------------

We can now move up to the outer k-fold splits.  We will use the best k for each outer fold to fit a model using the held-in data from the outer fold and then evaluate that model using the held-out test data.  Those test data were NEVER used before so the will allow us to see how that model with a best value of k (selected by bootstrap resampling) performs in new data

We can reuse the `eval_grid()` function we used before to fit and evaluate the model using the held-in data and the held-out test data.  But now we just use one value of k, the one that was best for each fold

```{r}
resamples_nested_ex4 <- resamples_nested_ex4 |> 
  mutate(test_rmse = map2(splits, best_k, 
                               \(split, k) eval_grid(split, rec, tibble(neighbors = k))))
```

---------------------------------------------------------------------------------

We can pull the one row tibbles out of this final column and bind them together to get a tibble with one row for each outer fold.  We have retained the best value of k for each fold for our information (these don't need to be the same for each k-fold split).  
```{r}
resamples_nested_ex4$test_rmse |> 
  list_rbind() |> 
  mutate(outer_fold = 1:length(resamples_nested_ex4$test_rmse)) |> 
  relocate(outer_fold)
```

If we want to know the true best k to use when we train a final model to implement using all our data, we need select it by using our inner reasampling method (10 boostraps) with all our data.  

We could then train our final implementation model by fitting a model to all our data using this value of k.


## Final notes - parallel processing

All of these examples were done without the use of parallel processing.  `fit_resamples()` and `tune_grid()` can use a parallel backend if you set it up.  

- You could modify our code to implement `map()` in parallel using `future_map()` from the `furrr` package.
- For our `fit_resamples()` examples, there is only one `map()` or several independent ones.  None are nested.  Switch them all to `future_map()`. 
- For our `tune_grid()` example, there are two nested `maps()`.  In most instances, you will want to switch the outer loop `map()` to `future_map()` and leave the inner `map()` as is.
- For our nested example, there are three nested `map()`s.  In most instances, you will want to switch that outermost `map()` (across outer splits) to `future_map()` and leave the inner two `map()`s as is. - See our [post](https://jjcurtin.github.io/book_dwvt/parallel_processing.html) on setting up parallel backends for more info on how to do that 